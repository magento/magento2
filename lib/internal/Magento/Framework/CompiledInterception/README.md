### ABOUT

This component changes the way Magento 2 generates Interceptor classes (a mechanism that allows plugins to work together).

Instead of generating boilerplate code it compiles the Interceptor using information from source code. 
This makes plugins slightly faster and as Magento uses a lot of plugins, even at its core, it lowers request time by ~10%.
This is important in places where there is a lot of non-cached PHP logic going on (for example admin panel is noticeably faster).

The default method uses code that is called on nearly each method to see if there are any plugins connected, in generated code this is not required and call-stack is reduced.

Having plugins called directly also makes code easier to debug and bugs easier to find.

The Interceptors generated by this plugin are 100% compatible with the ones generated by Magento by default, so there is no need to change anything in your plugins.

### ENABLING

To use compiled interceptors please add following preference to your di.xml
```
<preference for="Magento\Framework\Interception\PluginListInterface" type="Magento\Framework\CompiledInterception\Generator\CompiledPluginList" />
<preference for="Magento\Framework\Interception\Code\Generator\InterceptorInterface" type="Magento\Framework\CompiledInterception\Generator\CompiledInterceptor" />
<type name="Magento\Setup\Module\Di\App\Task\Operation\Interception">
    <arguments>
        <argument name="interceptorGeneratorClass" xsi:type="string">Magento\Framework\CompiledInterception\Generator\CompiledInterceptor</argument>
    </arguments>
</type>
```

Clear generated files and cache:

`rm -rf generated/* && bin/magento cache:clean`

### DISABLING

Remove preferences from `app/etc/di.xml`, remove module and clear cache and generated files.

### TECHNICAL DETAILS 

Instead of interceptors that read plugins config at runtime like this:

```
public function methodX($arg) {
    $pluginInfo = $this->pluginList->getNext($this->subjectType, 'methodX');
    if (!$pluginInfo) {
        return parent::methodX($arg);
    } else {
        return $this->___callPlugins('methodX', func_get_args(), $pluginInfo);
    }
}
```

This generator generates static interceptors like this:


```
public function methodX($arg) {
    switch(getCurrentScope()){
        case 'frontend':
            $this->_get_example_plugin()->beforeMethodX($this, $arg);
            $this->_get_another_plugin()->beforeMethodX($this, $arg);
            $result = $this->_get_around_plugin()->aroundMethodX($this, function($arg){
                return parent::methodX($arg);
            });
            return $this->_get_after_plugin()->afterMethodX($this, $result);
        case 'adminhtml':
            // ...
        default:
            return parent::methodX($arg);
    }
}
```


#### PROS

* Easier debugging. 
  * If you ever stumbled upon `___callPlugins` when debugging you should know how painful it is to debug issues inside plugins.
  * Generated code is decorated with PHPDoc for easier debugging in IDE

* Fastest response time (5%-15% faster in developer and production mode)
  * No redundant calls to `___callPlugins` in call stack.
  * Methods with no plugins are not overridden in parent at all.
  
* Implemented as a module and can be easily reverted to the default `Generator\Interceptor`

#### CONS

* Each time after making change in etc plugins config, `generated/code/*` and `var/cache/*` needs to be purged
* As this does not load plugins at runtime, might not work in an edge case of plugging into core Magento classes like `PluginsList` etc.
