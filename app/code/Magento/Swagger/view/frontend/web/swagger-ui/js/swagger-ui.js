/**
 * swagger-ui - Swagger UI is a dependency-free collection of HTML, JavaScript, and CSS assets that dynamically generate beautiful documentation from a Swagger-compliant API
 * @version v2.1.1
 * @link http://swagger.io
 * @license Apache-2.0
 *
 * The original name of this file, as part of the swagger-ui package, was dist/index.html.
 *
 * Modified by Magento, Modifications Copyright Â© Magento.
 */
(function () {
    this['Handlebars'] = this['Handlebars'] || {};
    this['Handlebars']['templates'] = this['Handlebars']['templates'] || {};
    this['Handlebars']['templates']['apikey_button_view'] = Handlebars.template({
        'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '<!--div class=\'auth_button\' id=\'apikey_button\'><img class=\'auth_icon\' alt=\'apply api key\' src=\'images/apikey.jpeg\'></div-->\n<div class=\'auth_container\' id=\'apikey_container\'>\n  <div class=\'key_input_container\'>\n    <div class=\'auth_label\'><label for=\'input_apiKey_entry\'>' +
                escapeExpression((helper = (helper = helpers.keyName || (depth0 != null ? depth0.keyName : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'keyName','hash': {},'data': data
            }) : helper)) +
                    '</label></div>\n    <input placeholder=\'api_key\' class=\'auth_input\' id=\'input_apiKey_entry\' name=\'apiKey\' type=\'text\'/>\n    <div class=\'auth_submit\'><a class=\'auth_submit_button\' id=\'apply_api_key\' href=\'#\' data-sw-translate>apply</a></div>\n  </div>\n</div>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['basic_auth_button_view'] = Handlebars.template({
        'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            return '<div class=\'auth_button\' id=\'basic_auth_button\'><img class=\'auth_icon\' src=\'images/password.jpeg\'></div>\n<div class=\'auth_container\' id=\'basic_auth_container\'>\n  <div class=\'key_input_container\'>\n    <div class="auth_label"><label for="input_username" data-sw-translate>Username</label></div>\n    <input placeholder="username" class="auth_input" id="input_username" name="username" type="text"/>\n    <div class="auth_label"><label for="password" data-sw-translate>Password</label></div>\n    <input placeholder="password" class="auth_input" id="input_password" name="password" type="password"/>\n    <div class=\'auth_submit\'><a class=\'auth_submit_button\' id="apply_basic_auth" href="#">apply</a></div>\n  </div>\n</div>\n\n';
        },'useData': true
    });
    this['Handlebars']['templates']['content_type'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    var stack1, buffer = '';

                    stack1 = helpers.each.call(depth0, depth0 != null ? depth0.produces : depth0, {
                        'name': 'each','hash': {},'fn': this.program(2, data),'inverse': this.noop,'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }

                    return buffer;
                },'2': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 buffer = '	<option value="';

            stack1 = lambda(depth0, depth0);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '">';
            stack1 = lambda(depth0, depth0);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</option>\n';
        },'4': function (depth0, helpers, partials, data) {
            return '  <option value="application/json">application/json</option>\n';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<label data-sw-translate for="' +
                escapeExpression((helper = (helper = helpers.contentTypeId || (depth0 != null ? depth0.contentTypeId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'contentTypeId','hash': {},'data': data
            }) : helper)) +
                '">Response Content Type</label>\n<select name="contentType" id="' +
                escapeExpression((helper = (helper = helpers.contentTypeId || (depth0 != null ? depth0.contentTypeId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'contentTypeId','hash': {},'data': data
            }) : helper)) +
                '">\n';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.produces : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.program(4, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</select>\n';
        },'useData': true
    });
    'use strict';

    $(function () {

        // Helper function for vertically aligning DOM elements
        // http://www.seodenver.com/simple-vertical-align-plugin-for-jquery/
        $.fn.vAlign = function () {
            return this.each(function () {
                var ah = $(this).height();
                var ph = $(this).parent().height();
                var mh = (ph - ah) / 2;

                $(this).css('margin-top', mh);
            });
        };

        $.fn.stretchFormtasticInputWidthToParent = function () {
            return this.each(function () {
                var p_width = $(this).closest('form').innerWidth();
                var p_padding = parseInt($(this).closest('form').css('padding-left'), 10) + parseInt($(this).closest('form').css('padding-right'), 10);
                var this_padding = parseInt($(this).css('padding-left'), 10) + parseInt($(this).css('padding-right'), 10);

                $(this).css('width', p_width - p_padding - this_padding);
            });
        };

        $('form.formtastic li.string input, form.formtastic textarea').stretchFormtasticInputWidthToParent();

        // Vertically center these paragraphs
        // Parent may need a min-height for this to work..
        $('ul.downplayed li div.content p').vAlign();

        // When a sandbox form is submitted..
        $('form.sandbox').submit(function () {

            var error_free = true;

            // Cycle through the forms required inputs
            $(this).find('input.required').each(function () {

                // Remove any existing error styles from the input
                $(this).removeClass('error');

                // Tack the error style on if the input is empty..
                if ($(this).val() === '') {
                    $(this).addClass('error');
                    $(this).wiggle();
                    error_free = false;
                }

            });

            return error_free;
        });

    });

    function clippyCopiedCallback() {
        $('#api_key_copied').fadeIn().delay(1000).fadeOut();

        // var b = $("#clippy_tooltip_" + a);
        // b.length != 0 && (b.attr("title", "copied!").trigger("tipsy.reload"), setTimeout(function() {
        //   b.attr("title", "copy to clipboard")
        // },
        // 500))
    }

    // Logging function that accounts for browsers that don't have window.console
    function log() {
        log.history = log.history || [];
        log.history.push(arguments);

        if (this.console) {
            console.log(Array.prototype.slice.call(arguments)[0]);
        }
    }

    // Handle browsers that do console incorrectly (IE9 and below, see http://stackoverflow.com/a/5539378/7913)
    if (Function.prototype.bind && console && typeof console.log === 'object') {
        [
            'log','info','warn','error','assert','dir','clear','profile','profileEnd'
        ].forEach(function (method) {
                console[method] = this.bind(console[method], console);
            }, Function.prototype.call);
    }

    window.Docs = {

        shebang: function () {

            // If shebang has an operation nickname in it..
            // e.g. /docs/#!/words/get_search
            var fragments = $.param.fragment().split('/');

            fragments.shift(); // get rid of the bang

            switch (fragments.length) {
                case 1:
                    if (fragments[0].length > 0) { // prevent matching "#/"
                        // Expand all operations for the resource and scroll to it
                        var dom_id = 'resource_' + fragments[0];

                        Docs.expandEndpointListForResource(fragments[0]);
                        $('#' + dom_id).slideto({
                            highlight: false
                        });
                    }
                    break;

                case 2:
                    // Refer to the endpoint DOM element, e.g. #words_get_search

                    // Expand Resource
                    Docs.expandEndpointListForResource(fragments[0]);
                    $('#' + dom_id).slideto({
                        highlight: false
                    });

                    // Expand operation
                    var li_dom_id = fragments.join('_');
                    var li_content_dom_id = li_dom_id + '_content';

                    Docs.expandOperation($('#' + li_content_dom_id));
                    $('#' + li_dom_id).slideto({
                        highlight: false
                    });
                    break;
            }

        },

        toggleEndpointListForResource: function (resource) {
            var elem = $('li#resource_' + Docs.escapeResourceName(resource) + ' ul.endpoints');

            if (elem.is(':visible')) {
                Docs.collapseEndpointListForResource(resource);
            } else {
                Docs.expandEndpointListForResource(resource);
            }
        },

        // Expand resource
        expandEndpointListForResource: function (resource) {
            var resource = Docs.escapeResourceName(resource);

            if (resource == '') {
                $('.resource ul.endpoints').slideDown();

                return;
            }

            $('li#resource_' + resource).addClass('active');

            var elem = $('li#resource_' + resource + ' ul.endpoints');

            elem.slideDown();
        },

        // Collapse resource and mark as explicitly closed
        collapseEndpointListForResource: function (resource) {
            var resource = Docs.escapeResourceName(resource);

            if (resource == '') {
                $('.resource ul.endpoints').slideUp();

                return;
            }

            $('li#resource_' + resource).removeClass('active');

            var elem = $('li#resource_' + resource + ' ul.endpoints');

            elem.slideUp();
        },

        expandOperationsForResource: function (resource) {
            // Make sure the resource container is open..
            Docs.expandEndpointListForResource(resource);

            if (resource == '') {
                $('.resource ul.endpoints li.operation div.content').slideDown();

                return;
            }

            $('li#resource_' + Docs.escapeResourceName(resource) + ' li.operation div.content').each(function () {
                Docs.expandOperation($(this));
            });
        },

        collapseOperationsForResource: function (resource) {
            // Make sure the resource container is open..
            Docs.expandEndpointListForResource(resource);

            if (resource == '') {
                $('.resource ul.endpoints li.operation div.content').slideUp();

                return;
            }

            $('li#resource_' + Docs.escapeResourceName(resource) + ' li.operation div.content').each(function () {
                Docs.collapseOperation($(this));
            });
        },

        escapeResourceName: function (resource) {
            return resource.replace(/[!"#$%&'()*+,.\/:;<=>?@\[\\\]\^`{|}~]/g, '\\$&');
        },

        expandOperation: function (elem) {
            elem.slideDown();
        },

        collapseOperation: function (elem) {
            elem.slideUp();
        }
    };

    'use strict';

    Handlebars.registerHelper('sanitize', function (html) {
        // Strip the script tags from the html, and return it as a Handlebars.SafeString
        html = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');

        return new Handlebars.SafeString(html);
    });

    Handlebars.registerHelper('renderTextParam', function (param) {
        var result, type = 'text',
 idAtt = '';
        var isArray = param.type.toLowerCase() === 'array' || param.allowMultiple;
        var defaultValue = isArray && Array.isArray(param.default) ? param.default.join('\n') : param.default;

        var dataVendorExtensions = Object.keys(param).filter(function (property) {
            // filter X-data- properties
            return property.match(/^X-data-/i) !== null;
        }).reduce(function (result, property) {
            // remove X- from property name, so it results in html attributes like data-foo='bar'
            return result += ' ' + property.substring(2, property.length) + '=\'' + param[property] + '\'';
        }, '');

        if (typeof defaultValue === 'undefined') {
            defaultValue = '';
        }

        if (param.format && param.format === 'password') {
            type = 'password';
        }

        if (param.valueId) {
            idAtt = ' id=\'' + param.valueId + '\'';
        }

        if (isArray) {
            result = '<textarea class=\'body-textarea' + (param.required ? ' required' : '') + '\' name=\'' + param.name + '\'' + idAtt + dataVendorExtensions;
            result += ' placeholder=\'Provide multiple values in new lines' + (param.required ? ' (at least one required).' : '.') + '\'>';
            result += defaultValue + '</textarea>';
        } else {
            var parameterClass = 'parameter';

            if (param.required) {
                parameterClass += ' required';
            }
            result = '<input class=\'' + parameterClass + '\' minlength=\'' + (param.required ? 1 : 0) + '\'';
            result += ' name=\'' + param.name + '\' placeholder=\'' + (param.required ? '(required)' : '') + '\'' + idAtt + dataVendorExtensions;
            result += ' type=\'' + type + '\' value=\'' + defaultValue + '\'/>';
        }

        return new Handlebars.SafeString(result);
    });

    this['Handlebars']['templates']['main'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    var stack1, lambda = this.lambda,
         escapeExpression = this.escapeExpression,
         buffer = '  <div class="info_title">' +
                        escapeExpression(lambda((stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.title : stack1, depth0)) +
                        '</div>\n  <div class="info_description markdown">';

                    stack1 = lambda((stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.description : stack1, depth0);

                    if (stack1 != null) {
                        buffer += stack1;
                    }
                    buffer += '</div>\n';
                    stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.externalDocs : depth0, {
                        'name': 'if','hash': {},'fn': this.program(2, data),'inverse': this.noop,'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }
                    buffer += '  ';
                    stack1 = helpers['if'].call(depth0, (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.termsOfServiceUrl : stack1, {
                        'name': 'if','hash': {},'fn': this.program(4, data),'inverse': this.noop,'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }
                    buffer += '\n  ';
                    stack1 = helpers['if'].call(depth0, (stack1 = (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.contact : stack1) != null ? stack1.name : stack1, {
                        'name': 'if','hash': {},'fn': this.program(6, data),'inverse': this.noop,'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }
                    buffer += '\n  ';
                    stack1 = helpers['if'].call(depth0, (stack1 = (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.contact : stack1) != null ? stack1.url : stack1, {
                        'name': 'if','hash': {},'fn': this.program(8, data),'inverse': this.noop,'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }
                    buffer += '\n  ';
                    stack1 = helpers['if'].call(depth0, (stack1 = (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.contact : stack1) != null ? stack1.email : stack1, {
                        'name': 'if','hash': {},'fn': this.program(10, data),'inverse': this.noop,'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }
                    buffer += '\n  ';
                    stack1 = helpers['if'].call(depth0, (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.license : stack1, {
                        'name': 'if','hash': {},'fn': this.program(12, data),'inverse': this.noop,'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }

                    return buffer + '\n';
                },'2': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 escapeExpression = this.escapeExpression;

            return '  <p>' +
                escapeExpression(lambda((stack1 = depth0 != null ? depth0.externalDocs : depth0) != null ? stack1.description : stack1, depth0)) +
                '</p>\n  <a href="' +
                escapeExpression(lambda((stack1 = depth0 != null ? depth0.externalDocs : depth0) != null ? stack1.url : stack1, depth0)) +
                '" target="_blank">' +
                escapeExpression(lambda((stack1 = depth0 != null ? depth0.externalDocs : depth0) != null ? stack1.url : stack1, depth0)) +
                '</a>\n';
        },'4': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 escapeExpression = this.escapeExpression;

            return '<div class="info_tos"><a href="' +
                escapeExpression(lambda((stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.termsOfServiceUrl : stack1, depth0)) +
                '" data-sw-translate>Terms of service</a></div>';
        },'6': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 escapeExpression = this.escapeExpression;

            return '<div class=\'info_name\' data-sw-translate>Created by ' +
                escapeExpression(lambda((stack1 = (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.contact : stack1) != null ? stack1.name : stack1, depth0)) +
                '</div>';
        },'8': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 escapeExpression = this.escapeExpression;

            return '<div class=\'info_url\' data-sw-translate>See more at <a href="' +
                escapeExpression(lambda((stack1 = (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.contact : stack1) != null ? stack1.url : stack1, depth0)) +
                '">' +
                escapeExpression(lambda((stack1 = (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.contact : stack1) != null ? stack1.url : stack1, depth0)) +
                '</a></div>';
        },'10': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 escapeExpression = this.escapeExpression;

            return '<div class=\'info_email\'><a href="mailto:' +
                escapeExpression(lambda((stack1 = (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.contact : stack1) != null ? stack1.email : stack1, depth0)) +
                '?subject=' +
                escapeExpression(lambda((stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.title : stack1, depth0)) +
                '" data-sw-translate>Contact the developer</a></div>';
        },'12': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 escapeExpression = this.escapeExpression;

            return '<div class=\'info_license\'><a href=\'' +
                escapeExpression(lambda((stack1 = (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.license : stack1) != null ? stack1.url : stack1, depth0)) +
                '\'>' +
                escapeExpression(lambda((stack1 = (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.license : stack1) != null ? stack1.name : stack1, depth0)) +
                '</a></div>';
        },'14': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 escapeExpression = this.escapeExpression;

            return '  , <span style="font-variant: small-caps" data-sw-translate>api version</span>: ' +
                escapeExpression(lambda((stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.version : stack1, depth0)) +
                '\n    ';
        },'16': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '    <span style="float:right"><a href="' +
                escapeExpression((helper = (helper = helpers.validatorUrl || (depth0 != null ? depth0.validatorUrl : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'validatorUrl','hash': {},'data': data
            }) : helper)) +
                '/debug?url=' +
                escapeExpression((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'url','hash': {},'data': data
            }) : helper)) +
                '"><img id="validator" src="' +
                escapeExpression((helper = (helper = helpers.validatorUrl || (depth0 != null ? depth0.validatorUrl : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'validatorUrl','hash': {},'data': data
            }) : helper)) +
                '?url=' +
                escapeExpression((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'url','hash': {},'data': data
            }) : helper)) +
                '"></a>\n    </span>\n';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<div class=\'info\' id=\'api_info\'>\n';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.info : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</div>\n<div class=\'container\' id=\'resources_container\'>\n  <ul id=\'resources\'></ul>\n\n  <div class="footer">\n    <h4 style="color: #999">[ <span style="font-variant: small-caps">base url</span>: ' +
            escapeExpression((helper = (helper = helpers.basePath || (depth0 != null ? depth0.basePath : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'basePath','hash': {},'data': data
            }) : helper)) +
            '\n';
            stack1 = helpers['if'].call(depth0, (stack1 = depth0 != null ? depth0.info : depth0) != null ? stack1.version : stack1, {
                'name': 'if','hash': {},'fn': this.program(14, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += ']\n';
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.validatorUrl : depth0, {
                'name': 'if','hash': {},'fn': this.program(16, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '    </h4>\n    </div>\n</div>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['operation'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    return 'deprecated';
                },'3': function (depth0, helpers, partials, data) {
            return '            <h4>Warning: Deprecated</h4>\n';
        },'5': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 buffer = '        <h4>Implementation Notes</h4>\n        <div class="markdown">';

            stack1 = (helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'description','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</div>\n';
        },'7': function (depth0, helpers, partials, data) {
            return '        <div class="auth">\n        <span class="api-ic ic-error">';
        },'9': function (depth0, helpers, partials, data) {
            var stack1, buffer = '          <div class="api_information_panel">\n';

            stack1 = helpers.each.call(depth0, depth0, {
                'name': 'each','hash': {},'fn': this.program(10, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '          </div>\n';
        },'10': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 escapeExpression = this.escapeExpression,
 buffer = '            <div title=\'';

            stack1 = lambda(depth0 != null ? depth0.description : depth0, depth0);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '\'>' +
                escapeExpression(lambda(depth0 != null ? depth0.scope : depth0, depth0)) +
                '</div>\n';
        },'12': function (depth0, helpers, partials, data) {
            return '</span></div>';
        },'14': function (depth0, helpers, partials, data) {
            return '        <div class=\'access\'>\n          <span class="api-ic ic-off" title="click to authenticate"></span>\n        </div>\n';
        },'16': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '          <h4><span data-sw-translate>Response Class</span> (<span data-sw-translate>Status</span> ' +
                escapeExpression((helper = (helper = helpers.successCode || (depth0 != null ? depth0.successCode : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'successCode','hash': {},'data': data
            }) : helper)) +
                ')</h4>\n          <p><span class="model-signature" /></p>\n          <br/>\n          <div class="response-content-type" />\n';
        },'18': function (depth0, helpers, partials, data) {
            return '          <h4 data-sw-translate>Parameters</h4>\n          <table class=\'fullwidth\'>\n          <thead>\n            <tr>\n            <th style="width: 100px; max-width: 100px" data-sw-translate>Parameter</th>\n            <th style="width: 310px; max-width: 310px" data-sw-translate>Value</th>\n            <th style="width: 200px; max-width: 200px" data-sw-translate>Description</th>\n            <th style="width: 100px; max-width: 100px" data-sw-translate>Parameter Type</th>\n            <th style="width: 220px; max-width: 230px" data-sw-translate>Data Type</th>\n            </tr>\n          </thead>\n          <tbody class="operation-params">\n\n          </tbody>\n          </table>\n';
        },'20': function (depth0, helpers, partials, data) {
            return '          <div style=\'margin:0;padding:0;display:inline\'></div>\n          <h4 data-sw-translate>Response Messages</h4>\n          <table class=\'fullwidth\'>\n            <thead>\n            <tr>\n              <th data-sw-translate>HTTP Status Code</th>\n              <th data-sw-translate>Reason</th>\n              <th data-sw-translate>Response Model</th>\n              <th data-sw-translate>Headers</th>\n            </tr>\n            </thead>\n            <tbody class="operation-status">\n\n            </tbody>\n          </table>\n';
        },'22': function (depth0, helpers, partials, data) {
            return '';
        },'24': function (depth0, helpers, partials, data) {
            return '          <div class=\'sandbox_header\'>\n            <input class=\'submit\' type=\'button\' value=\'Try it out!\' data-sw-translate/>\n            <a href=\'#\' class=\'response_hider\' style=\'display:none\' data-sw-translate>Hide Response</a>\n            <span class=\'response_throbber\' style=\'display:none\'></span>\n          </div>\n';
        },'26': function (depth0, helpers, partials, data) {
            return '          <h4 data-sw-translate>Request Headers</h4>\n          <div class=\'block request_headers\'></div>\n';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, options, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 blockHelperMissing = helpers.blockHelperMissing,
 buffer = '\n  <ul class=\'operations\' >\n    <li class=\'' +
                escapeExpression((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'method','hash': {},'data': data
            }) : helper)) +
                ' operation\' id=\'' +
                escapeExpression((helper = (helper = helpers.parentId || (depth0 != null ? depth0.parentId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'parentId','hash': {},'data': data
            }) : helper)) +
                '_' +
                escapeExpression((helper = (helper = helpers.nickname || (depth0 != null ? depth0.nickname : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'nickname','hash': {},'data': data
            }) : helper)) +
                '\'>\n      <div class=\'heading\'>\n        <h3>\n          <span class=\'http_method\'>\n          <a href=\'#!/' +
                escapeExpression((helper = (helper = helpers.encodedParentId || (depth0 != null ? depth0.encodedParentId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'encodedParentId','hash': {},'data': data
            }) : helper)) +
                '/' +
                escapeExpression((helper = (helper = helpers.nickname || (depth0 != null ? depth0.nickname : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'nickname','hash': {},'data': data
            }) : helper)) +
                '\' class="toggleOperation">' +
                escapeExpression((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'method','hash': {},'data': data
            }) : helper)) +
                '</a>\n          </span>\n          <span class=\'path\'>\n          <a href=\'#!/' +
                escapeExpression((helper = (helper = helpers.encodedParentId || (depth0 != null ? depth0.encodedParentId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'encodedParentId','hash': {},'data': data
            }) : helper)) +
                '/' +
                escapeExpression((helper = (helper = helpers.nickname || (depth0 != null ? depth0.nickname : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'nickname','hash': {},'data': data
            }) : helper)) +
                '\' class="toggleOperation ';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.deprecated : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '">' +
            escapeExpression((helper = (helper = helpers.path || (depth0 != null ? depth0.path : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'path','hash': {},'data': data
            }) : helper)) +
            '</a>\n          </span>\n        </h3>\n        <ul class=\'options\'>\n          <li>\n          <a href=\'#!/' +
            escapeExpression((helper = (helper = helpers.encodedParentId || (depth0 != null ? depth0.encodedParentId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'encodedParentId','hash': {},'data': data
            }) : helper)) +
            '/' +
            escapeExpression((helper = (helper = helpers.nickname || (depth0 != null ? depth0.nickname : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'nickname','hash': {},'data': data
            }) : helper)) +
            '\' class="toggleOperation">';
            stack1 = (helper = (helper = helpers.summary || (depth0 != null ? depth0.summary : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'summary','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</a>\n          </li>\n        </ul>\n      </div>\n      <div class=\'content\' id=\'' +
            escapeExpression((helper = (helper = helpers.parentId || (depth0 != null ? depth0.parentId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'parentId','hash': {},'data': data
            }) : helper)) +
            '_' +
            escapeExpression((helper = (helper = helpers.nickname || (depth0 != null ? depth0.nickname : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'nickname','hash': {},'data': data
            }) : helper)) +
            '_content\' style=\'display:none\'>\n';
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.deprecated : depth0, {
                'name': 'if','hash': {},'fn': this.program(3, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.description : depth0, {
                'name': 'if','hash': {},'fn': this.program(5, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            stack1 = (helper = (helper = helpers.oauth || (depth0 != null ? depth0.oauth : depth0)) != null ? helper : helperMissing,options = {
                'name': 'oauth','hash': {},'fn': this.program(7, data),'inverse': this.noop,'data': data
            },typeof helper === functionType ? helper.call(depth0, options) : helper);

            if (!helpers.oauth) {
                stack1 = blockHelperMissing.call(depth0, stack1, options);
            }

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '\n';
            stack1 = helpers.each.call(depth0, depth0 != null ? depth0.oauth : depth0, {
                'name': 'each','hash': {},'fn': this.program(9, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '        ';
            stack1 = (helper = (helper = helpers.oauth || (depth0 != null ? depth0.oauth : depth0)) != null ? helper : helperMissing,options = {
                'name': 'oauth','hash': {},'fn': this.program(12, data),'inverse': this.noop,'data': data
            },typeof helper === functionType ? helper.call(depth0, options) : helper);

            if (!helpers.oauth) {
                stack1 = blockHelperMissing.call(depth0, stack1, options);
            }

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '\n';
            stack1 = (helper = (helper = helpers.oauth || (depth0 != null ? depth0.oauth : depth0)) != null ? helper : helperMissing,options = {
                'name': 'oauth','hash': {},'fn': this.program(14, data),'inverse': this.noop,'data': data
            },typeof helper === functionType ? helper.call(depth0, options) : helper);

            if (!helpers.oauth) {
                stack1 = blockHelperMissing.call(depth0, stack1, options);
            }

            if (stack1 != null) {
                buffer += stack1;
            }
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.type : depth0, {
                'name': 'if','hash': {},'fn': this.program(16, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '        <form accept-charset=\'UTF-8\' class=\'sandbox\'>\n          <div style=\'margin:0;padding:0;display:inline\'></div>\n';
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.parameters : depth0, {
                'name': 'if','hash': {},'fn': this.program(18, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.responseMessages : depth0, {
                'name': 'if','hash': {},'fn': this.program(20, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isReadOnly : depth0, {
                'name': 'if','hash': {},'fn': this.program(22, data),'inverse': this.program(24, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '        </form>\n        <div class=\'response\' style=\'display:none\'>\n          <h4>Curl</h4>\n          <div class=\'block curl\'></div>\n          <h4 data-sw-translate>Request URL</h4>\n          <div class=\'block request_url\'></div>\n';
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.showRequestHeaders : depth0, {
                'name': 'if','hash': {},'fn': this.program(26, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '          <h4 data-sw-translate>Response Body</h4>\n          <div class=\'block response_body\'></div>\n          <h4 data-sw-translate>Response Code</h4>\n          <div class=\'block response_code\'></div>\n          <h4 data-sw-translate>Response Headers</h4>\n          <div class=\'block response_headers\'></div>\n        </div>\n      </div>\n    </li>\n  </ul>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['param_list'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    return ' required';
                },'3': function (depth0, helpers, partials, data) {
            return ' multiple="multiple"';
        },'5': function (depth0, helpers, partials, data) {
            return ' required ';
        },'7': function (depth0, helpers, partials, data) {
            var stack1, buffer = '      <option ';

            stack1 = helpers.unless.call(depth0, depth0 != null ? depth0.hasDefault : depth0, {
                'name': 'unless','hash': {},'fn': this.program(8, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + ' value=\'\'></option>\n';
        },'8': function (depth0, helpers, partials, data) {
            return '  selected="\" ';
        },'10': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '\n      <option ';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isDefault : depth0, {
                'name': 'if','hash': {},'fn': this.program(11, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '  value=\'' +
            escapeExpression((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'value','hash': {},'data': data
            }) : helper)) +
            '\'> ' +
            escapeExpression((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'value','hash': {},'data': data
            }) : helper)) +
            ' ';
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isDefault : depth0, {
                'name': 'if','hash': {},'fn': this.program(13, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + ' </option>\n\n';
        },'11': function (depth0, helpers, partials, data) {
            return ' selected="\"  ';
        },'13': function (depth0, helpers, partials, data) {
            return ' (default) ';
        },'15': function (depth0, helpers, partials, data) {
            return '<strong>';
        },'17': function (depth0, helpers, partials, data) {
            return '</strong>';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<td class=\'code';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.required : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '\'><label for=\'' +
            escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
            '\'>' +
            escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
            '</label></td>\n<td>\n  <select ';
            stack1 = (helpers.isArray || depth0 && depth0.isArray || helperMissing).call(depth0, depth0, {
                'name': 'isArray','hash': {},'fn': this.program(3, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += ' class="parameter ';
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.required : depth0, {
                'name': 'if','hash': {},'fn': this.program(5, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '" name="' +
            escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
            '" id="' +
            escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
            '">\n\n';
            stack1 = helpers.unless.call(depth0, depth0 != null ? depth0.required : depth0, {
                'name': 'unless','hash': {},'fn': this.program(7, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '\n';
            stack1 = helpers.each.call(depth0, (stack1 = depth0 != null ? depth0.allowableValues : depth0) != null ? stack1.descriptiveValues : stack1, {
                'name': 'each','hash': {},'fn': this.program(10, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '\n  </select>\n</td>\n<td class="markdown">';
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.required : depth0, {
                'name': 'if','hash': {},'fn': this.program(15, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            stack1 = (helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'description','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.required : depth0, {
                'name': 'if','hash': {},'fn': this.program(17, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</td>\n<td>';
            stack1 = (helper = (helper = helpers.paramType || (depth0 != null ? depth0.paramType : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'paramType','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</td>\n<td><span class="model-signature"></span></td>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['param_readonly_required'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    var helper, functionType = 'function',
         helperMissing = helpers.helperMissing,
         escapeExpression = this.escapeExpression;

                    return '        <textarea class=\'body-textarea\' readonly=\'readonly\' placeholder=\'(required)\' name=\'' +
                        escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                        'name': 'name','hash': {},'data': data
                    }) : helper)) +
                        '\' id=\'' +
                        escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                        'name': 'valueId','hash': {},'data': data
                    }) : helper)) +
                        '\'>' +
                        escapeExpression((helper = (helper = helpers['default'] || (depth0 != null ? depth0['default'] : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                        'name': 'default','hash': {},'data': data
                    }) : helper)) +
                        '</textarea>\n';
                },'3': function (depth0, helpers, partials, data) {
            var stack1, buffer = '';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0['default'] : depth0, {
                'name': 'if','hash': {},'fn': this.program(4, data),'inverse': this.program(6, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer;
        },'4': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '            ' +
                escapeExpression((helper = (helper = helpers['default'] || (depth0 != null ? depth0['default'] : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'default','hash': {},'data': data
            }) : helper)) +
                '\n';
        },'6': function (depth0, helpers, partials, data) {
            return '            (empty)\n';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<td class=\'code required\'><label for=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'>' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '</label></td>\n<td>\n';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isBody : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.program(3, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</td>\n<td class="markdown">';
            stack1 = (helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'description','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</td>\n<td>';
            stack1 = (helper = (helper = helpers.paramType || (depth0 != null ? depth0.paramType : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'paramType','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</td>\n<td><span class="model-signature"></span></td>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['param_readonly'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    var helper, functionType = 'function',
         helperMissing = helpers.helperMissing,
         escapeExpression = this.escapeExpression;

                    return '        <textarea class=\'body-textarea\' readonly=\'readonly\' name=\'' +
                        escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                        'name': 'name','hash': {},'data': data
                    }) : helper)) +
                        '\' id=\'' +
                        escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                        'name': 'valueId','hash': {},'data': data
                    }) : helper)) +
                        '\'>' +
                        escapeExpression((helper = (helper = helpers['default'] || (depth0 != null ? depth0['default'] : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                        'name': 'default','hash': {},'data': data
                    }) : helper)) +
                        '</textarea>\n';
                },'3': function (depth0, helpers, partials, data) {
            var stack1, buffer = '';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0['default'] : depth0, {
                'name': 'if','hash': {},'fn': this.program(4, data),'inverse': this.program(6, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer;
        },'4': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '            ' +
                escapeExpression((helper = (helper = helpers['default'] || (depth0 != null ? depth0['default'] : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'default','hash': {},'data': data
            }) : helper)) +
                '\n';
        },'6': function (depth0, helpers, partials, data) {
            return '            (empty)\n';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<td class=\'code\'><label for=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'>' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '</label></td>\n<td>\n';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isBody : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.program(3, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</td>\n<td class="markdown">';
            stack1 = (helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'description','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</td>\n<td>';
            stack1 = (helper = (helper = helpers.paramType || (depth0 != null ? depth0.paramType : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'paramType','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</td>\n<td><span class="model-signature"></span></td>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['param_required'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    var stack1, buffer = '';

                    stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isFile : depth0, {
                        'name': 'if','hash': {},'fn': this.program(2, data),'inverse': this.program(4, data),'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }

                    return buffer;
                },'2': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '			<input type="file" name=\'' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '\' id=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'/>\n';
        },'4': function (depth0, helpers, partials, data) {
            var stack1, buffer = '';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0['default'] : depth0, {
                'name': 'if','hash': {},'fn': this.program(5, data),'inverse': this.program(7, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer;
        },'5': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '				<textarea class=\'body-textarea required\' placeholder=\'(required)\' name=\'' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '\' id="' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '">' +
                escapeExpression((helper = (helper = helpers['default'] || (depth0 != null ? depth0['default'] : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'default','hash': {},'data': data
            }) : helper)) +
                '</textarea>\n        <br />\n        <div class="parameter-content-type" />\n';
        },'7': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '				<textarea class=\'body-textarea required\' placeholder=\'(required)\' name=\'' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '\' id=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'></textarea>\n				<br />\n				<div class="parameter-content-type" />\n';
        },'9': function (depth0, helpers, partials, data) {
            var stack1, buffer = '';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isFile : depth0, {
                'name': 'if','hash': {},'fn': this.program(10, data),'inverse': this.program(12, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer;
        },'10': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '			<input class=\'parameter\' class=\'required\' type=\'file\' name=\'' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '\' id=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'/>\n';
        },'12': function (depth0, helpers, partials, data) {
            var stack1, helperMissing = helpers.helperMissing,
 buffer = '';

            stack1 = (helpers.renderTextParam || depth0 && depth0.renderTextParam || helperMissing).call(depth0, depth0, {
                'name': 'renderTextParam','hash': {},'fn': this.program(13, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer;
        },'13': function (depth0, helpers, partials, data) {
            return '';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<td class=\'code required\'><label for=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'>' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '</label></td>\n<td>\n';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isBody : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.program(9, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</td>\n<td>\n	<strong><span class="markdown">';
            stack1 = (helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'description','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</span></strong>\n</td>\n<td>';
            stack1 = (helper = (helper = helpers.paramType || (depth0 != null ? depth0.paramType : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'paramType','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</td>\n<td><span class="model-signature"></span></td>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['param'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    var stack1, buffer = '';

                    stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isFile : depth0, {
                        'name': 'if','hash': {},'fn': this.program(2, data),'inverse': this.program(4, data),'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }

                    return buffer;
                },'2': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '			<input type="file" name=\'' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '\' id=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'/>\n			<div class="parameter-content-type" />\n';
        },'4': function (depth0, helpers, partials, data) {
            var stack1, buffer = '';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0['default'] : depth0, {
                'name': 'if','hash': {},'fn': this.program(5, data),'inverse': this.program(7, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer;
        },'5': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '				<textarea class=\'body-textarea\' name=\'' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '\' id=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'>' +
                escapeExpression((helper = (helper = helpers['default'] || (depth0 != null ? depth0['default'] : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'default','hash': {},'data': data
            }) : helper)) +
                '</textarea>\n        <br />\n        <div class="parameter-content-type" />\n';
        },'7': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '				<textarea class=\'body-textarea\' name=\'' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '\' id=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'></textarea>\n				<br />\n				<div class="parameter-content-type" />\n';
        },'9': function (depth0, helpers, partials, data) {
            var stack1, buffer = '';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isFile : depth0, {
                'name': 'if','hash': {},'fn': this.program(2, data),'inverse': this.program(10, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer;
        },'10': function (depth0, helpers, partials, data) {
            var stack1, helperMissing = helpers.helperMissing,
 buffer = '';

            stack1 = (helpers.renderTextParam || depth0 && depth0.renderTextParam || helperMissing).call(depth0, depth0, {
                'name': 'renderTextParam','hash': {},'fn': this.program(11, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer;
        },'11': function (depth0, helpers, partials, data) {
            return '';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<td class=\'code\'><label for=\'' +
                escapeExpression((helper = (helper = helpers.valueId || (depth0 != null ? depth0.valueId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'valueId','hash': {},'data': data
            }) : helper)) +
                '\'>' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '</label></td>\n<td>\n\n';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.isBody : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.program(9, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '\n</td>\n<td class="markdown">';
            stack1 = (helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'description','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</td>\n<td>';
            stack1 = (helper = (helper = helpers.paramType || (depth0 != null ? depth0.paramType : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'paramType','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</td>\n<td>\n	<span class="model-signature"></span>\n</td>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['parameter_content_type'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    var stack1, buffer = '';

                    stack1 = helpers.each.call(depth0, depth0 != null ? depth0.consumes : depth0, {
                        'name': 'each','hash': {},'fn': this.program(2, data),'inverse': this.noop,'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }

                    return buffer;
                },'2': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 buffer = '  <option value="';

            stack1 = lambda(depth0, depth0);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '">';
            stack1 = lambda(depth0, depth0);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</option>\n';
        },'4': function (depth0, helpers, partials, data) {
            return '  <option value="application/json">application/json</option>\n';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<label for="' +
                escapeExpression((helper = (helper = helpers.parameterContentTypeId || (depth0 != null ? depth0.parameterContentTypeId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'parameterContentTypeId','hash': {},'data': data
            }) : helper)) +
                '">Parameter content type:</label>\n<select name="parameterContentType" id="' +
                escapeExpression((helper = (helper = helpers.parameterContentTypeId || (depth0 != null ? depth0.parameterContentTypeId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'parameterContentTypeId','hash': {},'data': data
            }) : helper)) +
                '">\n';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.consumes : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.program(4, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</select>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['resource'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    return ' : ';
                },'3': function (depth0, helpers, partials, data) {
            var helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression;

            return '    <li>\n      <a href=\'' +
                escapeExpression((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'url','hash': {},'data': data
            }) : helper)) +
                '\' data-sw-translate>Raw</a>\n    </li>\n';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, options, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 blockHelperMissing = helpers.blockHelperMissing,
 buffer = '<div class=\'heading\'>\n  <h2>\n    <a href=\'#!/' +
                escapeExpression((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'id','hash': {},'data': data
            }) : helper)) +
                '\' class="toggleEndpointList" data-id="' +
                escapeExpression((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'id','hash': {},'data': data
            }) : helper)) +
                '">' +
                escapeExpression((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'name','hash': {},'data': data
            }) : helper)) +
                '</a> ';

            stack1 = (helper = (helper = helpers.summary || (depth0 != null ? depth0.summary : depth0)) != null ? helper : helperMissing,options = {
                'name': 'summary','hash': {},'fn': this.program(1, data),'inverse': this.noop,'data': data
            },typeof helper === functionType ? helper.call(depth0, options) : helper);

            if (!helpers.summary) {
                stack1 = blockHelperMissing.call(depth0, stack1, options);
            }

            if (stack1 != null) {
                buffer += stack1;
            }
            stack1 = (helper = (helper = helpers.summary || (depth0 != null ? depth0.summary : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'summary','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '\n  </h2>\n  <ul class=\'options\'>\n    <li>\n      <a href=\'#!/' +
            escapeExpression((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'id','hash': {},'data': data
            }) : helper)) +
            '\' id=\'endpointListTogger_' +
            escapeExpression((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'id','hash': {},'data': data
            }) : helper)) +
            '\' class="toggleEndpointList" data-id="' +
            escapeExpression((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'id','hash': {},'data': data
            }) : helper)) +
            '" data-sw-translate>Show/Hide</a>\n    </li>\n    <li>\n      <a href=\'#\' class="collapseResource" data-id="' +
            escapeExpression((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'id','hash': {},'data': data
            }) : helper)) +
            '" data-sw-translate>\n        List Operations\n      </a>\n    </li>\n    <li>\n      <a href=\'#\' class="expandResource" data-id="' +
            escapeExpression((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'id','hash': {},'data': data
            }) : helper)) +
            '" data-sw-translate>\n        Expand Operations\n      </a>\n    </li>\n';
            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.url : depth0, {
                'name': 'if','hash': {},'fn': this.program(3, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '  </ul>\n</div>\n<ul class=\'endpoints\' id=\'' +
                escapeExpression((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'id','hash': {},'data': data
            }) : helper)) +
                '_endpoint_list\' style=\'display:none\'>\n\n</ul>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['response_content_type'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    var stack1, buffer = '';

                    stack1 = helpers.each.call(depth0, depth0 != null ? depth0.produces : depth0, {
                        'name': 'each','hash': {},'fn': this.program(2, data),'inverse': this.noop,'data': data
                    });

                    if (stack1 != null) {
                        buffer += stack1;
                    }

                    return buffer;
                },'2': function (depth0, helpers, partials, data) {
            var stack1, lambda = this.lambda,
 buffer = '  <option value="';

            stack1 = lambda(depth0, depth0);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '">';
            stack1 = lambda(depth0, depth0);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</option>\n';
        },'4': function (depth0, helpers, partials, data) {
            return '  <option value="application/json">application/json</option>\n';
        },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<label data-sw-translate for="' +
                escapeExpression((helper = (helper = helpers.responseContentTypeId || (depth0 != null ? depth0.responseContentTypeId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'responseContentTypeId','hash': {},'data': data
            }) : helper)) +
                '">Response Content Type</label>\n<select name="responseContentType" id="' +
                escapeExpression((helper = (helper = helpers.responseContentTypeId || (depth0 != null ? depth0.responseContentTypeId : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'responseContentTypeId','hash': {},'data': data
            }) : helper)) +
                '">\n';

            stack1 = helpers['if'].call(depth0, depth0 != null ? depth0.produces : depth0, {
                'name': 'if','hash': {},'fn': this.program(1, data),'inverse': this.program(4, data),'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '</select>\n';
        },'useData': true
    });
    this['Handlebars']['templates']['signature'] = Handlebars.template({
        'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<div>\n<ul class="signature-nav">\n  <li><a class="description-link" href="#" data-sw-translate>Model</a></li>\n  <li><a class="snippet-link" href="#" data-sw-translate>Model Schema</a></li>\n</ul>\n<div>\n\n<div class="signature-container">\n  <div class="description">\n    ';

            stack1 = (helper = (helper = helpers.signature || (depth0 != null ? depth0.signature : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'signature','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '\n  </div>\n\n  <div class="snippet">\n    <pre><code>' +
                escapeExpression((helper = (helper = helpers.sampleJSON || (depth0 != null ? depth0.sampleJSON : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'sampleJSON','hash': {},'data': data
            }) : helper)) +
                '</code></pre>\n    <small class="notice"></small>\n  </div>\n</div>\n\n';
        },'useData': true
    });
    this['Handlebars']['templates']['status_code'] = Handlebars.template({
        '1': function (depth0, helpers, partials, data) {
                    var lambda = this.lambda,
         escapeExpression = this.escapeExpression;

                    return '      <tr>\n        <td>' +
                        escapeExpression(lambda(data && data.key, depth0)) +
                        '</td>\n        <td>' +
                        escapeExpression(lambda(depth0 != null ? depth0.description : depth0, depth0)) +
                        '</td>\n        <td>' +
                        escapeExpression(lambda(depth0 != null ? depth0.type : depth0, depth0)) +
                        '</td>\n      </tr>\n';
                },'compiler': [6,'>= 2.0.0-beta.1'],'main': function (depth0, helpers, partials, data) {
            var stack1, helper, functionType = 'function',
 helperMissing = helpers.helperMissing,
 escapeExpression = this.escapeExpression,
 buffer = '<td width=\'15%\' class=\'code\'>' +
                escapeExpression((helper = (helper = helpers.code || (depth0 != null ? depth0.code : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'code','hash': {},'data': data
            }) : helper)) +
                '</td>\n<td class="markdown">';

            stack1 = (helper = (helper = helpers.message || (depth0 != null ? depth0.message : depth0)) != null ? helper : helperMissing,typeof helper === functionType ? helper.call(depth0, {
                'name': 'message','hash': {},'data': data
            }) : helper);

            if (stack1 != null) {
                buffer += stack1;
            }
            buffer += '</td>\n<td width=\'50%\'><span class="model-signature" /></td>\n<td class="headers">\n  <table>\n    <tbody>\n';
            stack1 = helpers.each.call(depth0, depth0 != null ? depth0.headers : depth0, {
                'name': 'each','hash': {},'fn': this.program(1, data),'inverse': this.noop,'data': data
            });

            if (stack1 != null) {
                buffer += stack1;
            }

            return buffer + '    </tbody>\n  </table>\n</td>';
        },'useData': true
    });

    /**
     * swagger-client - swagger-client is a javascript client for use with swaggering APIs.
     * @version v2.1.2
     * @link http://swagger.io
     * @license Apache-2.0
     */
    (function (f) {
        if (typeof exports === 'object' && typeof module !== 'undefined') {
            module.exports = f();
        } else if (typeof define === 'function' && define.amd) {
            define([], f);
        } else {
            var g;

            if (typeof window !== 'undefined') {
                g = window;
            } else if (typeof global !== 'undefined') {
                g = global;
            } else if (typeof self !== 'undefined') {
                g = self;
            } else {
                g = this;
            }g.SwaggerClient = f();
        }
    })(function () {
        var define,module,exports;

        return (function e(t, n, r) {
            function s(o, u) {
                if (!n[o]) {
                    if (!t[o]) {
                        var a = typeof require == 'function' && require;

                        if (!u && a)return a(o, !0);

                        if (i)return i(o, !0); var f = new Error('Cannot find module \'' + o + '\'');

                        throw f.code = 'MODULE_NOT_FOUND',f;
                    }var l = n[o] = {
                        exports: {}
                    };

                    t[o][0].call(l.exports, function (e) {
                    var n = t[o][1][e];

                    return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
                }

                return n[o].exports;
            }var i = typeof require == 'function' && require;

            for (var o = 0; o < r.length; o++)s(r[o]);

            return s;
        })({
            1: [function (require, module, exports) {
                            'use strict';

                            var auth = require('./lib/auth');
                            var helpers = require('./lib/helpers');
                            var SwaggerClient = require('./lib/client');
                            var deprecationWrapper = function (url, options) {
                                helpers.log('This is deprecated, use "new SwaggerClient" instead.');

                                return new SwaggerClient(url, options);
                            };

                            /* Here for IE8 Support */
                            if (!Array.prototype.indexOf) {
                                Array.prototype.indexOf = function (obj, start) {
                                    for (var i = start || 0, j = this.length; i < j; i++) {
                                        if (this[i] === obj) {
                                            return i;
                                        }
                                    }

                                    return -1;
                                };
                            }

                            /* Here for IE8 Support */
                            if (!String.prototype.trim) {
                                String.prototype.trim = function () {
                                    return this.replace(/^\s+|\s+$/g, '');
                                };
                            }

                            /* Here for node 10.x support */
                            if (!String.prototype.endsWith) {
                                String.prototype.endsWith = function (suffix) {
                                    return this.indexOf(suffix, this.length - suffix.length) !== -1;
                                };
                            }

                            module.exports = SwaggerClient;

                            SwaggerClient.ApiKeyAuthorization = auth.ApiKeyAuthorization;
                            SwaggerClient.PasswordAuthorization = auth.PasswordAuthorization;
                            SwaggerClient.CookieAuthorization = auth.CookieAuthorization;
                            SwaggerClient.SwaggerApi = deprecationWrapper;
                            SwaggerClient.SwaggerClient = deprecationWrapper;
                            SwaggerClient.SchemaMarkup = require('./lib/schema-markup');

                        },{
                './lib/auth': 2,'./lib/client': 3,'./lib/helpers': 4,'./lib/schema-markup': 7
            }],2: [function (require, module, exports) {
                'use strict';

                var helpers = require('./helpers');
                var btoa = require('btoa'); // jshint ignore:line
                var CookieJar = require('cookiejar');
                var _ = {
                    each: require('lodash-compat/collection/each'),
                    includes: require('lodash-compat/collection/includes'),
                    isObject: require('lodash-compat/lang/isObject'),
                    isArray: require('lodash-compat/lang/isArray')
                };

                /**
                 * SwaggerAuthorizations applys the correct authorization to an operation being executed
                 */
                var SwaggerAuthorizations = module.exports.SwaggerAuthorizations = function (authz) {
                    this.authz = authz || {};
                };

                /**
                 * Add auths to the hash
                 * Will overwrite any existing
                 *
                 */
                SwaggerAuthorizations.prototype.add = function (name, auth) {
                    if (_.isObject(name)) {
                        for (var key in name) {
                            this.authz[key] = name[key];
                        }
                    } else if (typeof name === 'string') {
                        this.authz[name] = auth;
                    }

                    return auth;
                };

                SwaggerAuthorizations.prototype.remove = function (name) {
                    return delete this.authz[name];
                };

                SwaggerAuthorizations.prototype.apply = function (obj, securities) {
                    var status = true;
                    var applyAll = !securities;
                    var flattenedSecurities = [];

                    // Securities could be [ {} ]
                    _.each(securities, function (obj, key) {

                        // Make sure we account for securities being [ str ]
                        if (typeof key === 'string') {
                            flattenedSecurities.push(key);
                        }

                        // Flatten keys in to our array
                        _.each(obj, function (val, key) {
                            flattenedSecurities.push(key);
                        });
                    });

                    _.each(this.authz, function (auth, authName) {
                        if (applyAll || _.includes(flattenedSecurities, authName)) {
                            var newStatus = auth.apply(obj);

                            status = status && !!newStatus; // logical ORs regarding status
                        }
                    });

                    return status;
                };

                /**
                 * ApiKeyAuthorization allows a query param or header to be injected
                 */
                var ApiKeyAuthorization = module.exports.ApiKeyAuthorization = function (name, value, type) {
                    this.name = name;
                    this.value = value;
                    this.type = type;
                };

                ApiKeyAuthorization.prototype.apply = function (obj) {
                    if (this.type === 'query') {
                        if (obj.url.indexOf('?') > 0) {
                            obj.url = obj.url + '&' + this.name + '=' + this.value;
                        } else {
                            obj.url = obj.url + '?' + this.name + '=' + this.value;
                        }

                        return true;
                    } else if (this.type === 'header') {
                        if (typeof obj.headers[this.name] === 'undefined') {
                            obj.headers[this.name] = this.value;
                        }

                        return true;
                    }
                };

                var CookieAuthorization = module.exports.CookieAuthorization = function (cookie) {
                    this.cookie = cookie;
                };

                CookieAuthorization.prototype.apply = function (obj) {
                    obj.cookieJar = obj.cookieJar || new CookieJar();
                    obj.cookieJar.setCookie(this.cookie);

                    return true;
                };

                /**
                 * Password Authorization is a basic auth implementation
                 */
                var PasswordAuthorization = module.exports.PasswordAuthorization = function (username, password) {
                    if (arguments.length === 3) {
                        helpers.log('PasswordAuthorization: the \'name\' argument has been removed, pass only username and password');
                        username = arguments[1];
                        password = arguments[2];
                    }
                    this.username = username;
                    this.password = password;
                };

                PasswordAuthorization.prototype.apply = function (obj) {
                    if (typeof obj.headers.Authorization === 'undefined') {
                        obj.headers.Authorization = 'Basic ' + btoa(this.username + ':' + this.password);
                    }

                    return true;
                };

            },{
                './helpers': 4,'btoa': 18,'cookiejar': 19,'lodash-compat/collection/each': 55,'lodash-compat/collection/includes': 58,'lodash-compat/lang/isArray': 143,'lodash-compat/lang/isObject': 147
            }],3: [function (require, module, exports) {
                'use strict';

                var _ = {
                    bind: require('lodash-compat/function/bind'),
                    cloneDeep: require('lodash-compat/lang/cloneDeep'),
                    find: require('lodash-compat/collection/find'),
                    forEach: require('lodash-compat/collection/forEach'),
                    indexOf: require('lodash-compat/array/indexOf'),
                    isArray: require('lodash-compat/lang/isArray'),
                    isObject: require('lodash-compat/lang/isObject'),
                    isFunction: require('lodash-compat/lang/isFunction'),
                    isPlainObject: require('lodash-compat/lang/isPlainObject'),
                    isUndefined: require('lodash-compat/lang/isUndefined')
                };
                var auth = require('./auth');
                var helpers = require('./helpers');
                var Model = require('./types/model');
                var Operation = require('./types/operation');
                var OperationGroup = require('./types/operationGroup');
                var Resolver = require('./resolver');
                var SwaggerHttp = require('./http');
                var SwaggerSpecConverter = require('./spec-converter');

                // We have to keep track of the function/property names to avoid collisions for tag names which are used to allow the
                // following usage: 'client.{tagName}'
                var reservedClientTags = [
                    'apis',
                    'authorizationScheme',
                    'authorizations',
                    'basePath',
                    'build',
                    'buildFrom1_1Spec',
                    'buildFrom1_2Spec',
                    'buildFromSpec',
                    'clientAuthorizations',
                    'convertInfo',
                    'debug',
                    'defaultErrorCallback',
                    'defaultSuccessCallback',
                    'fail',
                    'failure',
                    'finish',
                    'help',
                    'idFromOp',
                    'info',
                    'initialize',
                    'isBuilt',
                    'isValid',
                    'modelPropertyMacro',
                    'models',
                    'modelsArray',
                    'options',
                    'parameterMacro',
                    'parseUri',
                    'progress',
                    'resourceCount',
                    'sampleModels',
                    'selfReflect',
                    'setConsolidatedModels',
                    'spec',
                    'supportedSubmitMethods',
                    'swaggerRequestHeaders',
                    'tagFromLabel',
                    'url',
                    'useJQuery'
                ];
                // We have to keep track of the function/property names to avoid collisions for tag names which are used to allow the
                // following usage: 'client.apis.{tagName}'
                var reservedApiTags = [
                    'apis',
                    'asCurl',
                    'description',
                    'externalDocs',
                    'help',
                    'label',
                    'name',
                    'operation',
                    'operations',
                    'operationsArray',
                    'path',
                    'tag'
                ];
                var supportedOperationMethods = ['delete', 'get', 'head', 'options', 'patch', 'post', 'put'];
                var SwaggerClient = module.exports = function (url, options) {
                    this.authorizations = null;
                    this.authorizationScheme = null;
                    this.basePath = null;
                    this.debug = false;
                    this.info = null;
                    this.isBuilt = false;
                    this.isValid = false;
                    this.modelsArray = [];
                    this.resourceCount = 0;
                    this.url = null;
                    this.useJQuery = false;
                    this.swaggerObject = {};

                    this.clientAuthorizations = new auth.SwaggerAuthorizations();

                    if (typeof url !== 'undefined') {
                        return this.initialize(url, options);
                    }

                    return this;

                };

                SwaggerClient.prototype.initialize = function (url, options) {
                    this.models = {};
                    this.sampleModels = {};

                    if (typeof url === 'string') {
                        this.url = url;
                    } else if (_.isObject(url)) {
                        options = url;
                        this.url = options.url;
                    }

                    options = options || {};
                    this.clientAuthorizations.add(options.authorizations);
                    this.swaggerRequestHeaders = options.swaggerRequestHeaders || 'application/json;charset=utf-8,*/*';
                    this.defaultSuccessCallback = options.defaultSuccessCallback || null;
                    this.defaultErrorCallback = options.defaultErrorCallback || null;
                    this.modelPropertyMacro = options.modelPropertyMacro || null;
                    this.parameterMacro = options.modelPropertyMacro || null;

                    if (typeof options.success === 'function') {
                        this.success = options.success;
                    }

                    if (options.useJQuery) {
                        this.useJQuery = options.useJQuery;
                    }

                    this.options = options || {};

                    this.supportedSubmitMethods = options.supportedSubmitMethods || [];
                    this.failure = options.failure || function () {};
                    this.progress = options.progress || function () {};
                    this.spec = _.cloneDeep(options.spec); // Clone so we do not alter the provided document

                    if (typeof options.success === 'function') {
                        this.ready = true;
                        this.build();
                    }
                };

                SwaggerClient.prototype.build = function (mock) {
                    if (this.isBuilt) {
                        return this;
                    }

                    var self = this;

                    this.progress('fetching resource list: ' + this.url);

                    var obj = {
                        useJQuery: this.useJQuery,
                        url: this.url,
                        method: 'get',
                        headers: {
                            accept: this.swaggerRequestHeaders
                        },
                        on: {
                            error: function (response) {
                                if (self.url.substring(0, 4) !== 'http') {
                                    return self.fail('Please specify the protocol for ' + self.url);
                                } else if (response.status === 0) {
                                    return self.fail('Can\'t read from server.  It may not have the appropriate access-control-origin settings.');
                                } else if (response.status === 404) {
                                    return self.fail('Can\'t read swagger JSON from ' + self.url);
                                }

                                return self.fail(response.status + ' : ' + response.statusText + ' ' + self.url);

                            },
                            response: function (resp) {

                                var responseObj = resp.obj;

                                if (!responseObj) {
                                    return self.fail('failed to parse JSON/YAML response');
                                }

                                self.swaggerVersion = responseObj.swaggerVersion;
                                self.swaggerObject = responseObj;

                                if (responseObj.swagger && parseInt(responseObj.swagger) === 2) {
                                    self.swaggerVersion = responseObj.swagger;

                                    new Resolver().resolve(responseObj, self.url, self.buildFromSpec, self);

                                    self.isValid = true;
                                } else {
                                    var converter = new SwaggerSpecConverter();

                                    self.oldSwaggerObject = self.swaggerObject;

                                    converter.setDocumentationLocation(self.url);
                                    converter.convert(responseObj, self.clientAuthorizations, function (spec) {
                                        self.swaggerObject = spec;
                                        new Resolver().resolve(spec, self.url, self.buildFromSpec, self);
                                        self.isValid = true;
                                    });
                                }
                            }
                        }
                    };

                    if (this.spec) {
                        self.swaggerObject = this.spec;
                        setTimeout(function () {
                            new Resolver().resolve(self.spec, self.buildFromSpec, self);
                        }, 10);
                    } else {
                        this.clientAuthorizations.apply(obj);

                        if (mock) {
                            return obj;
                        }

                        new SwaggerHttp().execute(obj, this.options);
                    }

                    return this;
                };

                SwaggerClient.prototype.buildFromSpec = function (response) {
                    if (this.isBuilt) {
                        return this;
                    }

                    this.apis = {};
                    this.apisArray = [];
                    this.basePath = response.basePath || '';
                    this.consumes = response.consumes;
                    this.host = response.host || '';
                    this.info = response.info || {};
                    this.produces = response.produces;
                    this.schemes = response.schemes || [];
                    this.securityDefinitions = response.securityDefinitions;
                    this.title = response.title || '';

                    if (response.externalDocs) {
                        this.externalDocs = response.externalDocs;
                    }

                    // legacy support
                    this.authSchemes = response.securityDefinitions;

                    var definedTags = {};
                    var k;

                    if (Array.isArray(response.tags)) {
                        definedTags = {};

                        for (k = 0; k < response.tags.length; k++) {
                            var t = response.tags[k];

                            definedTags[t.name] = t;
                        }
                    }

                    var location;

                    if (typeof this.url === 'string') {
                        location = this.parseUri(this.url);

                        if (typeof this.schemes === 'undefined' || this.schemes.length === 0) {
                            this.scheme = location.scheme || 'http';
                        } else {
                            this.scheme = this.schemes[0];
                        }

                        if (typeof this.host === 'undefined' || this.host === '') {
                            this.host = location.host;

                            if (location.port) {
                                this.host = this.host + ':' + location.port;
                            }
                        }
                    } else if (typeof this.schemes === 'undefined' || this.schemes.length === 0) {
                        this.scheme = 'http';
                    } else {
                        this.scheme = this.schemes[0];
                    }

                    this.definitions = response.definitions;

                    var key;

                    for (key in this.definitions) {
                        var model = new Model(key, this.definitions[key], this.models, this.modelPropertyMacro);

                        if (model) {
                            this.models[key] = model;
                        }
                    }

                    // get paths, create functions for each operationId
                    var self = this;

                    // Bind help to 'client.apis'
                    self.apis.help = _.bind(self.help, self);

                    _.forEach(response.paths, function (pathObj, path) {
                        // Only process a path if it's an object
                        if (!_.isPlainObject(pathObj)) {
                            return;
                        }

                        _.forEach(supportedOperationMethods, function (method) {
                            var operation = pathObj[method];

                            if (_.isUndefined(operation)) {
                                // Operation does not exist
                                return;
                            } else if (!_.isPlainObject(operation)) {
                                // Operation exists but it is not an Operation Object.  Since this is invalid, log it.
                                helpers.log('The \'' + method + '\' operation for \'' + path + '\' path is not an Operation Object');

                                return;
                            }

                            var tags = operation.tags;

                            if (_.isUndefined(tags) || !_.isArray(tags) || tags.length === 0) {
                                tags = operation.tags = ['default'];
                            }

                            var operationId = self.idFromOp(path, method, operation);
                            var operationObject = new Operation(self,
                                operation.scheme,
                                operationId,
                                method,
                                path,
                                operation,
                                self.definitions,
                                self.models,
                                self.clientAuthorizations);

                            // bind self operation's execute command to the api
                            _.forEach(tags, function (tag) {
                                var clientProperty = _.indexOf(reservedClientTags, tag) > -1 ? '_' + tag : tag;
                                var apiProperty = _.indexOf(reservedApiTags, tag) > -1 ? '_' + tag : tag;
                                var operationGroup = self[clientProperty];

                                if (clientProperty !== tag) {
                                    helpers.log('The \'' + tag + '\' tag conflicts with a SwaggerClient function/property name.  Use \'client.' +
                                    clientProperty + '\' or \'client.apis.' + tag + '\' instead of \'client.' + tag + '\'.');
                                }

                                if (apiProperty !== tag) {
                                    helpers.log('The \'' + tag + '\' tag conflicts with a SwaggerClient operation function/property name.  Use ' +
                                    '\'client.apis.' + apiProperty + '\' instead of \'client.apis.' + tag + '\'.');
                                }

                                if (_.indexOf(reservedApiTags, operationId) > -1) {
                                    helpers.log('The \'' + operationId + '\' operationId conflicts with a SwaggerClient operation ' +
                                    'function/property name.  Use \'client.apis.' + apiProperty + '._' + operationId +
                                    '\' instead of \'client.apis.' + apiProperty + '.' + operationId + '\'.');

                                    operationId = '_' + operationId;
                                    operationObject.nickname = operationId; // So 'client.apis.[tag].operationId.help() works properly
                                }

                                if (_.isUndefined(operationGroup)) {
                                    operationGroup = self[clientProperty] = self.apis[apiProperty] = {};

                                    operationGroup.operations = {};
                                    operationGroup.label = apiProperty;
                                    operationGroup.apis = {};

                                    var tagDef = definedTags[tag];

                                    if (!_.isUndefined(tagDef)) {
                                        operationGroup.description = tagDef.description;
                                        operationGroup.externalDocs = tagDef.externalDocs;
                                    }

                                    self[clientProperty].help = _.bind(self.help, operationGroup);
                                    self.apisArray.push(new OperationGroup(tag, operationGroup.description, operationGroup.externalDocs, operationObject));
                                }

                                // Bind tag help
                                if (!_.isFunction(operationGroup.help)) {
                                    operationGroup.help = _.bind(self.help, operationGroup);
                                }

                                // bind to the apis object
                                self.apis[apiProperty][operationId] = operationGroup[operationId] = _.bind(operationObject.execute,
                                    operationObject);
                                self.apis[apiProperty][operationId].help = operationGroup[operationId].help = _.bind(operationObject.help,
                                    operationObject);
                                self.apis[apiProperty][operationId].asCurl = operationGroup[operationId].asCurl = _.bind(operationObject.asCurl,
                                    operationObject);

                                operationGroup.apis[operationId] = operationGroup.operations[operationId] = operationObject;

                                // legacy UI feature
                                var api = _.find(self.apisArray, function (api) {
                                    return api.tag === tag;
                                });

                                if (api) {
                                    api.operationsArray.push(operationObject);
                                }
                            });
                        });
                    });

                    this.isBuilt = true;

                    if (this.success) {
                        this.isValid = true;
                        this.isBuilt = true;
                        this.success();
                    }

                    return this;
                };

                SwaggerClient.prototype.parseUri = function (uri) {
                    var urlParseRE = /^(((([^:\/#\?]+:)?(?:(\/\/)((?:(([^:@\/#\?]+)(?:\:([^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/;
                    var parts = urlParseRE.exec(uri);

                    return {
                        scheme: parts[4].replace(':', ''),
                        host: parts[11],
                        port: parts[12],
                        path: parts[15]
                    };
                };

                SwaggerClient.prototype.help = function (dontPrint) {
                    var output = '';

                    if (this instanceof SwaggerClient) {
                        _.forEach(this.apis, function (api, name) {
                            if (_.isPlainObject(api)) {
                                output += 'operations for the \'' + name + '\' tag\n';

                                _.forEach(api.operations, function (operation, name) {
                                    output += '  * ' + name + ': ' + operation.summary + '\n';
                                });
                            }
                        });
                    } else if (this instanceof OperationGroup || _.isPlainObject(this)) {
                        output += 'operations for the \'' + this.label + '\' tag\n';

                        _.forEach(this.apis, function (operation, name) {
                            output += '  * ' + name + ': ' + operation.summary + '\n';
                        });
                    }

                    if (dontPrint) {
                        return output;
                    }
                    helpers.log(output);

                    return output;

                };

                SwaggerClient.prototype.tagFromLabel = function (label) {
                    return label;
                };

                SwaggerClient.prototype.idFromOp = function (path, httpMethod, op) {
                    if (!op || !op.operationId) {
                        op = op || {};
                        op.operationId = httpMethod + '_' + path;
                    }
                    var opId = op.operationId.replace(/[\s!@#$%^&*()_+=\[{\]};:<>|.\/?,\\'""-]/g, '_') || path.substring(1) + '_' + httpMethod;

                    opId = opId.replace(/((_){2,})/g, '_');
                    opId = opId.replace(/^(_)*/g, '');
                    opId = opId.replace(/([_])*$/g, '');

                    return opId;
                };

                SwaggerClient.prototype.setHost = function (host) {
                    this.host = host;

                    if (this.apis) {
                        _.forEach(this.apis, function (api) {
                            if (api.operations) {
                                _.forEach(api.operations, function (operation) {
                                    operation.host = host;
                                });
                            }
                        });
                    }
                };

                SwaggerClient.prototype.setBasePath = function (basePath) {
                    this.basePath = basePath;

                    if (this.apis) {
                        _.forEach(this.apis, function (api) {
                            if (api.operations) {
                                _.forEach(api.operations, function (operation) {
                                    operation.basePath = basePath;
                                });
                            }
                        });
                    }
                };

                SwaggerClient.prototype.fail = function (message) {
                    this.failure(message);

                    throw message;
                };
            },{
                './auth': 2,'./helpers': 4,'./http': 5,'./resolver': 6,'./spec-converter': 8,'./types/model': 9,'./types/operation': 10,'./types/operationGroup': 11,'lodash-compat/array/indexOf': 52,'lodash-compat/collection/find': 56,'lodash-compat/collection/forEach': 57,'lodash-compat/function/bind': 61,'lodash-compat/lang/cloneDeep': 141,'lodash-compat/lang/isArray': 143,'lodash-compat/lang/isFunction': 145,'lodash-compat/lang/isObject': 147,'lodash-compat/lang/isPlainObject': 148,'lodash-compat/lang/isUndefined': 151
            }],4: [function (require, module, exports) {
                (function (process) {
                    'use strict';

                    var _ = {
                        isPlainObject: require('lodash-compat/lang/isPlainObject'),
                        indexOf: require('lodash-compat/array/indexOf')
                    };

                    module.exports.__bind = function (fn, me) {
                        return function () {
                            return fn.apply(me, arguments);
                        };
                    };

                    var log = module.exports.log = function () {
                        // Only log if available and we're not testing
                        if (console && process.env.NODE_ENV !== 'test') {
                            console.log(Array.prototype.slice.call(arguments)[0]);
                        }
                    };

                    module.exports.fail = function (message) {
                        log(message);
                    };

                    var optionHtml = module.exports.optionHtml = function (label, value) {
                        return '<tr><td class="optionName">' + label + ':</td><td>' + value + '</td></tr>';
                    };

                    var resolveSchema = module.exports.resolveSchema = function (schema) {
                        if (_.isPlainObject(schema.schema)) {
                            schema = resolveSchema(schema.schema);
                        }

                        return schema;
                    };

                    var simpleRef = module.exports.simpleRef = function (name) {
                        if (typeof name === 'undefined') {
                            return null;
                        }

                        if (name.indexOf('#/definitions/') === 0) {
                            return name.substring('#/definitions/'.length);
                        }

                        return name;

                    };

                }).call(this, require('_process'));
                //# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9oZWxwZXJzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHtcbiAgaXNQbGFpbk9iamVjdDogcmVxdWlyZSgnbG9kYXNoLWNvbXBhdC9sYW5nL2lzUGxhaW5PYmplY3QnKSxcbiAgaW5kZXhPZjogcmVxdWlyZSgnbG9kYXNoLWNvbXBhdC9hcnJheS9pbmRleE9mJylcbn07XG5cbm1vZHVsZS5leHBvcnRzLl9fYmluZCA9IGZ1bmN0aW9uIChmbiwgbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIGxvZyA9IG1vZHVsZS5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICAvLyBPbmx5IGxvZyBpZiBhdmFpbGFibGUgYW5kIHdlJ3JlIG5vdCB0ZXN0aW5nXG4gIGlmIChjb25zb2xlICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcpIHtcbiAgICBjb25zb2xlLmxvZyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpWzBdKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZmFpbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIGxvZyhtZXNzYWdlKTtcbn07XG5cbnZhciBvcHRpb25IdG1sID0gbW9kdWxlLmV4cG9ydHMub3B0aW9uSHRtbCA9IGZ1bmN0aW9uIChsYWJlbCwgdmFsdWUpIHtcbiAgcmV0dXJuICc8dHI+PHRkIGNsYXNzPVwib3B0aW9uTmFtZVwiPicgKyBsYWJlbCArICc6PC90ZD48dGQ+JyArIHZhbHVlICsgJzwvdGQ+PC90cj4nO1xufTtcblxudmFyIHJlc29sdmVTY2hlbWEgPSBtb2R1bGUuZXhwb3J0cy5yZXNvbHZlU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICBpZiAoXy5pc1BsYWluT2JqZWN0KHNjaGVtYS5zY2hlbWEpKSB7XG4gICAgc2NoZW1hID0gcmVzb2x2ZVNjaGVtYShzY2hlbWEuc2NoZW1hKTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuXG52YXIgc2ltcGxlUmVmID0gbW9kdWxlLmV4cG9ydHMuc2ltcGxlUmVmID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG5hbWUuaW5kZXhPZignIy9kZWZpbml0aW9ucy8nKSA9PT0gMCkge1xuICAgIHJldHVybiBuYW1lLnN1YnN0cmluZygnIy9kZWZpbml0aW9ucy8nLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn07XG5cbiJdfQ==
            },{
                '_process': 17,'lodash-compat/array/indexOf': 52,'lodash-compat/lang/isPlainObject': 148
            }],5: [function (require, module, exports) {
                'use strict';

                var helpers = require('./helpers');
                var jQuery = require('jquery');
                var request = require('superagent');
                var jsyaml = require('js-yaml');
                var _ = {
                    isObject: require('lodash-compat/lang/isObject')
                };

                /*
                 * JQueryHttpClient is a light-weight, node or browser HTTP client
                 */
                var JQueryHttpClient = function () {};

                /*
                 * SuperagentHttpClient is a light-weight, node or browser HTTP client
                 */
                var SuperagentHttpClient = function () {};

                /**
                 * SwaggerHttp is a wrapper for executing requests
                 */
                var SwaggerHttp = module.exports = function () {};

                SwaggerHttp.prototype.execute = function (obj, opts) {
                    var client;

                    if (opts && opts.client) {
                        client = opts.client;
                    } else {
                        client = new SuperagentHttpClient(opts);
                    }

                    // legacy support
                    if (obj && obj.useJQuery === true || this.isInternetExplorer()) {
                        client = new JQueryHttpClient(opts);
                    }

                    var success = obj.on.response;

                    var responseInterceptor = function (data) {
                        if (opts && opts.responseInterceptor) {
                            data = opts.responseInterceptor.apply(data);
                        }
                        success(data);
                    };

                    obj.on.response = function (data) {
                        responseInterceptor(data);
                    };

                    if (_.isObject(obj) && _.isObject(obj.body)) {
                        // special processing for file uploads via jquery
                        if (obj.body.type && obj.body.type === 'formData') {
                            obj.contentType = false;
                            obj.processData = false;

                            delete obj.headers['Content-Type'];
                        } else {
                            obj.body = JSON.stringify(obj.body);
                        }
                    }
                    client.execute(obj);
                };

                SwaggerHttp.prototype.isInternetExplorer = function () {
                    var detectedIE = false;

                    if (typeof navigator !== 'undefined' && navigator.userAgent) {
                        var nav = navigator.userAgent.toLowerCase();

                        if (nav.indexOf('msie') !== -1) {
                            var version = parseInt(nav.split('msie')[1]);

                            if (version <= 8) {
                                detectedIE = true;
                            }
                        }
                    }

                    return detectedIE;
                };

                JQueryHttpClient.prototype.execute = function (obj) {
                    var cb = obj.on;
                    var request = obj;

                    obj.type = obj.method;
                    obj.cache = false;
                    delete obj.useJQuery;

                    /*
                     obj.beforeSend = function (xhr) {
                     var key, results;
                     if (obj.headers) {
                     results = [];
                     for (key in obj.headers) {
                     if (key.toLowerCase() === 'content-type') {
                     results.push(obj.contentType = obj.headers[key]);
                     } else if (key.toLowerCase() === 'accept') {
                     results.push(obj.accepts = obj.headers[key]);
                     } else {
                     results.push(xhr.setRequestHeader(key, obj.headers[key]));
                     }
                     }
                     return results;
                     }
                     };*/

                    obj.data = obj.body;

                    delete obj.body;

                    obj.complete = function (response) {
                        var headers = {};
                        var headerArray = response.getAllResponseHeaders().split('\n');

                        for (var i = 0; i < headerArray.length; i++) {
                            var toSplit = headerArray[i].trim();

                            if (toSplit.length === 0) {
                                continue;
                            }

                            var separator = toSplit.indexOf(':');

                            if (separator === -1) {
                                // Name but no value in the header
                                headers[toSplit] = null;

                                continue;
                            }

                            var name = toSplit.substring(0, separator).trim();
                            var value = toSplit.substring(separator + 1).trim();

                            headers[name] = value;
                        }

                        var out = {
                            url: request.url,
                            method: request.method,
                            status: response.status,
                            statusText: response.statusText,
                            data: response.responseText,
                            headers: headers
                        };

                        try {
                            var possibleObj =  response.responseJSON || jsyaml.safeLoad(response.responseText);

                            out.obj = typeof possibleObj === 'string' ? {} : possibleObj;
                        } catch (ex) {
                            // do not set out.obj
                            helpers.log('unable to parse JSON/YAML content');
                        }

                        // I can throw, or parse null?
                        out.obj = out.obj || null;

                        if (response.status >= 200 && response.status < 300) {
                            cb.response(out);
                        } else if (response.status === 0 || response.status >= 400 && response.status < 599) {
                            cb.error(out);
                        } else {
                            return cb.response(out);
                        }
                    };

                    jQuery.support.cors = true;

                    return jQuery.ajax(obj);
                };

                SuperagentHttpClient.prototype.execute = function (obj) {
                    var method = obj.method.toLowerCase();

                    if (method === 'delete') {
                        method = 'del';
                    }
                    var headers = obj.headers || {};
                    var r = request[method](obj.url);
                    var name;

                    for (name in headers) {
                        r.set(name, headers[name]);
                    }

                    if (obj.body) {
                        r.send(obj.body);
                    }

                    if (typeof r.buffer === 'function') {
                        r.buffer(); // force superagent to populate res.text with the raw response data
                    }

                    r.end(function (err, res) {
                        res = res || {
                            status: 0,
                            headers: {
                                error: 'no response from server'
                            }
                        };
                        var response = {
                            url: obj.url,
                            method: obj.method,
                            headers: res.headers
                        };
                        var cb;

                        if (!err && res.error) {
                            err = res.error;
                        }

                        if (err && obj.on && obj.on.error) {
                            response.obj = err;
                            response.status = res ? res.status : 500;
                            response.statusText = res ? res.text : err.message;
                            cb = obj.on.error;
                        } else if (res && obj.on && obj.on.response) {
                            var possibleObj;

                            // Already parsed by by superagent?
                            if (res.body && Object.keys(res.body).length > 0) {
                                possibleObj = res.body;
                            } else {
                                try {
                                    possibleObj = jsyaml.safeLoad(res.text);
                                    // can parse into a string... which we don't need running around in the system
                                    possibleObj = typeof possibleObj === 'string' ? null : possibleObj;
                                } catch (e) {
                                    helpers.log('cannot parse JSON/YAML content');
                                }
                            }

                            // null means we can't parse into object
                            response.obj = possibleObj || null;

                            response.status = res.status;
                            response.statusText = res.text;
                            cb = obj.on.response;
                        }
                        response.data = response.statusText;

                        if (cb) {
                            cb(response);
                        }
                    });
                };

            },{
                './helpers': 4,'jquery': 20,'js-yaml': 21,'lodash-compat/lang/isObject': 147,'superagent': 160
            }],6: [function (require, module, exports) {
                'use strict';

                var SwaggerHttp = require('./http');
                var _ = {
                    isObject: require('lodash-compat/lang/isObject'),
                    isArray: require('lodash-compat/lang/isArray')
                };


                /**
                 * Resolves a spec's remote references
                 */
                var Resolver = module.exports = function () {};

                Resolver.prototype.resolve = function (spec, arg1, arg2, arg3) {
                    var root = arg1,
 callback = arg2,
 scope = arg3,
 location, i;

                    if (typeof arg1 === 'function') {
                        root = null;
                        callback = arg1;
                        scope = arg2;
                    }
                    var _root = root;

                    this.scope = scope || this;
                    this.iteration = this.iteration || 0;

                    var name, path, property, propertyName;
                    var processedCalls = 0,
 resolvedRefs = {},
 unresolvedRefs = {};
                    var resolutionTable = []; // store objects for dereferencing

                    // definitions
                    for (name in spec.definitions) {
                        var definition = spec.definitions[name];

                        for (propertyName in definition.properties) {
                            property = definition.properties[propertyName];
                            this.resolveTo(root, property, resolutionTable, '/definitions');
                        }

                        if (definition.allOf) {
                            definition['x-resolved-from'] = ['#/definitions/' + name];
                            var allOf = definition.allOf;
                            // the refs go first

                            allOf.sort(function (a, b) {
                                if (a.$ref && b.$ref) {
                                    return 0;
                                } else if (a.$ref) {
                                    return -1;
                                }

                                return 1;
                            });

                            for (i = 0; i < allOf.length; i++) {
                                property = allOf[i];
                                location = '/definitions/' + name + '/allOf';
                                this.resolveInline(null, spec, property, resolutionTable, unresolvedRefs, location);
                            }
                        }
                    }

                    // operations
                    for (name in spec.paths) {
                        var method, operation, responseCode;

                        path = spec.paths[name];

                        for (method in path) {
                            // operation reference
                            if (method === '$ref') {
                                // location = path[method];
                                location = '/paths' + name;
                                this.resolveInline(root, spec, path, resolutionTable, unresolvedRefs, location);
                            } else {
                                operation = path[method];

                                var parameters = operation.parameters;

                                for (i in parameters) {
                                    var parameter = parameters[i];

                                    location = '/paths' + name + '/' + method + '/parameters';

                                    if (parameter.in === 'body' && parameter.schema) {
                                        this.resolveTo(root, parameter.schema, resolutionTable, location);
                                    }

                                    if (parameter.$ref) {
                                        // parameter reference
                                        this.resolveInline(root, spec, parameter, resolutionTable, unresolvedRefs, parameter.$ref);
                                    }
                                }

                                for (responseCode in operation.responses) {
                                    var response = operation.responses[responseCode];

                                    location = '/paths' + name + '/' + method + '/responses/' + responseCode;

                                    if (_.isObject(response)) {
                                        if (response.$ref) {
                                            // response reference
                                            this.resolveInline(root, spec, response, resolutionTable, unresolvedRefs, location);
                                        }

                                        if (response.schema) {
                                            this.resolveTo(root, response.schema, resolutionTable, location);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    var expectedCalls = 0,
 toResolve = [];
                    // if the root is same as obj[i].root we can resolve locally
                    var all = resolutionTable;

                    for (i = 0; i < all.length; i++) {
                        var a = all[i];

                        if (root === a.root) {
                            if (a.resolveAs === 'ref') {
                                // resolve any path walking
                                var joined = ((a.root || '') + '/' + a.key).split('/');
                                var normalized = [];
                                var url = '';
                                var k;

                                if (a.key.indexOf('../') >= 0) {
                                    for (var j = 0; j < joined.length; j++) {
                                        if (joined[j] === '..') {
                                            normalized = normalized.slice(0, normalized.length - 1);
                                        } else {
                                            normalized.push(joined[j]);
                                        }
                                    }

                                    for (k = 0; k < normalized.length; k++) {
                                        if (k > 0) {
                                            url += '/';
                                        }
                                        url += normalized[k];
                                    }
                                    // we now have to remote resolve this because the path has changed
                                    a.root = url;
                                    toResolve.push(a);
                                } else {
                                    var parts = a.key.split('#');

                                    if (parts.length === 2) {
                                        if (parts[0].indexOf('http://') === 0 || parts[0].indexOf('https://') === 0) {
                                            a.root = parts[0];
                                        }
                                        location = parts[1].split('/');
                                        var r;
                                        var s = spec;

                                        for (k = 0; k < location.length; k++) {
                                            var part = location[k];

                                            if (part !== '') {
                                                s = s[part];

                                                if (typeof s !== 'undefined') {
                                                    r = s;
                                                } else {
                                                    r = null;
                                                    break;
                                                }
                                            }
                                        }

                                        if (r === null) {
                                            // must resolve this too
                                            toResolve.push(a);
                                        }
                                    }
                                }
                            } else if (a.resolveAs === 'inline') {
                                toResolve.push(a);
                            }
                        } else {
                            toResolve.push(a);
                        }
                    }
                    expectedCalls = toResolve.length;

                    // resolve anything that is local
                    for (var ii = 0; ii < toResolve.length; ii++) {
                        (function (item, self) {
                            if (item.root === null) {
                                // local resolve
                                self.resolveItem(spec, _root, resolutionTable, resolvedRefs, unresolvedRefs, item);
                                processedCalls += 1;

                                if (processedCalls === expectedCalls) {
                                    self.finish(spec, root, resolutionTable, resolvedRefs, unresolvedRefs, callback);
                                }
                            } else {
                                var obj = {
                                    useJQuery: false,  // TODO
                                    url: item.root,
                                    method: 'get',
                                    headers: {
                                        accept: self.scope.swaggerRequestHeaders || 'application/json'
                                    },
                                    on: {
                                        error: function () {
                                            processedCalls += 1;
                                            unresolvedRefs[item.key] = null;

                                            if (processedCalls === expectedCalls) {
                                                self.finish(spec, _root, resolutionTable, resolvedRefs, unresolvedRefs, callback);
                                            }
                                        },  // jshint ignore:line
                                        response: function (response) {
                                            var swagger = response.obj;

                                            self.resolveItem(swagger, _root, resolutionTable, resolvedRefs, unresolvedRefs, item);
                                            processedCalls += 1;

                                            if (processedCalls === expectedCalls) {
                                                self.finish(spec, _root, resolutionTable, resolvedRefs, unresolvedRefs, callback);
                                            }
                                        }
                                    } // jshint ignore:line
                                };

                                if (scope && scope.clientAuthorizations) {
                                    scope.clientAuthorizations.apply(obj);
                                }
                                new SwaggerHttp().execute(obj);
                            }
                        }(toResolve[ii], this));
                    }

                    if (Object.keys(toResolve).length === 0) {
                        this.finish(spec, _root, resolutionTable, resolvedRefs, unresolvedRefs, callback);
                    }
                };

                Resolver.prototype.resolveItem = function (spec, root, resolutionTable, resolvedRefs, unresolvedRefs, item) {
                    var path = item.location;
                    var location = spec,
 parts = path.split('/');

                    for (var j = 0; j < parts.length; j++) {
                        var segment = parts[j];

                        if (segment.indexOf('~1') !== -1) {
                            segment = parts[j].replace(/~0/g, '~').replace(/~1/g, '/');

                            if (segment.charAt(0) !== '/') {
                                segment = '/' + segment;
                            }
                        }

                        if (typeof location === 'undefined' || location === null) {
                            break;
                        }

                        if (segment === '' && j === parts.length - 1  && parts.length > 1) {
                            location = null;
                            break;
                        }

                        if (segment.length > 0) {
                            location = location[segment];
                        }
                    }
                    var resolved = item.key;

                    parts = item.key.split('/');
                    var resolvedName = parts[parts.length - 1];

                    if (resolvedName.indexOf('#') >= 0) {
                        resolvedName = resolvedName.split('#')[1];
                    }

                    if (location !== null && typeof location !== 'undefined') {
                        resolvedRefs[resolved] = {
                            name: resolvedName,
                            obj: location,
                            key: item.key,
                            root: item.root
                        };
                    } else {
                        unresolvedRefs[resolved] = {
                            root: item.root,
                            location: item.location
                        };
                    }
                };

                Resolver.prototype.finish = function (spec, root, resolutionTable, resolvedRefs, unresolvedRefs, callback) {
                    // walk resolution table and replace with resolved refs
                    var ref;

                    for (ref in resolutionTable) {
                        var item = resolutionTable[ref];

                        var key = item.key;
                        var resolvedTo = resolvedRefs[key];

                        if (resolvedTo) {
                            spec.definitions = spec.definitions || {};

                            if (item.resolveAs === 'ref') {
                                spec.definitions[resolvedTo.name] = resolvedTo.obj;
                                item.obj.$ref = '#/definitions/' + resolvedTo.name;
                            } else if (item.resolveAs === 'inline') {
                                var targetObj = item.obj;

                                targetObj['x-resolved-from'] = [item.key];
                                delete targetObj.$ref;

                                for (key in resolvedTo.obj) {
                                    var abs = this.retainRoot(resolvedTo.obj[key], item.root);

                                    targetObj[key] = abs;
                                }
                            }
                        }
                    }
                    var existingUnresolved = this.countUnresolvedRefs(spec);

                    if (existingUnresolved.length === 0 || this.iteration > 5) {
                        this.resolveAllOf(spec.definitions);
                        callback.call(this.scope, spec, unresolvedRefs);
                    } else {
                        this.iteration += 1;
                        this.resolve(spec, root, callback, this.scope);
                    }
                };

                Resolver.prototype.countUnresolvedRefs = function (spec) {
                    var i;
                    var refs = this.getRefs(spec);
                    var keys = [];
                    var unresolvedKeys = [];

                    for (i in refs) {
                        if (i.indexOf('#') === 0) {
                            keys.push(i.substring(1));
                        } else {
                            unresolvedKeys.push(i);
                        }
                    }

                    // verify possible keys
                    for (i = 0; i < keys.length; i++) {
                        var part = keys[i];
                        var parts = part.split('/');
                        var obj = spec;

                        for (var k = 0; k < parts.length; k++) {
                            var key = parts[k];

                            if (key !== '') {
                                obj = obj[key];

                                if (typeof obj === 'undefined') {
                                    unresolvedKeys.push(part);
                                    break;
                                }
                            }
                        }
                    }

                    return unresolvedKeys.length;
                };

                Resolver.prototype.getRefs = function (spec, obj) {
                    obj = obj || spec;
                    var output = {};

                    for (var key in obj) {
                        var item = obj[key];

                        if (key === '$ref' && typeof item === 'string') {
                            output[item] = null;
                        } else if (_.isObject(item)) {
                            var o = this.getRefs(item);

                            for (var k in o) {
                                output[k] = null;
                            }
                        }
                    }

                    return output;
                };

                Resolver.prototype.retainRoot = function (obj, root) {
                    // walk object and look for relative $refs
                    for (var key in obj) {
                        var item = obj[key];

                        if (key === '$ref' && typeof item === 'string') {
                            // stop and inspect
                            if (item.indexOf('http://') !== 0 && item.indexOf('https://') !== 0) {
                                if (item.indexOf('#') !== 0) {
                                    item = '#' + item;
                                }
                                item = (root || '') + item;
                                obj[key] = item;
                            }
                        } else if (_.isObject(item)) {
                            this.retainRoot(item, root);
                        }
                    }

                    return obj;
                };

                /**
                 * immediately in-lines local refs, queues remote refs
                 * for inline resolution
                 */
                Resolver.prototype.resolveInline = function (root, spec, property, resolutionTable, unresolvedRefs, location) {
                    var key = property.$ref,
 ref = property.$ref,
 i, p, p2, rs;
                    var rootTrimmed = false;

                    if (ref) {
                        if (ref.indexOf('../') === 0) {
                            // reset root
                            p = ref.split('../');
                            p2 = root.split('/');
                            ref = '';

                            for (i = 0; i < p.length; i++) {
                                if (p[i] === '') {
                                    p2 = p2.slice(0, p2.length - 1);
                                } else {
                                    ref += p[i];
                                }
                            }
                            root = '';

                            for (i = 0; i < p2.length - 1; i++) {
                                if (i > 0) {
                                    root += '/';
                                }
                                root += p2[i];
                            }
                            rootTrimmed = true;
                        }

                        if (ref.indexOf('#') >= 0) {
                            if (ref.indexOf('/') === 0) {
                                rs = ref.split('#');
                                p  = root.split('//');
                                p2 = p[1].split('/');
                                root = p[0] + '//' + p2[0] + rs[0];
                                location = rs[1];
                            } else {
                                rs = ref.split('#');

                                if (rs[0] !== '') {
                                    p2 = root.split('/');
                                    p2 = p2.slice(0, p2.length - 1);

                                    if (!rootTrimmed) {
                                        root = '';

                                        for (var k = 0; k < p2.length; k++) {
                                            if (k > 0) {
                                                root += '/';
                                            }
                                            root += p2[k];
                                        }
                                    }
                                    root += '/' + ref.split('#')[0];
                                }
                                location = rs[1];
                            }
                        }

                        if (ref.indexOf('http') === 0) {
                            if (ref.indexOf('#') >= 0) {
                                root = ref.split('#')[0];
                                location = ref.split('#')[1];
                            } else {
                                root = ref;
                                location = '';
                            }
                            resolutionTable.push({
                                obj: property, resolveAs: 'inline', root: root, key: key, location: location
                            });
                        } else if (ref.indexOf('#') === 0) {
                            location = ref.split('#')[1];
                            resolutionTable.push({
                                obj: property, resolveAs: 'inline', root: root, key: key, location: location
                            });
                        } else {
                            resolutionTable.push({
                                obj: property, resolveAs: 'inline', root: root, key: key, location: location
                            });
                        }
                    } else if (property.type === 'array') {
                        this.resolveTo(root, property.items, resolutionTable, location);
                    }
                };

                Resolver.prototype.resolveTo = function (root, property, resolutionTable, location) {
                    var ref = property.$ref;

                    if (ref) {
                        if (ref.indexOf('#') >= 0) {
                            location = ref.split('#')[1];
                        }
                        resolutionTable.push({
                            obj: property, resolveAs: 'ref', root: root, key: ref, location: location
                        });
                    } else if (property.type === 'array') {
                        var items = property.items;

                        this.resolveTo(root, items, resolutionTable, location);
                    }
                };

                Resolver.prototype.resolveAllOf = function (spec, obj, depth) {
                    depth = depth || 0;
                    obj = obj || spec;
                    var name;

                    for (var key in obj) {
                        var item = obj[key];

                        if (item === null) {
                            throw new TypeError('Swagger 2.0 does not support null types (' + obj + ').  See https://github.com/swagger-api/swagger-spec/issues/229.');
                        }

                        if (typeof item === 'object') {
                            this.resolveAllOf(spec, item, depth + 1);
                        }

                        if (item && typeof item.allOf !== 'undefined') {
                            var allOf = item.allOf;

                            if (_.isArray(allOf)) {
                                var output = {};

                                output['x-composed'] = true;

                                if (typeof item['x-resolved-from'] !== 'undefined') {
                                    output['x-resolved-from'] = item['x-resolved-from'];
                                }
                                output.properties = {};

                                for (var i = 0; i < allOf.length; i++) {
                                    var component = allOf[i];
                                    var source = 'self';

                                    if (typeof component['x-resolved-from'] !== 'undefined') {
                                        source = component['x-resolved-from'][0];
                                    }

                                    for (var part in component) {
                                        if (!output.hasOwnProperty(part)) {
                                            output[part] = JSON.parse(JSON.stringify(component[part]));

                                            if (part === 'properties') {
                                                for (name in output[part]) {
                                                    output[part][name]['x-resolved-from'] = source;
                                                }
                                            }
                                        } else if (part === 'properties') {
                                            var properties = component[part];

                                            for (name in properties) {
                                                output.properties[name] = JSON.parse(JSON.stringify(properties[name]));
                                                var resolvedFrom = properties[name]['x-resolved-from'];

                                                if (typeof resolvedFrom === 'undefined' || resolvedFrom === 'self') {
                                                    resolvedFrom = source;
                                                }
                                                output.properties[name]['x-resolved-from'] = resolvedFrom;
                                            }
                                        } else if (part === 'required') {
                                            // merge & dedup the required array
                                            var a = output.required.concat(component[part]);

                                            for (var k = 0; k < a.length; ++k) {
                                                for (var j = k + 1; j < a.length; ++j) {
                                                    if (a[k] === a[j]) {
                                                        a.splice(j--, 1);
                                                    }
                                                }
                                            }
                                            output.required = a;
                                        } else if (part === 'x-resolved-from') {
                                            output['x-resolved-from'].push(source);
                                        } else {
                                            // TODO: need to merge this property
                                            // console.log('what to do with ' + part)
                                        }
                                    }
                                }
                                obj[key] = output;
                            }
                        }

                        if (_.isObject(item)) {
                            this.resolveAllOf(spec, item, depth + 1);
                        }
                    }
                };

            },{
                './http': 5,'lodash-compat/lang/isArray': 143,'lodash-compat/lang/isObject': 147
            }],7: [function (require, module, exports) {
                'use strict';

                var Helpers = require('./helpers');

                var _ = {
                    isPlainObject: require('lodash-compat/lang/isPlainObject'),
                    isUndefined: require('lodash-compat/lang/isUndefined'),
                    isArray: require('lodash-compat/lang/isArray'),
                    isObject: require('lodash-compat/lang/isObject'),
                    isEmpty: require('lodash-compat/lang/isEmpty'),
                    map: require('lodash-compat/collection/map'),
                    indexOf: require('lodash-compat/array/indexOf'),
                    cloneDeep: require('lodash-compat/lang/cloneDeep'),
                    keys: require('lodash-compat/object/keys'),
                    forEach: require('lodash-compat/collection/forEach')
                };

                module.exports.optionHtml = optionHtml;
                module.exports.typeFromJsonSchema = typeFromJsonSchema;
                module.exports.getStringSignature = getStringSignature;
                module.exports.schemaToHTML = schemaToHTML;
                module.exports.schemaToJSON = schemaToJSON;

                function optionHtml(label, value) {
                    return '<tr><td class="optionName">' + label + ':</td><td>' + value + '</td></tr>';
                }

                function typeFromJsonSchema(type, format) {
                    var str;

                    if (type === 'integer' && format === 'int32') {
                        str = 'integer';
                    } else if (type === 'integer' && format === 'int64') {
                        str = 'long';
                    } else if (type === 'integer' && typeof format === 'undefined') {
                        str = 'long';
                    } else if (type === 'string' && format === 'date-time') {
                        str = 'date-time';
                    } else if (type === 'string' && format === 'date') {
                        str = 'date';
                    } else if (type === 'number' && format === 'float') {
                        str = 'float';
                    } else if (type === 'number' && format === 'double') {
                        str = 'double';
                    } else if (type === 'number' && typeof format === 'undefined') {
                        str = 'double';
                    } else if (type === 'boolean') {
                        str = 'boolean';
                    } else if (type === 'string') {
                        str = 'string';
                    }

                    return str;
                }

                function getStringSignature(obj, baseComponent) {
                    var str = '';

                    if (typeof obj.$ref !== 'undefined') {
                        str += Helpers.simpleRef(obj.$ref);
                    } else if (typeof obj.type === 'undefined') {
                        str += 'object';
                    } else if (obj.type === 'array') {
                        if (baseComponent) {
                            str += getStringSignature(obj.items || obj.$ref || {});
                        } else {
                            str += 'Array[';
                            str += getStringSignature(obj.items || obj.$ref || {});
                            str += ']';
                        }
                    } else if (obj.type === 'integer' && obj.format === 'int32') {
                        str += 'integer';
                    } else if (obj.type === 'integer' && obj.format === 'int64') {
                        str += 'long';
                    } else if (obj.type === 'integer' && typeof obj.format === 'undefined') {
                        str += 'long';
                    } else if (obj.type === 'string' && obj.format === 'date-time') {
                        str += 'date-time';
                    } else if (obj.type === 'string' && obj.format === 'date') {
                        str += 'date';
                    } else if (obj.type === 'string' && typeof obj.format === 'undefined') {
                        str += 'string';
                    } else if (obj.type === 'number' && obj.format === 'float') {
                        str += 'float';
                    } else if (obj.type === 'number' && obj.format === 'double') {
                        str += 'double';
                    } else if (obj.type === 'number' && typeof obj.format === 'undefined') {
                        str += 'double';
                    } else if (obj.type === 'boolean') {
                        str += 'boolean';
                    } else if (obj.$ref) {
                        str += Helpers.simpleRef(obj.$ref);
                    } else {
                        str += obj.type;
                    }

                    return str;
                }

                function schemaToJSON(schema, models, modelsToIgnore, modelPropertyMacro) {
                    // Resolve the schema (Handle nested schemas)
                    schema = Helpers.resolveSchema(schema);

                    if (typeof modelPropertyMacro !== 'function') {
                        modelPropertyMacro = function (prop) {
                            return (prop || {}).default;
                        };
                    }

                    modelsToIgnore = modelsToIgnore || {};

                    var type = schema.type || 'object';
                    var format = schema.format;
                    var model;
                    var output;

                    if (schema.example) {
                        output = schema.example;
                    } else if (_.isUndefined(schema.items) && _.isArray(schema.enum)) {
                        output = schema.enum[0];
                    }

                    if (_.isUndefined(output)) {
                        if (schema.$ref) {
                            model = models[Helpers.simpleRef(schema.$ref)];

                            if (!_.isUndefined(model)) {
                                if (_.isUndefined(modelsToIgnore[model.name])) {
                                    modelsToIgnore[model.name] = model;
                                    output = schemaToJSON(model.definition, models, modelsToIgnore, modelPropertyMacro);
                                    delete modelsToIgnore[model.name];
                                } else if (model.type === 'array') {
                                    output = [];
                                } else {
                                    output = {};
                                }
                            }
                        } else if (!_.isUndefined(schema.default)) {
                            output = schema.default;
                        } else if (type === 'string') {
                            if (format === 'date-time') {
                                output = new Date().toISOString();
                            } else if (format === 'date') {
                                output = new Date().toISOString().split('T')[0];
                            } else {
                                output = 'string';
                            }
                        } else if (type === 'integer') {
                            output = 0;
                        } else if (type === 'number') {
                            output = 0.0;
                        } else if (type === 'boolean') {
                            output = true;
                        } else if (type === 'object') {
                            output = {};

                            _.forEach(schema.properties, function (property, name) {
                                var cProperty = _.cloneDeep(property);

                                // Allow macro to set the default value
                                cProperty.default = modelPropertyMacro(property);

                                output[name] = schemaToJSON(cProperty, models, modelsToIgnore, modelPropertyMacro);
                            });
                        } else if (type === 'array') {
                            output = [];

                            if (_.isArray(schema.items)) {
                                _.forEach(schema.items, function (item) {
                                    output.push(schemaToJSON(item, models, modelsToIgnore, modelPropertyMacro));
                                });
                            } else if (_.isPlainObject(schema.items)) {
                                output.push(schemaToJSON(schema.items, models, modelsToIgnore, modelPropertyMacro));
                            } else if (_.isUndefined(schema.items)) {
                                output.push({});
                            } else {
                                Helpers.log('Array type\'s \'items\' property is not an array or an object, cannot process');
                            }
                        }
                    }

                    return output;
                }

                function schemaToHTML(name, schema, models, modelPropertyMacro) {

                    var strongOpen = '<span class="strong">';
                    var strongClose = '</span>';

                    // Allow for ignoring the 'name' argument.... shifting the rest
                    if (_.isObject(arguments[0])) {
                        name = void 0;
                        schema = arguments[0];
                        models = arguments[1];
                        modelPropertyMacro = arguments[2];
                    }

                    models = models || {};

                    // Resolve the schema (Handle nested schemas)
                    schema = Helpers.resolveSchema(schema);

                    // Return for empty object
                    if (_.isEmpty(schema)) {
                        return strongOpen + 'Empty' + strongClose;
                    }

                    // Dereference $ref from 'models'
                    if (typeof schema.$ref === 'string') {
                        name = Helpers.simpleRef(schema.$ref);
                        schema = models[name];
                    }

                    if (typeof name !== 'string') {
                        name = schema.title || 'Inline Model';
                    }

                    // If we are a Model object... adjust accordingly
                    if (schema.definition) {
                        schema = schema.definition;
                    }

                    if (typeof modelPropertyMacro !== 'function') {
                        modelPropertyMacro = function (prop) {
                            return (prop || {}).default;
                        };
                    }

                    var references = {};
                    var seenModels = [];
                    var inlineModels = 0;



                    // Generate current HTML
                    var html = processModel(schema, name);

                    // Generate references HTML
                    while (_.keys(references).length > 0) {
                        /* jshint ignore:start */
                        _.forEach(references, function (schema, name) {
                            var seenModel = _.indexOf(seenModels, name) > -1;

                            delete references[name];

                            if (!seenModel) {
                                seenModels.push(name);

                                html += '<br />' + processModel(schema, name);
                            }
                        });
                        /* jshint ignore:end */
                    }

                    return html;

                    /////////////////////////////////

                    function addReference(schema, name, skipRef) {
                        var modelName = name;
                        var model;

                        if (schema.$ref) {
                            modelName = schema.title || Helpers.simpleRef(schema.$ref);
                            model = models[modelName];
                        } else if (_.isUndefined(name)) {
                            modelName = schema.title || 'Inline Model ' + ++inlineModels;
                            model = {
                                definition: schema
                            };
                        }

                        if (skipRef !== true) {
                            references[modelName] = _.isUndefined(model) ? {} : model.definition;
                        }

                        return modelName;
                    }

                    function primitiveToHTML(schema) {
                        var html = '<span class="propType">';
                        var type = schema.type || 'object';

                        if (schema.$ref) {
                            html += addReference(schema, Helpers.simpleRef(schema.$ref));
                        } else if (type === 'object') {
                            if (!_.isUndefined(schema.properties)) {
                                html += addReference(schema);
                            } else {
                                html += 'object';
                            }
                        } else if (type === 'array') {
                            html += 'Array[';

                            if (_.isArray(schema.items)) {
                                html += _.map(schema.items, addReference).join(',');
                            } else if (_.isPlainObject(schema.items)) {
                                if (_.isUndefined(schema.items.$ref)) {
                                    if (!_.isUndefined(schema.items.type) && _.indexOf(['array', 'object'], schema.items.type) === -1) {
                                        html += schema.items.type;
                                    } else {
                                        html += addReference(schema.items);
                                    }
                                } else {
                                    html += addReference(schema.items, Helpers.simpleRef(schema.items.$ref));
                                }
                            } else {
                                Helpers.log('Array type\'s \'items\' schema is not an array or an object, cannot process');
                                html += 'object';
                            }

                            html += ']';
                        } else {
                            html += schema.type;
                        }

                        html += '</span>';

                        return html;
                    }
                    function primitiveToOptionsHTML(schema, html) {
                        var options = '';
                        var type = schema.type || 'object';
                        var isArray = type === 'array';

                        if (isArray) {
                            if (_.isPlainObject(schema.items) && !_.isUndefined(schema.items.type)) {
                                type = schema.items.type;
                            } else {
                                type = 'object';
                            }
                        }

                        if (!_.isUndefined(schema.default)) {
                            options += optionHtml('Default', schema.default);
                        }

                        switch (type) {
                            case 'string':
                                if (schema.minLength) {
                                    options += optionHtml('Min. Length', schema.minLength);
                                }

                                if (schema.maxLength) {
                                    options += optionHtml('Max. Length', schema.maxLength);
                                }

                                if (schema.pattern) {
                                    options += optionHtml('Reg. Exp.', schema.pattern);
                                }
                                break;

                            case 'integer':
                            case 'number':
                                if (schema.minimum) {
                                    options += optionHtml('Min. Value', schema.minimum);
                                }

                                if (schema.exclusiveMinimum) {
                                    options += optionHtml('Exclusive Min.', 'true');
                                }

                                if (schema.maximum) {
                                    options += optionHtml('Max. Value', schema.maximum);
                                }

                                if (schema.exclusiveMaximum) {
                                    options += optionHtml('Exclusive Max.', 'true');
                                }

                                if (schema.multipleOf) {
                                    options += optionHtml('Multiple Of', schema.multipleOf);
                                }

                                break;
                        }

                        if (isArray) {
                            if (schema.minItems) {
                                options += optionHtml('Min. Items', schema.minItems);
                            }

                            if (schema.maxItems) {
                                options += optionHtml('Max. Items', schema.maxItems);
                            }

                            if (schema.uniqueItems) {
                                options += optionHtml('Unique Items', 'true');
                            }

                            if (schema.collectionFormat) {
                                options += optionHtml('Coll. Format', schema.collectionFormat);
                            }
                        }

                        if (_.isUndefined(schema.items)) {
                            if (_.isArray(schema.enum)) {
                                var enumString;

                                if (type === 'number' || type === 'integer') {
                                    enumString = schema.enum.join(', ');
                                } else {
                                    enumString = '"' + schema.enum.join('", "') + '"';
                                }

                                options += optionHtml('Enum', enumString);
                            }
                        }

                        if (options.length > 0) {
                            html = '<span class="propWrap">' + html + '<table class="optionsWrapper"><tr><th colspan="2">' + type + '</th></tr>' + options + '</table></span>';
                        }

                        return html;
                    }
                    function processModel(schema, name) {
                        var type = schema.type || 'object';
                        var isArray = schema.type === 'array';
                        var html = strongOpen + name + ' ' + (isArray ? '[' : '{') + strongClose;

                        if (name) {
                            seenModels.push(name);
                        }

                        if (isArray) {
                            if (_.isArray(schema.items)) {
                                html += '<div>' + _.map(schema.items, function (item) {
                                    var type = item.type || 'object';

                                    if (_.isUndefined(item.$ref)) {
                                        if (_.indexOf(['array', 'object'], type) > -1) {
                                            if (type === 'object' && _.isUndefined(item.properties)) {
                                                return 'object';
                                            }

                                            return addReference(item);

                                        }

                                        return primitiveToOptionsHTML(item, type);

                                    }

                                    return addReference(item, Helpers.simpleRef(item.$ref));

                                }).join(',</div><div>');
                            } else if (_.isPlainObject(schema.items)) {
                                if (_.isUndefined(schema.items.$ref)) {
                                    if (_.indexOf(['array', 'object'], schema.items.type || 'object') > -1) {
                                        if ((_.isUndefined(schema.items.type) || schema.items.type === 'object') && _.isUndefined(schema.items.properties)) {
                                            html += '<div>object</div>';
                                        } else {
                                            html += '<div>' + addReference(schema.items) + '</div>';
                                        }
                                    } else {
                                        html += '<div>' + primitiveToOptionsHTML(schema.items, schema.items.type) + '</div>';
                                    }
                                } else {
                                    html += '<div>' + addReference(schema.items, Helpers.simpleRef(schema.items.$ref)) + '</div>';
                                }
                            } else {
                                Helpers.log('Array type\'s \'items\' property is not an array or an object, cannot process');
                                html += '<div>object</div>';
                            }
                        } else if (schema.$ref) {
                            html += '<div>' + addReference(schema, name) + '</div>';
                        } else if (type === 'object') {
                            html += '<div>';

                            if (_.isPlainObject(schema.properties)) {
                                html += _.map(schema.properties, function (property, name) {
                                    var propertyIsRequired = _.indexOf(schema.required, name) >= 0;
                                    var cProperty = _.cloneDeep(property);

                                    var requiredClass = propertyIsRequired ? 'required' : '';
                                    var html = '<span class="propName ' + requiredClass + '">' + name + '</span> (';
                                    var model;

                                    // Allow macro to set the default value
                                    cProperty.default = modelPropertyMacro(cProperty);

                                    // Resolve the schema (Handle nested schemas)
                                    cProperty = Helpers.resolveSchema(cProperty);

                                    // We need to handle property references to primitives (Issue 339)
                                    if (!_.isUndefined(cProperty.$ref)) {
                                        model = models[Helpers.simpleRef(cProperty.$ref)];

                                        if (!_.isUndefined(model) && _.indexOf([undefined, 'array', 'object'], model.definition.type) === -1) {
                                            // Use referenced schema
                                            cProperty = Helpers.resolveSchema(model.definition);
                                        }
                                    }

                                    html += primitiveToHTML(cProperty);

                                    if (!propertyIsRequired) {
                                        html += ', <span class="propOptKey">optional</span>';
                                    }

                                    html += ')';

                                    if (!_.isUndefined(cProperty.description)) {
                                        html += ': ' + '<span class="propDesc">' + cProperty.description + '</span>';
                                    }

                                    if (cProperty.enum) {
                                        html += ' = <span class="propVals">[\'' + cProperty.enum.join('\', \'') + '\']</span>';
                                    }

                                    return primitiveToOptionsHTML(cProperty, html);
                                }).join(',</div><div>');
                            }

                            html += '</div>';
                        } else {
                            html += '<div>' + primitiveToOptionsHTML(schema, type) + '</div>';
                        }

                        return html + strongOpen + (isArray ? ']' : '}') + strongClose;
                    }

                }

            },{
                './helpers': 4,'lodash-compat/array/indexOf': 52,'lodash-compat/collection/forEach': 57,'lodash-compat/collection/map': 59,'lodash-compat/lang/cloneDeep': 141,'lodash-compat/lang/isArray': 143,'lodash-compat/lang/isEmpty': 144,'lodash-compat/lang/isObject': 147,'lodash-compat/lang/isPlainObject': 148,'lodash-compat/lang/isUndefined': 151,'lodash-compat/object/keys': 152
            }],8: [function (require, module, exports) {
                'use strict';

                var SwaggerHttp = require('./http');
                var _ = {
                    isObject: require('lodash-compat/lang/isObject')
                };

                var SwaggerSpecConverter = module.exports = function () {
                    this.errors = [];
                    this.warnings = [];
                    this.modelMap = {};
                };

                SwaggerSpecConverter.prototype.setDocumentationLocation = function (location) {
                    this.docLocation = location;
                };

                /**
                 * converts a resource listing OR api declaration
                 **/
                SwaggerSpecConverter.prototype.convert = function (obj, clientAuthorizations, callback) {
                    // not a valid spec
                    if (!obj || !Array.isArray(obj.apis)) {
                        return this.finish(callback, null);
                    }
                    this.clientAuthorizations = clientAuthorizations;

                    // create a new swagger object to return
                    var swagger = {
                        swagger: '2.0'
                    };

                    swagger.originalVersion = obj.swaggerVersion;

                    // add the info
                    this.apiInfo(obj, swagger);

                    // add security definitions
                    this.securityDefinitions(obj, swagger);

                    // take basePath into account
                    if (obj.basePath) {
                        this.setDocumentationLocation(obj.basePath);
                    }

                    // see if this is a single-file swagger definition
                    var isSingleFileSwagger = false;
                    var i;

                    for (i = 0; i < obj.apis.length; i++) {
                        var api = obj.apis[i];

                        if (Array.isArray(api.operations)) {
                            isSingleFileSwagger = true;
                        }
                    }

                    if (isSingleFileSwagger) {
                        this.declaration(obj, swagger);
                        this.finish(callback, swagger);
                    } else {
                        this.resourceListing(obj, swagger, callback);
                    }
                };

                SwaggerSpecConverter.prototype.declaration = function (obj, swagger) {
                    var name, i, p, pos;

                    if (!obj.apis) {
                        return;
                    }

                    if (obj.basePath.indexOf('http://') === 0) {
                        p = obj.basePath.substring('http://'.length);
                        pos = p.indexOf('/');

                        if (pos > 0) {
                            swagger.host = p.substring(0, pos);
                            swagger.basePath = p.substring(pos);
                        } else {
                            swagger.host = p;
                            swagger.basePath = '/';
                        }
                    } else if (obj.basePath.indexOf('https://') === 0) {
                        p = obj.basePath.substring('https://'.length);
                        pos = p.indexOf('/');

                        if (pos > 0) {
                            swagger.host = p.substring(0, pos);
                            swagger.basePath = p.substring(pos);
                        } else {
                            swagger.host = p;
                            swagger.basePath = '/';
                        }
                    } else {
                        swagger.basePath = obj.basePath;
                    }

                    var resourceLevelAuth;

                    if (obj.authorizations) {
                        resourceLevelAuth = obj.authorizations;
                    }

                    if (obj.consumes) {
                        swagger.consumes = obj.consumes;
                    }

                    if (obj.produces) {
                        swagger.produces = obj.produces;
                    }

                    // build a mapping of id to name for 1.0 model resolutions
                    if (_.isObject(obj)) {
                        for (name in obj.models) {
                            var existingModel = obj.models[name];
                            var key = existingModel.id || name;

                            this.modelMap[key] = name;
                        }
                    }

                    for (i = 0; i < obj.apis.length; i++) {
                        var api = obj.apis[i];
                        var path = api.path;
                        var operations = api.operations;

                        this.operations(path, obj.resourcePath, operations, resourceLevelAuth, swagger);
                    }

                    var models = obj.models || {};

                    this.models(models, swagger);
                };

                SwaggerSpecConverter.prototype.models = function (obj, swagger) {
                    if (!_.isObject(obj)) {
                        return;
                    }
                    var name;

                    swagger.definitions = swagger.definitions || {};

                    for (name in obj) {
                        var existingModel = obj[name];
                        var _enum = [];
                        var schema = {
                            properties: {}
                        };
                        var propertyName;

                        for (propertyName in existingModel.properties) {
                            var existingProperty = existingModel.properties[propertyName];
                            var property = {};

                            this.dataType(existingProperty, property);

                            if (existingProperty.description) {
                                property.description = existingProperty.description;
                            }

                            if (existingProperty['enum']) {
                                property['enum'] = existingProperty['enum'];
                            }

                            if (typeof existingProperty.required === 'boolean' && existingProperty.required === true) {
                                _enum.push(propertyName);
                            }

                            if (typeof existingProperty.required === 'string' && existingProperty.required === 'true') {
                                _enum.push(propertyName);
                            }
                            schema.properties[propertyName] = property;
                        }

                        if (_enum.length > 0) {
                            schema['enum'] = _enum;
                        }

                        schema.required = existingModel.required;
                        swagger.definitions[name] = schema;
                    }
                };

                SwaggerSpecConverter.prototype.extractTag = function (resourcePath) {
                    var pathString = resourcePath || 'default';

                    if (pathString.indexOf('http:') === 0 || pathString.indexOf('https:') === 0) {
                        pathString = pathString.split(['/']);
                        pathString = pathString[pathString.length - 1].substring();
                    }

                    if (pathString.endsWith('.json')) {
                        pathString = pathString.substring(0, pathString.length - '.json'.length);
                    }

                    return pathString.replace('/', '');
                };

                SwaggerSpecConverter.prototype.operations = function (path, resourcePath, obj, resourceLevelAuth, swagger) {
                    if (!Array.isArray(obj)) {
                        return;
                    }
                    var i;

                    if (!swagger.paths) {
                        swagger.paths = {};
                    }

                    var pathObj = swagger.paths[path] || {};
                    var tag = this.extractTag(resourcePath);

                    swagger.tags = swagger.tags || [];
                    var matched = false;

                    for (i = 0; i < swagger.tags.length; i++) {
                        var tagObject = swagger.tags[i];

                        if (tagObject.name === tag) {
                            matched = true;
                        }
                    }

                    if (!matched) {
                        swagger.tags.push({
                            name: tag
                        });
                    }

                    for (i = 0; i < obj.length; i++) {
                        var existingOperation = obj[i];
                        var method = (existingOperation.method || existingOperation.httpMethod).toLowerCase();
                        var operation = {
                            tags: [tag]
                        };
                        var existingAuthorizations = existingOperation.authorizations;

                        if (existingAuthorizations && Object.keys(existingAuthorizations).length === 0) {
                            existingAuthorizations = resourceLevelAuth;
                        }

                        if (typeof existingAuthorizations !== 'undefined') {
                            var scopesObject;

                            for (var key in existingAuthorizations) {
                                operation.security = operation.security || [];
                                var scopes = existingAuthorizations[key];

                                if (scopes) {
                                    var securityScopes = [];

                                    for (var j in scopes) {
                                        securityScopes.push(scopes[j].scope);
                                    }
                                    scopesObject = {};
                                    scopesObject[key] = securityScopes;
                                    operation.security.push(scopesObject);
                                } else {
                                    scopesObject = {};
                                    scopesObject[key] = [];
                                    operation.security.push(scopesObject);
                                }
                            }
                        }

                        if (existingOperation.consumes) {
                            operation.consumes = existingOperation.consumes;
                        } else if (swagger.consumes) {
                            operation.consumes = swagger.consumes;
                        }

                        if (existingOperation.produces) {
                            operation.produces = existingOperation.produces;
                        } else if (swagger.produces) {
                            operation.produces = swagger.produces;
                        }

                        if (existingOperation.summary) {
                            operation.summary = existingOperation.summary;
                        }

                        if (existingOperation.notes) {
                            operation.description = existingOperation.notes;
                        }

                        if (existingOperation.nickname) {
                            operation.operationId = existingOperation.nickname;
                        }

                        if (existingOperation.deprecated) {
                            operation.deprecated = existingOperation.deprecated;
                        }

                        this.authorizations(existingAuthorizations, swagger);
                        this.parameters(operation, existingOperation.parameters, swagger);
                        this.responseMessages(operation, existingOperation, swagger);

                        pathObj[method] = operation;
                    }

                    swagger.paths[path] = pathObj;
                };

                SwaggerSpecConverter.prototype.responseMessages = function (operation, existingOperation) {
                    if (!_.isObject(existingOperation)) {
                        return;
                    }
                    // build default response from the operation (1.x)
                    var defaultResponse = {};

                    this.dataType(existingOperation, defaultResponse);
                    // TODO: look into the real problem of rendering responses in swagger-ui
                    // ....should reponseType have an implicit schema?
                    if (!defaultResponse.schema && defaultResponse.type) {
                        defaultResponse = {
                            schema: defaultResponse
                        };
                    }

                    operation.responses = operation.responses || {};

                    // grab from responseMessages (1.2)
                    var has200 = false;

                    if (Array.isArray(existingOperation.responseMessages)) {
                        var i;
                        var existingResponses = existingOperation.responseMessages;

                        for (i = 0; i < existingResponses.length; i++) {
                            var existingResponse = existingResponses[i];
                            var response = {
                                description: existingResponse.message
                            };

                            if (existingResponse.code === 200) {
                                has200 = true;
                            }
                            // Convert responseModel -> schema{$ref: responseModel}
                            if (existingResponse.responseModel) {
                                response.schema = {
                                    '$ref': existingResponse.responseModel
                                };
                            }
                            operation.responses['' + existingResponse.code] = response;
                        }
                    }

                    if (has200) {
                        operation.responses['default'] = defaultResponse;
                    } else {
                        operation.responses['200'] = defaultResponse;
                    }
                };

                SwaggerSpecConverter.prototype.authorizations = function (obj) {
                    // TODO
                    if (!_.isObject(obj)) {
                        return;
                    }
                };

                SwaggerSpecConverter.prototype.parameters = function (operation, obj) {
                    if (!Array.isArray(obj)) {
                        return;
                    }
                    var i;

                    for (i = 0; i < obj.length; i++) {
                        var existingParameter = obj[i];
                        var parameter = {};

                        parameter.name = existingParameter.name;
                        parameter.description = existingParameter.description;
                        parameter.required = existingParameter.required;
                        parameter.in = existingParameter.paramType;

                        // per #168
                        if (parameter.in === 'body') {
                            parameter.name = 'body';
                        }

                        if (parameter.in === 'form') {
                            parameter.in = 'formData';
                        }

                        if (existingParameter.enum) {
                            parameter.enum = existingParameter.enum;
                        }

                        if (existingParameter.allowMultiple === true || existingParameter.allowMultiple === 'true') {
                            var innerType = {};

                            this.dataType(existingParameter, innerType);
                            parameter.type = 'array';
                            parameter.items = innerType;

                            if (existingParameter.allowableValues) {
                                var av = existingParameter.allowableValues;

                                if (av.valueType === 'LIST') {
                                    parameter['enum'] = av.values;
                                }
                            }
                        } else {
                            this.dataType(existingParameter, parameter);
                        }

                        operation.parameters = operation.parameters || [];
                        operation.parameters.push(parameter);
                    }
                };

                SwaggerSpecConverter.prototype.dataType = function (source, target) {
                    if (!_.isObject(source)) {
                        return;
                    }

                    if (source.minimum) {
                        target.minimum = source.minimum;
                    }

                    if (source.maximum) {
                        target.maximum = source.maximum;
                    }

                    if (source.format) {
                        target.format = source.format;
                    }

                    // default can be 'false'
                    if (typeof source.defaultValue !== 'undefined') {
                        target.default = source.defaultValue;
                    }

                    var jsonSchemaType = this.toJsonSchema(source);

                    if (jsonSchemaType) {
                        target = target || {};

                        if (jsonSchemaType.type) {
                            target.type = jsonSchemaType.type;
                        }

                        if (jsonSchemaType.format) {
                            target.format = jsonSchemaType.format;
                        }

                        if (jsonSchemaType.$ref) {
                            target.schema = {
                                $ref: jsonSchemaType.$ref
                            };
                        }

                        if (jsonSchemaType.items) {
                            target.items = jsonSchemaType.items;
                        }
                    }
                };

                SwaggerSpecConverter.prototype.toJsonSchema = function (source) {
                    if (!source) {
                        return 'object';
                    }
                    var detectedType = source.type || source.dataType || source.responseClass || '';
                    var lcType = detectedType.toLowerCase();
                    var format = (source.format || '').toLowerCase();

                    if (lcType.indexOf('list[') === 0) {
                        var innerType = detectedType.substring(5, detectedType.length - 1);
                        var jsonType = this.toJsonSchema({
                            type: innerType
                        });

                        return {
                            type: 'array', items: jsonType
                        };
                    } else if (lcType === 'int' || lcType === 'integer' && format === 'int32') {
                        return {
                            type: 'integer', format: 'int32'
                        };
                    } else if (lcType === 'long' || lcType === 'integer' && format === 'int64') {
                        return {
                            type: 'integer', format: 'int64'
                        };
                    } else if (lcType === 'integer') {
                        return {
                            type: 'integer', format: 'int64'
                        };
                    } else if (lcType === 'float' || lcType === 'number' && format === 'float') {
                        return {
                            type: 'number', format: 'float'
                        };
                    } else if (lcType === 'double' || lcType === 'number' && format === 'double') {
                        return {
                            type: 'number', format: 'double'
                        };
                    } else if (lcType === 'string' && format === 'date-time' || lcType === 'date') {
                        return {
                            type: 'string', format: 'date-time'
                        };
                    } else if (lcType === 'string') {
                        return {
                            type: 'string'
                        };
                    } else if (lcType === 'file') {
                        return {
                            type: 'file'
                        };
                    } else if (lcType === 'boolean') {
                        return {
                            type: 'boolean'
                        };
                    } else if (lcType === 'array' || lcType === 'list') {
                        if (source.items) {
                            var it = this.toJsonSchema(source.items);

                            return {
                                type: 'array', items: it
                            };
                        }

                        return {
                            type: 'array', items: {
                                type: 'object'
                            }
                        };

                    } else if (source.$ref) {
                        return {
                            $ref: '#/definitions/' + this.modelMap[source.$ref] || source.$ref
                        };
                    } else if (lcType === 'void' || lcType === '') {
                        return {};
                    }

                    return {
                        $ref: '#/definitions/' + this.modelMap[source.type] || source.type
                    };

                };

                SwaggerSpecConverter.prototype.resourceListing = function (obj, swagger, callback) {
                    var i;
                    var processedCount = 0;   // jshint ignore:line
                    var self = this;          // jshint ignore:line
                    var expectedCount = obj.apis.length;
                    var _swagger = swagger;   // jshint ignore:line

                    if (expectedCount === 0) {
                        this.finish(callback, swagger);
                    }

                    for (i = 0; i < expectedCount; i++) {
                        var api = obj.apis[i];
                        var path = api.path;
                        var absolutePath = this.getAbsolutePath(obj.swaggerVersion, this.docLocation, path);

                        if (api.description) {
                            swagger.tags = swagger.tags || [];
                            swagger.tags.push({
                                name: this.extractTag(api.path),
                                description: api.description || ''
                            });
                        }
                        var http = {
                            url: absolutePath,
                            headers: {
                                accept: 'application/json'
                            },
                            on: {},
                            method: 'get'
                        };
                        /* jshint ignore:start */

                        http.on.response = function (data) {
                            processedCount += 1;
                            var obj = data.obj;

                            if (obj) {
                                self.declaration(obj, _swagger);
                            }

                            if (processedCount === expectedCount) {
                                self.finish(callback, _swagger);
                            }
                        };
                        http.on.error = function (data) {
                            console.error(data);
                            processedCount += 1;

                            if (processedCount === expectedCount) {
                                self.finish(callback, _swagger);
                            }
                        };
                        /* jshint ignore:end */

                        if (this.clientAuthorizations && typeof this.clientAuthorizations.apply === 'function') {
                            this.clientAuthorizations.apply(http);
                        }

                        new SwaggerHttp().execute(http);
                    }
                };

                SwaggerSpecConverter.prototype.getAbsolutePath = function (version, docLocation, path)  {
                    if (version === '1.0') {
                        if (docLocation.endsWith('.json')) {
                            // get root path
                            var pos = docLocation.lastIndexOf('/');

                            if (pos > 0) {
                                docLocation = docLocation.substring(0, pos);
                            }
                        }
                    }

                    var location = docLocation;

                    if (path.indexOf('http://') === 0 || path.indexOf('https://') === 0) {
                        location = path;
                    } else {
                        if (docLocation.endsWith('/')) {
                            location = docLocation.substring(0, docLocation.length - 1);
                        }
                        location += path;
                    }
                    location = location.replace('{format}', 'json');

                    return location;
                };

                SwaggerSpecConverter.prototype.securityDefinitions = function (obj, swagger) {
                    if (obj.authorizations) {
                        var name;

                        for (name in obj.authorizations) {
                            var isValid = false;
                            var securityDefinition = {};
                            var definition = obj.authorizations[name];

                            if (definition.type === 'apiKey') {
                                securityDefinition.type = 'apiKey';
                                securityDefinition.in = definition.passAs;
                                securityDefinition.name = definition.keyname || name;
                                isValid = true;
                            } else if (definition.type === 'oauth2') {
                                var existingScopes = definition.scopes || [];
                                var scopes = {};
                                var i;

                                for (i in existingScopes) {
                                    var scope = existingScopes[i];

                                    scopes[scope.scope] = scope.description;
                                }
                                securityDefinition.type = 'oauth2';

                                if (i > 0) {
                                    securityDefinition.scopes = scopes;
                                }

                                if (definition.grantTypes) {
                                    if (definition.grantTypes.implicit) {
                                        var implicit = definition.grantTypes.implicit;

                                        securityDefinition.flow = 'implicit';
                                        securityDefinition.authorizationUrl = implicit.loginEndpoint;
                                        isValid = true;
                                    }
                                    /* jshint ignore:start */
                                    if (definition.grantTypes['authorization_code']) {
                                        if (!securityDefinition.flow) {
                                            // cannot set if flow is already defined
                                            var authCode = definition.grantTypes['authorization_code'];

                                            securityDefinition.flow = 'accessCode';
                                            securityDefinition.authorizationUrl = authCode.tokenRequestEndpoint.url;
                                            securityDefinition.tokenUrl = authCode.tokenEndpoint.url;
                                            isValid = true;
                                        }
                                    }
                                    /* jshint ignore:end */
                                }
                            }

                            if (isValid) {
                                swagger.securityDefinitions = swagger.securityDefinitions || {};
                                swagger.securityDefinitions[name] = securityDefinition;
                            }
                        }
                    }
                };

                SwaggerSpecConverter.prototype.apiInfo = function (obj, swagger) {
                    // info section
                    if (obj.info) {
                        var info = obj.info;

                        swagger.info = {};

                        if (info.contact) {
                            swagger.info.contact = {};
                            swagger.info.contact.email = info.contact;
                        }

                        if (info.description) {
                            swagger.info.description = info.description;
                        }

                        if (info.title) {
                            swagger.info.title = info.title;
                        }

                        if (info.termsOfServiceUrl) {
                            swagger.info.termsOfService = info.termsOfServiceUrl;
                        }

                        if (info.license || info.licenseUrl) {
                            swagger.license = {};

                            if (info.license) {
                                swagger.license.name = info.license;
                            }

                            if (info.licenseUrl) {
                                swagger.license.url = info.licenseUrl;
                            }
                        }
                    } else {
                        this.warnings.push('missing info section');
                    }
                };

                SwaggerSpecConverter.prototype.finish = function (callback, obj) {
                    callback(obj);
                };

            },{
                './http': 5,'lodash-compat/lang/isObject': 147
            }],9: [function (require, module, exports) {
                'use strict';

                var _ = {
                    isPlainObject: require('lodash-compat/lang/isPlainObject'),
                    isString: require('lodash-compat/lang/isString')
                };

                var SchemaMarkup = require('../schema-markup.js');
                var jsyaml = require('js-yaml');

                var Model = module.exports = function (name, definition, models, modelPropertyMacro) {
                    this.definition = definition || {};
                    this.isArray = definition.type === 'array';
                    this.models = models || {};
                    this.name = definition.title || name || 'Inline Model';
                    this.modelPropertyMacro = modelPropertyMacro || function (property) {
                        return property.default;
                    };

                    return this;
                };

                Model.prototype.createJSONSample = Model.prototype.getSampleValue = function (modelsToIgnore) {
                    modelsToIgnore = modelsToIgnore || {};

                    modelsToIgnore[this.name] = this;

                    // Response support
                    if (this.examples && _.isPlainObject(this.examples) && this.examples['application/json']) {
                        this.definition.example = this.examples['application/json'];

                        if (_.isString(this.definition.example)) {
                            this.definition.example = jsyaml.safeLoad(this.definition.example);
                        }
                    } else if (!this.definition.example) {
                        this.definition.example = this.examples;
                    }

                    return SchemaMarkup.schemaToJSON(this.definition, this.models, modelsToIgnore, this.modelPropertyMacro);
                };

                Model.prototype.getMockSignature = function () {
                    return SchemaMarkup.schemaToHTML(this.name, this.definition, this.models, this.modelPropertyMacro);
                };

            },{
                '../schema-markup.js': 7,'js-yaml': 21,'lodash-compat/lang/isPlainObject': 148,'lodash-compat/lang/isString': 149
            }],10: [function (require, module, exports) {
                'use strict';

                var _ = {
                    cloneDeep: require('lodash-compat/lang/cloneDeep'),
                    isUndefined: require('lodash-compat/lang/isUndefined'),
                    isEmpty: require('lodash-compat/lang/isEmpty'),
                    isObject: require('lodash-compat/lang/isObject')
                };
                var helpers = require('../helpers');
                var Model = require('./model');
                var SwaggerHttp = require('../http');

                var Operation = module.exports = function (parent, scheme, operationId, httpMethod, path, args, definitions, models, clientAuthorizations) {
                    var errors = [];

                    parent = parent || {};
                    args = args || {};

                    if (parent && parent.options) {
                        this.client = parent.options.client || null;
                        this.responseInterceptor = parent.options.responseInterceptor || null;
                    }
                    this.authorizations = args.security;
                    this.basePath = parent.basePath || '/';
                    this.clientAuthorizations = clientAuthorizations;
                    this.consumes = args.consumes || parent.consumes || ['application/json'];
                    this.produces = args.produces || parent.produces || ['application/json'];
                    this.deprecated = args.deprecated;
                    this.description = args.description;
                    this.host = parent.host || 'localhost';
                    this.method = httpMethod || errors.push('Operation ' + operationId + ' is missing method.');
                    this.models = models || {};
                    this.nickname = operationId || errors.push('Operations must have a nickname.');
                    this.operation = args;
                    this.operations = {};
                    this.parameters = args !== null ? args.parameters || [] : {};
                    this.parent = parent;
                    this.path = path || errors.push('Operation ' + this.nickname + ' is missing path.');
                    this.responses = args.responses || {};
                    this.scheme = scheme || parent.scheme || 'http';
                    this.schemes = args.schemes || parent.schemes;
                    this.security = args.security;
                    this.summary = args.summary || '';
                    this.type = null;
                    this.useJQuery = parent.useJQuery;
                    this.parameterMacro = parent.parameterMacro || function (parameter) {
                        return parameter.default;
                    };

                    this.inlineModels = [];

                    if (typeof this.deprecated === 'string') {
                        switch (this.deprecated.toLowerCase()) {
                            case 'true': case 'yes': case '1': {
                                this.deprecated = true;
                                break;
                            }

                            case 'false': case 'no': case '0': case null: {
                                this.deprecated = false;
                                break;
                            }

                            default: this.deprecated = Boolean(this.deprecated);
                        }
                    }

                    var i, model;

                    if (definitions) {
                        // add to global models
                        var key;

                        for (key in definitions) {
                            model = new Model(key, definitions[key], this.models, parent.modelPropertyMacro);

                            if (model) {
                                this.models[key] = model;
                            }
                        }
                    }

                    for (i = 0; i < this.parameters.length; i++) {
                        var param = this.parameters[i];

                        // Allow macro to set the default value
                        param.default = this.parameterMacro(param);

                        if (param.type === 'array') {
                            param.isList = true;
                            param.allowMultiple = true;
                            // the enum can be defined at the items level
                            if (param.items && param.items.enum) {
                                param['enum'] = param.items.enum;
                            }
                        }

                        var innerType = this.getType(param);

                        if (innerType && innerType.toString().toLowerCase() === 'boolean') {
                            param.allowableValues = {};
                            param.isList = true;
                            param['enum'] = [true, false]; // use actual primitives
                        }

                        if (typeof param['enum'] !== 'undefined') {
                            var id;

                            param.allowableValues = {};
                            param.allowableValues.values = [];
                            param.allowableValues.descriptiveValues = [];

                            for (id = 0; id < param['enum'].length; id++) {
                                var value = param['enum'][id];
                                var isDefault = value === param.default || value + '' === param.default;

                                param.allowableValues.values.push(value);
                                // Always have string for descriptive values....
                                param.allowableValues.descriptiveValues.push({
                                    value: value + '', isDefault: isDefault
                                });
                            }
                        }

                        if (param.type === 'array') {
                            innerType = [innerType];

                            if (typeof param.allowableValues === 'undefined') {
                                // can't show as a list if no values to select from
                                delete param.isList;
                                delete param.allowMultiple;
                            }
                        }

                        param.signature = this.getModelSignature(innerType, this.models).toString();
                        param.sampleJSON = this.getModelSampleJSON(innerType, this.models);
                        param.responseClassSignature = param.signature;
                    }

                    var defaultResponseCode, response, responses = this.responses;

                    if (responses['200']) {
                        response = responses['200'];
                        defaultResponseCode = '200';
                    } else if (responses['201']) {
                        response = responses['201'];
                        defaultResponseCode = '201';
                    } else if (responses['202']) {
                        response = responses['202'];
                        defaultResponseCode = '202';
                    } else if (responses['203']) {
                        response = responses['203'];
                        defaultResponseCode = '203';
                    } else if (responses['204']) {
                        response = responses['204'];
                        defaultResponseCode = '204';
                    } else if (responses['205']) {
                        response = responses['205'];
                        defaultResponseCode = '205';
                    } else if (responses['206']) {
                        response = responses['206'];
                        defaultResponseCode = '206';
                    } else if (responses['default']) {
                        response = responses['default'];
                        defaultResponseCode = 'default';
                    }

                    if (response && response.schema) {
                        var resolvedModel = this.resolveModel(response.schema, definitions);
                        var successResponse;

                        delete responses[defaultResponseCode];

                        if (resolvedModel) {
                            this.successResponse = {};
                            successResponse = this.successResponse[defaultResponseCode] = resolvedModel;
                        } else if (!response.schema.type || response.schema.type === 'object' || response.schema.type === 'array') {
                            // Inline model
                            this.successResponse = {};
                            successResponse = this.successResponse[defaultResponseCode] = new Model(undefined, response.schema || {}, this.models, parent.modelPropertyMacro);
                        } else {
                            // Primitive
                            this.successResponse = {};
                            successResponse = this.successResponse[defaultResponseCode] = response.schema;
                        }

                        if (successResponse) {
                            // Attach response properties
                            if (response.description) {
                                successResponse.description = response.description;
                            }

                            if (response.examples) {
                                successResponse.examples = response.examples;
                            }

                            if (response.headers) {
                                successResponse.headers = response.headers;
                            }
                        }

                        this.type = response;
                    }

                    if (errors.length > 0) {
                        if (this.resource && this.resource.api && this.resource.api.fail) {
                            this.resource.api.fail(errors);
                        }
                    }

                    return this;
                };

                Operation.prototype.isDefaultArrayItemValue = function (value, param) {
                    if (param.default && Array.isArray(param.default)) {
                        return param.default.indexOf(value) !== -1;
                    }

                    return value === param.default;
                };

                Operation.prototype.getType = function (param) {
                    var type = param.type;
                    var format = param.format;
                    var isArray = false;
                    var str;

                    if (type === 'integer' && format === 'int32') {
                        str = 'integer';
                    } else if (type === 'integer' && format === 'int64') {
                        str = 'long';
                    } else if (type === 'integer') {
                        str = 'integer';
                    } else if (type === 'string') {
                        if (format === 'date-time') {
                            str = 'date-time';
                        } else if (format === 'date') {
                            str = 'date';
                        } else {
                            str = 'string';
                        }
                    } else if (type === 'number' && format === 'float') {
                        str = 'float';
                    } else if (type === 'number' && format === 'double') {
                        str = 'double';
                    } else if (type === 'number') {
                        str = 'double';
                    } else if (type === 'boolean') {
                        str = 'boolean';
                    } else if (type === 'array') {
                        isArray = true;

                        if (param.items) {
                            str = this.getType(param.items);
                        }
                    }

                    if (param.$ref) {
                        str = helpers.simpleRef(param.$ref);
                    }

                    var schema = param.schema;

                    if (schema) {
                        var ref = schema.$ref;

                        if (ref) {
                            ref = helpers.simpleRef(ref);

                            if (isArray) {
                                return [ref];
                            }

                            return ref;

                        }
                        // If inline schema, we add it our interal hash -> which gives us it's ID (int)
                        if (schema.type === 'object') {
                            return this.addInlineModel(schema);
                        }

                        return this.getType(schema);

                    }

                    if (isArray) {
                        return [str];
                    }

                    return str;

                };

                /**
                 * adds an inline schema (model) to a hash, where we can ref it later
                 * @param {object} schema a schema
                 * @return {number} the ID of the schema being added, or null
                 **/
                Operation.prototype.addInlineModel = function (schema) {
                    var len = this.inlineModels.length;
                    var model = this.resolveModel(schema, {});

                    if (model) {
                        this.inlineModels.push(model);

                        return 'Inline Model ' + len; // return string ref of the inline model (used with #getInlineModel)
                    }

                    return null; // report errors?
                };

                /**
                 * gets the internal ref to an inline model
                 * @param {string} inline_str a string reference to an inline model
                 * @return {Model} the model being referenced. Or null
                 **/
                Operation.prototype.getInlineModel = function (inlineStr) {
                    if (/^Inline Model \d+$/.test(inlineStr)) {
                        var id = parseInt(inlineStr.substr('Inline Model'.length).trim(), 10); //
                        var model = this.inlineModels[id];

                        return model;
                    }
                    // I'm returning null here, should I rather throw an error?
                    return null;
                };

                Operation.prototype.resolveModel = function (schema, definitions) {
                    if (typeof schema.$ref !== 'undefined') {
                        var ref = schema.$ref;

                        if (ref.indexOf('#/definitions/') === 0) {
                            ref = ref.substring('#/definitions/'.length);
                        }

                        if (definitions[ref]) {
                            return new Model(ref, definitions[ref], this.models, this.parent.modelPropertyMacro);
                        }
                        // schema must at least be an object to get resolved to an inline Model
                    } else if (schema && typeof schema === 'object' &&
                        (schema.type === 'object' || _.isUndefined(schema.type))) {
                        return new Model(undefined, schema, this.models, this.parent.modelPropertyMacro);
                    }

                    return null;
                };

                Operation.prototype.help = function (dontPrint) {
                    var out = this.nickname + ': ' + this.summary + '\n';

                    for (var i = 0; i < this.parameters.length; i++) {
                        var param = this.parameters[i];
                        var typeInfo = param.signature;

                        out += '\n  * ' + param.name + ' (' + typeInfo + '): ' + param.description;
                    }

                    if (typeof dontPrint === 'undefined') {
                        helpers.log(out);
                    }

                    return out;
                };

                Operation.prototype.getModelSignature = function (type, definitions) {
                    var isPrimitive, listType;

                    if (type instanceof Array) {
                        listType = true;
                        type = type[0];
                    }

                    // Convert undefined to string of 'undefined'
                    if (typeof type === 'undefined') {
                        type = 'undefined';
                        isPrimitive = true;

                    } else if (definitions[type]) {
                        // a model def exists?
                        type = definitions[type]; /* Model */
                        isPrimitive = false;

                    } else if (this.getInlineModel(type)) {
                        type = this.getInlineModel(type); /* Model */
                        isPrimitive = false;

                    } else {
                        // We default to primitive
                        isPrimitive = true;
                    }

                    if (isPrimitive) {
                        if (listType) {
                            return 'Array[' + type + ']';
                        }

                        return type.toString();

                    }

                    if (listType) {
                        return 'Array[' + type.getMockSignature() + ']';
                    }

                    return type.getMockSignature();

                };

                Operation.prototype.supportHeaderParams = function () {
                    return true;
                };

                Operation.prototype.supportedSubmitMethods = function () {
                    return this.parent.supportedSubmitMethods;
                };

                Operation.prototype.getHeaderParams = function (args) {
                    var headers = this.setContentTypes(args, {});

                    for (var i = 0; i < this.parameters.length; i++) {
                        var param = this.parameters[i];

                        if (typeof args[param.name] !== 'undefined') {
                            if (param.in === 'header') {
                                var value = args[param.name];

                                if (Array.isArray(value)) {
                                    value = value.toString();
                                }

                                headers[param.name] = value;
                            }
                        }
                    }

                    return headers;
                };

                Operation.prototype.urlify = function (args) {
                    var formParams = {};
                    var requestUrl = this.path;
                    var querystring = ''; // grab params from the args, build the querystring along the way

                    for (var i = 0; i < this.parameters.length; i++) {
                        var param = this.parameters[i];

                        if (typeof args[param.name] !== 'undefined') {
                            if (param.in === 'path') {
                                var reg = new RegExp('\{' + param.name + '\}', 'gi');
                                var value = args[param.name];

                                if (Array.isArray(value)) {
                                    value = this.encodePathCollection(param.collectionFormat, param.name, value);
                                } else {
                                    value = this.encodePathParam(value);
                                }

                                requestUrl = requestUrl.replace(reg, value);
                            } else if (param.in === 'query' && typeof args[param.name] !== 'undefined') {
                                if (querystring === '') {
                                    querystring += '?';
                                } else {
                                    querystring += '&';
                                }

                                if (typeof param.collectionFormat !== 'undefined') {
                                    var qp = args[param.name];

                                    if (Array.isArray(qp)) {
                                        querystring += this.encodeQueryCollection(param.collectionFormat, param.name, qp);
                                    } else {
                                        querystring += this.encodeQueryParam(param.name) + '=' + this.encodeQueryParam(args[param.name]);
                                    }
                                } else {
                                    querystring += this.encodeQueryParam(param.name) + '=' + this.encodeQueryParam(args[param.name]);
                                }
                            } else if (param.in === 'formData') {
                                formParams[param.name] = args[param.name];
                            }
                        }
                    }
                    var url = this.scheme + '://' + this.host;

                    if (this.basePath !== '/') {
                        url += this.basePath;
                    }

                    return url + requestUrl + querystring;
                };

                Operation.prototype.getMissingParams = function (args) {
                    var missingParams = []; // check required params, track the ones that are missing
                    var i;

                    for (i = 0; i < this.parameters.length; i++) {
                        var param = this.parameters[i];

                        if (param.required === true) {
                            if (typeof args[param.name] === 'undefined') {
                                missingParams = param.name;
                            }
                        }
                    }

                    return missingParams;
                };

                Operation.prototype.getBody = function (headers, args, opts) {
                    var formParams = {},
 body, key, value, hasBody = false;

                    for (var i = 0; i < this.parameters.length; i++) {
                        var param = this.parameters[i];

                        if (typeof args[param.name] !== 'undefined') {
                            if (param.in === 'body') {
                                body = args[param.name];
                            } else if (param.in === 'formData') {
                                formParams[param.name] = args[param.name];
                            }
                        } else if (param.in === 'body') {
                            hasBody = true;
                        }
                    }

                    // if body is null and hasBody is true, AND a JSON body is requested, send empty {}
                    if (hasBody && typeof body === 'undefined') {
                        var contentType = headers['Content-Type'];

                        if (contentType && contentType.indexOf('application/json') === 0) {
                            body = '{}';
                        }
                    }

                    // handle form params
                    if (headers['Content-Type'] === 'application/x-www-form-urlencoded') {
                        var encoded = '';

                        for (key in formParams) {
                            value = formParams[key];

                            if (typeof value !== 'undefined') {
                                if (encoded !== '') {
                                    encoded += '&';
                                }

                                encoded += encodeURIComponent(key) + '=' + encodeURIComponent(value);
                            }
                        }

                        body = encoded;
                    } else if (headers['Content-Type'] && headers['Content-Type'].indexOf('multipart/form-data') >= 0) {
                        if (opts.useJQuery) {
                            var bodyParam = new FormData();

                            bodyParam.type = 'formData';

                            for (key in formParams) {
                                value = args[key];

                                if (typeof value !== 'undefined') {
                                    // required for jquery file upload
                                    if (value.type === 'file' && value.value) {
                                        delete headers['Content-Type'];

                                        bodyParam.append(key, value.value);
                                    } else {
                                        bodyParam.append(key, value);
                                    }
                                }
                            }

                            body = bodyParam;
                        }
                    }

                    return body;
                };

                /**
                 * gets sample response for a single operation
                 **/
                Operation.prototype.getModelSampleJSON = function (type, models) {
                    var listType, sampleJson, innerType;

                    models = models || {};

                    listType = type instanceof Array;
                    innerType = listType ? type[0] : type;

                    if (models[innerType]) {
                        sampleJson = models[innerType].createJSONSample();
                    } else if (this.getInlineModel(innerType)) {
                        sampleJson = this.getInlineModel(innerType).createJSONSample(); // may return null, if type isn't correct
                    }

                    if (sampleJson) {
                        sampleJson = listType ? [sampleJson] : sampleJson;

                        if (typeof sampleJson === 'string') {
                            return sampleJson;
                        } else if (_.isObject(sampleJson)) {
                            var t = sampleJson;

                            if (sampleJson instanceof Array && sampleJson.length > 0) {
                                t = sampleJson[0];
                            }

                            if (t.nodeName) {
                                var xmlString = new XMLSerializer().serializeToString(t);

                                return this.formatXml(xmlString);
                            }

                            return JSON.stringify(sampleJson, null, 2);

                        }

                        return sampleJson;

                    }
                };

                /**
                 * legacy binding
                 **/
                Operation.prototype.do = function (args, opts, callback, error, parent) {
                    return this.execute(args, opts, callback, error, parent);
                };

                /**
                 * executes an operation
                 **/
                Operation.prototype.execute = function (arg1, arg2, arg3, arg4, parent) {
                    var args = arg1 || {};
                    var opts = {},
 success, error;

                    if (_.isObject(arg2)) {
                        opts = arg2;
                        success = arg3;
                        error = arg4;
                    }

                    if (this.client) {
                        opts.client = this.client;
                    }

                    if (this.responseInterceptor) {
                        opts.responseInterceptor = this.responseInterceptor;
                    }

                    if (typeof arg2 === 'function') {
                        success = arg2;
                        error = arg3;
                    }

                    success = success || this.parent.defaultSuccessCallback || helpers.log;
                    error = error || this.parent.defaultErrorCallback || helpers.log;

                    if (typeof opts.useJQuery === 'undefined') {
                        opts.useJQuery = this.useJQuery;
                    }
                    var missingParams = this.getMissingParams(args);

                    if (missingParams.length > 0) {
                        var message = 'missing required params: ' + missingParams;

                        helpers.fail(message);
                        error(message);

                        return;
                    }

                    var allHeaders = this.getHeaderParams(args);
                    var contentTypeHeaders = this.setContentTypes(args, opts);
                    var headers = {},
 attrname;

                    for (attrname in allHeaders) {
                        headers[attrname] = allHeaders[attrname];
                    }

                    for (attrname in contentTypeHeaders) {
                        headers[attrname] = contentTypeHeaders[attrname];
                    }

                    var body = this.getBody(contentTypeHeaders, args, opts);
                    var url = this.urlify(args);

                    if (url.indexOf('.{format}') > 0) {
                        if (headers) {
                            var format = headers.Accept || headers.accept;

                            if (format && format.indexOf('json') > 0) {
                                url = url.replace('.{format}', '.json');
                            } else if (format && format.indexOf('xml') > 0) {
                                url = url.replace('.{format}', '.xml');
                            }
                        }
                    }

                    var obj = {
                        url: url,
                        method: this.method.toUpperCase(),
                        body: body,
                        useJQuery: opts.useJQuery,
                        headers: headers,
                        on: {
                            response: function (response) {
                                return success(response, parent);
                            },
                            error: function (response) {
                                return error(response, parent);
                            }
                        }
                    };

                    this.clientAuthorizations.apply(obj, this.operation.security);

                    if (opts.mock === true) {
                        return obj;
                    }
                    new SwaggerHttp().execute(obj, opts);

                };

                function itemByPriority(col, itemPriority) {

                    // No priorities? return first...
                    if (_.isEmpty(itemPriority)) {
                        return col[0];
                    }

                    for (var i = 0, len = itemPriority.length; i < len; i++) {
                        if (col.indexOf(itemPriority[i]) > -1) {
                            return itemPriority[i];
                        }
                    }

                    // Otherwise return first
                    return col[0];
                }

                Operation.prototype.setContentTypes = function (args, opts) {
                    // default type
                    var allDefinedParams = this.parameters;
                    var body;
                    var consumes = args.parameterContentType || itemByPriority(this.consumes, ['application/json', 'application/yaml']);
                    var accepts = opts.responseContentType || itemByPriority(this.produces, ['application/json', 'application/yaml']);
                    var definedFileParams = [];
                    var definedFormParams = [];
                    var headers = {};
                    var i;

                    // get params from the operation and set them in definedFileParams, definedFormParams, headers
                    for (i = 0; i < allDefinedParams.length; i++) {
                        var param = allDefinedParams[i];

                        if (param.in === 'formData') {
                            if (param.type === 'file') {
                                definedFileParams.push(param);
                            } else {
                                definedFormParams.push(param);
                            }
                        } else if (param.in === 'header' && opts) {
                            var key = param.name;
                            var headerValue = opts[param.name];

                            if (typeof opts[param.name] !== 'undefined') {
                                headers[key] = headerValue;
                            }
                        } else if (param.in === 'body' && typeof args[param.name] !== 'undefined') {
                            body = args[param.name];
                        }
                    }

                    // if there's a body, need to set the consumes header via requestContentType
                    if (this.method === 'post' || this.method === 'put' || this.method === 'patch' ||
                        this.method === 'delete' && body) {
                        if (opts.requestContentType) {
                            consumes = opts.requestContentType;
                        }
                        // if any form params, content type must be set
                        if (definedFormParams.length > 0) {
                            if (opts.requestContentType) {             // override if set
                                consumes = opts.requestContentType;
                            } else if (definedFileParams.length > 0) { // if a file, must be multipart/form-data
                                consumes = 'multipart/form-data';
                            } else {                                   // default to x-www-from-urlencoded
                                consumes = 'application/x-www-form-urlencoded';
                            }
                        }
                    } else {
                        consumes = null;
                    }

                    if (consumes && this.consumes) {
                        if (this.consumes.indexOf(consumes) === -1) {
                            helpers.log('server doesn\'t consume ' + consumes + ', try ' + JSON.stringify(this.consumes));
                        }
                    }

                    if (!this.matchesAccept(accepts)) {
                        helpers.log('server can\'t produce ' + accepts);
                    }

                    if (consumes && body !== '' || consumes === 'application/x-www-form-urlencoded') {
                        headers['Content-Type'] = consumes;
                    }

                    if (accepts) {
                        headers.Accept = accepts;
                    }

                    return headers;
                };

                /**
                 * Returns true if the request accepts header matches anything in this.produces.
                 *  If this.produces contains * / *, ignore the accept header.
                 * @param {string=} accepts The client request accept header.
                 * @return {boolean}
                 */
                Operation.prototype.matchesAccept = function (accepts) {
                    // no accepts or produces, no problem!
                    if (!accepts || !this.produces) {
                        return true;
                    }

                    return this.produces.indexOf(accepts) !== -1 || this.produces.indexOf('*/*') !== -1;
                };

                Operation.prototype.asCurl = function (args1, args2) {
                    var opts = {
                        mock: true
                    };

                    if (typeof args2 === 'object') {
                        for (var argKey in args2) {
                            opts[argKey] = args2[argKey];
                        }
                    }
                    var obj = this.execute(args1, opts);

                    this.clientAuthorizations.apply(obj);

                    var results = [];

                    results.push('-X ' + this.method.toUpperCase());

                    if (obj.headers) {
                        var key;

                        for (key in obj.headers) {
                            results.push('--header "' + key + ': ' + obj.headers[key] + '"');
                        }
                    }

                    if (obj.body) {
                        var body;

                        if (_.isObject(obj.body)) {
                            body = JSON.stringify(obj.body);
                        } else {
                            body = obj.body;
                        }

                        results.push('-d "' + body.replace(/"/g, '\\"') + '"');
                    }

                    return 'curl ' + results.join(' ') + ' "' + obj.url + '"';
                };

                Operation.prototype.encodePathCollection = function (type, name, value) {
                    var encoded = '';
                    var i;
                    var separator = '';

                    if (type === 'ssv') {
                        separator = '%20';
                    } else if (type === 'tsv') {
                        separator = '\\t';
                    } else if (type === 'pipes') {
                        separator = '|';
                    } else {
                        separator = ',';
                    }

                    for (i = 0; i < value.length; i++) {
                        if (i === 0) {
                            encoded = this.encodeQueryParam(value[i]);
                        } else {
                            encoded += separator + this.encodeQueryParam(value[i]);
                        }
                    }

                    return encoded;
                };

                Operation.prototype.encodeQueryCollection = function (type, name, value) {
                    var encoded = '';
                    var i;

                    if (type === 'default' || type === 'multi') {
                        for (i = 0; i < value.length; i++) {
                            if (i > 0) {
                                encoded += '&';
                            }

                            encoded += this.encodeQueryParam(name) + '=' + this.encodeQueryParam(value[i]);
                        }
                    } else {
                        var separator = '';

                        if (type === 'csv') {
                            separator = ',';
                        } else if (type === 'ssv') {
                            separator = '%20';
                        } else if (type === 'tsv') {
                            separator = '\\t';
                        } else if (type === 'pipes') {
                            separator = '|';
                        } else if (type === 'brackets') {
                            for (i = 0; i < value.length; i++) {
                                if (i !== 0) {
                                    encoded += '&';
                                }

                                encoded += this.encodeQueryParam(name) + '[]=' + this.encodeQueryParam(value[i]);
                            }
                        }

                        if (separator !== '') {
                            for (i = 0; i < value.length; i++) {
                                if (i === 0) {
                                    encoded = this.encodeQueryParam(name) + '=' + this.encodeQueryParam(value[i]);
                                } else {
                                    encoded += separator + this.encodeQueryParam(value[i]);
                                }
                            }
                        }
                    }

                    return encoded;
                };

                Operation.prototype.encodeQueryParam = function (arg) {
                    return encodeURIComponent(arg);
                };

                /**
                 * TODO revisit, might not want to leave '/'
                 **/
                Operation.prototype.encodePathParam = function (pathParam) {
                    return encodeURIComponent(pathParam);
                };

            },{
                '../helpers': 4,'../http': 5,'./model': 9,'lodash-compat/lang/cloneDeep': 141,'lodash-compat/lang/isEmpty': 144,'lodash-compat/lang/isObject': 147,'lodash-compat/lang/isUndefined': 151
            }],11: [function (require, module, exports) {
                'use strict';

                var OperationGroup = module.exports = function (tag, description, externalDocs, operation) {
                    this.description = description;
                    this.externalDocs = externalDocs;
                    this.name = tag;
                    this.operation = operation;
                    this.operationsArray = [];
                    this.path = tag;
                    this.tag = tag;
                };

                OperationGroup.prototype.sort = function () {

                };

            },{}],12: [function (require, module, exports) {

            },{}],13: [function (require, module, exports) {
                /*!
                 * The buffer module from node.js, for the browser.
                 *
                 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
                 * @license  MIT
                 */

                var base64 = require('base64-js');
                var ieee754 = require('ieee754');
                var isArray = require('is-array');

                exports.Buffer = Buffer;
                exports.SlowBuffer = SlowBuffer;
                exports.INSPECT_MAX_BYTES = 50;
                Buffer.poolSize = 8192; // not used by this implementation

                var rootParent = {};

                /**
                 * If `Buffer.TYPED_ARRAY_SUPPORT`:
                 *   === true    Use Uint8Array implementation (fastest)
                 *   === false   Use Object implementation (most compatible, even IE6)
                 *
                 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
                 * Opera 11.6+, iOS 4.2+.
                 *
                 * Note:
                 *
                 * - Implementation must support adding new properties to `Uint8Array` instances.
                 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
                 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
                 *
                 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
                 *
                 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
                 *    incorrect length in some situations.
                 *
                 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
                 * get the Object implementation, which is slower but will work correctly.
                 */
                Buffer.TYPED_ARRAY_SUPPORT = (function () {
                    function Foo() {}

                    try {
                        var buf = new ArrayBuffer(0);
                        var arr = new Uint8Array(buf);

                        arr.foo = function () {
                            return 42;
                        };
                        arr.constructor = Foo;

                        return arr.foo() === 42 && // typed array instances can be augmented
                            arr.constructor === Foo && // constructor can be set
                            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                            new Uint8Array(1).subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
                    } catch (e) {
                        return false;
                    }
                })();

                function kMaxLength() {
                    return Buffer.TYPED_ARRAY_SUPPORT ?
                        0x7fffffff
                        : 0x3fffffff;
                }

                /**
                 * Class: Buffer
                 * =============
                 *
                 * The Buffer constructor returns instances of `Uint8Array` that are augmented
                 * with function properties for all the node `Buffer` API functions. We use
                 * `Uint8Array` so that square bracket notation works as expected -- it returns
                 * a single octet.
                 *
                 * By augmenting the instances, we can avoid modifying the `Uint8Array`
                 * prototype.
                 */
                function Buffer(arg) {
                    if (!(this instanceof Buffer)) {
                        // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
                        if (arguments.length > 1) return new Buffer(arg, arguments[1]);

                        return new Buffer(arg);
                    }

                    this.length = 0;
                    this.parent = undefined;

                    // Common case.
                    if (typeof arg === 'number') {
                        return fromNumber(this, arg);
                    }

                    // Slightly less common case.
                    if (typeof arg === 'string') {
                        return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
                    }

                    // Unusual.
                    return fromObject(this, arg);
                }

                function fromNumber(that, length) {
                    that = allocate(that, length < 0 ? 0 : checked(length) | 0);

                    if (!Buffer.TYPED_ARRAY_SUPPORT) {
                        for (var i = 0; i < length; i++) {
                            that[i] = 0;
                        }
                    }

                    return that;
                }

                function fromString(that, string, encoding) {
                    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';

                    // Assumption: byteLength() return value is always < kMaxLength.
                    var length = byteLength(string, encoding) | 0;

                    that = allocate(that, length);

                    that.write(string, encoding);

                    return that;
                }

                function fromObject(that, object) {
                    if (Buffer.isBuffer(object)) return fromBuffer(that, object);

                    if (isArray(object)) return fromArray(that, object);

                    if (object == null) {
                        throw new TypeError('must start with number, buffer, array or string');
                    }

                    if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
                        return fromTypedArray(that, object);
                    }

                    if (object.length) return fromArrayLike(that, object);

                    return fromJsonObject(that, object);
                }

                function fromBuffer(that, buffer) {
                    var length = checked(buffer.length) | 0;

                    that = allocate(that, length);
                    buffer.copy(that, 0, 0, length);

                    return that;
                }

                function fromArray(that, array) {
                    var length = checked(array.length) | 0;

                    that = allocate(that, length);

                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }

                    return that;
                }

                // Duplicate of fromArray() to keep fromArray() monomorphic.
                function fromTypedArray(that, array) {
                    var length = checked(array.length) | 0;

                    that = allocate(that, length);
                    // Truncating the elements is probably not what people expect from typed
                    // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
                    // of the old Buffer constructor.
                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }

                    return that;
                }

                function fromArrayLike(that, array) {
                    var length = checked(array.length) | 0;

                    that = allocate(that, length);

                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }

                    return that;
                }

                // Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
                // Returns a zero-length buffer for inputs that don't conform to the spec.
                function fromJsonObject(that, object) {
                    var array;
                    var length = 0;

                    if (object.type === 'Buffer' && isArray(object.data)) {
                        array = object.data;
                        length = checked(array.length) | 0;
                    }
                    that = allocate(that, length);

                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }

                    return that;
                }

                function allocate(that, length) {
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        // Return an augmented `Uint8Array` instance, for best performance
                        that = Buffer._augment(new Uint8Array(length));
                    } else {
                        // Fallback: Return an object instance of the Buffer class
                        that.length = length;
                        that._isBuffer = true;
                    }

                    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;

                    if (fromPool) that.parent = rootParent;

                    return that;
                }

                function checked(length) {
                    // Note: cannot use `length < kMaxLength` here because that fails when
                    // length is NaN (which is otherwise coerced to zero.)
                    if (length >= kMaxLength()) {
                        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                        'size: 0x' + kMaxLength().toString(16) + ' bytes');
                    }

                    return length | 0;
                }

                function SlowBuffer(subject, encoding) {
                    if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);

                    var buf = new Buffer(subject, encoding);

                    delete buf.parent;

                    return buf;
                }

                Buffer.isBuffer = function isBuffer(b) {
                    return !!(b != null && b._isBuffer);
                };

                Buffer.compare = function compare(a, b) {
                    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                        throw new TypeError('Arguments must be Buffers');
                    }

                    if (a === b) return 0;

                    var x = a.length;
                    var y = b.length;

                    var i = 0;
                    var len = Math.min(x, y);

                    while (i < len) {
                        if (a[i] !== b[i]) break;

                        ++i;
                    }

                    if (i !== len) {
                        x = a[i];
                        y = b[i];
                    }

                    if (x < y) return -1;

                    if (y < x) return 1;

                    return 0;
                };

                Buffer.isEncoding = function isEncoding(encoding) {
                    switch (String(encoding).toLowerCase()) {
                        case 'hex':
                        case 'utf8':
                        case 'utf-8':
                        case 'ascii':
                        case 'binary':
                        case 'base64':
                        case 'raw':
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return true;
                        default:
                            return false;
                    }
                };

                Buffer.concat = function concat(list, length) {
                    if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.');

                    if (list.length === 0) {
                        return new Buffer(0);
                    } else if (list.length === 1) {
                        return list[0];
                    }

                    var i;

                    if (length === undefined) {
                        length = 0;

                        for (i = 0; i < list.length; i++) {
                            length += list[i].length;
                        }
                    }

                    var buf = new Buffer(length);
                    var pos = 0;

                    for (i = 0; i < list.length; i++) {
                        var item = list[i];

                        item.copy(buf, pos);
                        pos += item.length;
                    }

                    return buf;
                };

                function byteLength(string, encoding) {
                    if (typeof string !== 'string') string = '' + string;

                    var len = string.length;

                    if (len === 0) return 0;

                    // Use a for loop to avoid recursion
                    var loweredCase = false;

                    for (;;) {
                        switch (encoding) {
                            case 'ascii':
                            case 'binary':
                            // Deprecated
                            case 'raw':
                            case 'raws':
                                return len;

                            case 'utf8':
                            case 'utf-8':
                                return utf8ToBytes(string).length;

                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return len * 2;

                            case 'hex':
                                return len >>> 1;

                            case 'base64':
                                return base64ToBytes(string).length;
                            default:
                                if (loweredCase) return utf8ToBytes(string).length; // assume utf8
                                encoding = ('' + encoding).toLowerCase();
                                loweredCase = true;
                        }
                    }
                }
                Buffer.byteLength = byteLength;

                // pre-set for values that may exist in the future
                Buffer.prototype.length = undefined;
                Buffer.prototype.parent = undefined;

                function slowToString(encoding, start, end) {
                    var loweredCase = false;

                    start |= 0;
                    end = end === undefined || end === Infinity ? this.length : end | 0;

                    if (!encoding) encoding = 'utf8';

                    if (start < 0) start = 0;

                    if (end > this.length) end = this.length;

                    if (end <= start) return '';

                    while (true) {
                        switch (encoding) {
                            case 'hex':
                                return hexSlice(this, start, end);

                            case 'utf8':
                            case 'utf-8':
                                return utf8Slice(this, start, end);

                            case 'ascii':
                                return asciiSlice(this, start, end);

                            case 'binary':
                                return binarySlice(this, start, end);

                            case 'base64':
                                return base64Slice(this, start, end);

                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return utf16leSlice(this, start, end);

                            default:
                                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                                encoding = (encoding + '').toLowerCase();
                                loweredCase = true;
                        }
                    }
                }

                Buffer.prototype.toString = function toString() {
                    var length = this.length | 0;

                    if (length === 0) return '';

                    if (arguments.length === 0) return utf8Slice(this, 0, length);

                    return slowToString.apply(this, arguments);
                };

                Buffer.prototype.equals = function equals(b) {
                    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');

                    if (this === b) return true;

                    return Buffer.compare(this, b) === 0;
                };

                Buffer.prototype.inspect = function inspect() {
                    var str = '';
                    var max = exports.INSPECT_MAX_BYTES;

                    if (this.length > 0) {
                        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');

                        if (this.length > max) str += ' ... ';
                    }

                    return '<Buffer ' + str + '>';
                };

                Buffer.prototype.compare = function compare(b) {
                    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');

                    if (this === b) return 0;

                    return Buffer.compare(this, b);
                };

                Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
                    if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
                    else if (byteOffset < -0x80000000) byteOffset = -0x80000000;
                    byteOffset >>= 0;

                    if (this.length === 0) return -1;

                    if (byteOffset >= this.length) return -1;

                    // Negative offsets start from the end of the buffer
                    if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);

                    if (typeof val === 'string') {
                        if (val.length === 0) return -1; // special case: looking for empty string always fails
                        return String.prototype.indexOf.call(this, val, byteOffset);
                    }

                    if (Buffer.isBuffer(val)) {
                        return arrayIndexOf(this, val, byteOffset);
                    }

                    if (typeof val === 'number') {
                        if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                            return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
                        }

                        return arrayIndexOf(this, [val], byteOffset);
                    }

                    function arrayIndexOf(arr, val, byteOffset) {
                        var foundIndex = -1;

                        for (var i = 0; byteOffset + i < arr.length; i++) {
                            if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                                if (foundIndex === -1) foundIndex = i;

                                if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex;
                            } else {
                                foundIndex = -1;
                            }
                        }

                        return -1;
                    }

                    throw new TypeError('val must be string, number or Buffer');
                };

                // `get` will be removed in Node 0.13+
                Buffer.prototype.get = function get(offset) {
                    console.log('.get() is deprecated. Access using array indexes instead.');

                    return this.readUInt8(offset);
                };

                // `set` will be removed in Node 0.13+
                Buffer.prototype.set = function set(v, offset) {
                    console.log('.set() is deprecated. Access using array indexes instead.');

                    return this.writeUInt8(v, offset);
                };

                function hexWrite(buf, string, offset, length) {
                    offset = Number(offset) || 0;
                    var remaining = buf.length - offset;

                    if (!length) {
                        length = remaining;
                    } else {
                        length = Number(length);

                        if (length > remaining) {
                            length = remaining;
                        }
                    }

                    // must be an even number of digits
                    var strLen = string.length;

                    if (strLen % 2 !== 0) throw new Error('Invalid hex string');

                    if (length > strLen / 2) {
                        length = strLen / 2;
                    }

                    for (var i = 0; i < length; i++) {
                        var parsed = parseInt(string.substr(i * 2, 2), 16);

                        if (isNaN(parsed)) throw new Error('Invalid hex string');
                        buf[offset + i] = parsed;
                    }

                    return i;
                }

                function utf8Write(buf, string, offset, length) {
                    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }

                function asciiWrite(buf, string, offset, length) {
                    return blitBuffer(asciiToBytes(string), buf, offset, length);
                }

                function binaryWrite(buf, string, offset, length) {
                    return asciiWrite(buf, string, offset, length);
                }

                function base64Write(buf, string, offset, length) {
                    return blitBuffer(base64ToBytes(string), buf, offset, length);
                }

                function ucs2Write(buf, string, offset, length) {
                    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                }

                Buffer.prototype.write = function write(string, offset, length, encoding) {
                    // Buffer#write(string)
                    if (offset === undefined) {
                        encoding = 'utf8';
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, encoding)
                    } else if (length === undefined && typeof offset === 'string') {
                        encoding = offset;
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, offset[, length][, encoding])
                    } else if (isFinite(offset)) {
                        offset |= 0;

                        if (isFinite(length)) {
                            length |= 0;

                            if (encoding === undefined) encoding = 'utf8';
                        } else {
                            encoding = length;
                            length = undefined;
                        }
                        // legacy write(string, encoding, offset, length) - remove in v0.13
                    } else {
                        var swap = encoding;

                        encoding = offset;
                        offset = length | 0;
                        length = swap;
                    }

                    var remaining = this.length - offset;

                    if (length === undefined || length > remaining) length = remaining;

                    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                        throw new RangeError('attempt to write outside buffer bounds');
                    }

                    if (!encoding) encoding = 'utf8';

                    var loweredCase = false;

                    for (;;) {
                        switch (encoding) {
                            case 'hex':
                                return hexWrite(this, string, offset, length);

                            case 'utf8':
                            case 'utf-8':
                                return utf8Write(this, string, offset, length);

                            case 'ascii':
                                return asciiWrite(this, string, offset, length);

                            case 'binary':
                                return binaryWrite(this, string, offset, length);

                            case 'base64':
                                // Warning: maxLength not taken into account in base64Write
                                return base64Write(this, string, offset, length);

                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return ucs2Write(this, string, offset, length);

                            default:
                                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                                encoding = ('' + encoding).toLowerCase();
                                loweredCase = true;
                        }
                    }
                };

                Buffer.prototype.toJSON = function toJSON() {
                    return {
                        type: 'Buffer',
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    };
                };

                function base64Slice(buf, start, end) {
                    if (start === 0 && end === buf.length) {
                        return base64.fromByteArray(buf);
                    }

                    return base64.fromByteArray(buf.slice(start, end));

                }

                function utf8Slice(buf, start, end) {
                    var res = '';
                    var tmp = '';

                    end = Math.min(buf.length, end);

                    for (var i = start; i < end; i++) {
                        if (buf[i] <= 0x7F) {
                            res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
                            tmp = '';
                        } else {
                            tmp += '%' + buf[i].toString(16);
                        }
                    }

                    return res + decodeUtf8Char(tmp);
                }

                function asciiSlice(buf, start, end) {
                    var ret = '';

                    end = Math.min(buf.length, end);

                    for (var i = start; i < end; i++) {
                        ret += String.fromCharCode(buf[i] & 0x7F);
                    }

                    return ret;
                }

                function binarySlice(buf, start, end) {
                    var ret = '';

                    end = Math.min(buf.length, end);

                    for (var i = start; i < end; i++) {
                        ret += String.fromCharCode(buf[i]);
                    }

                    return ret;
                }

                function hexSlice(buf, start, end) {
                    var len = buf.length;

                    if (!start || start < 0) start = 0;

                    if (!end || end < 0 || end > len) end = len;

                    var out = '';

                    for (var i = start; i < end; i++) {
                        out += toHex(buf[i]);
                    }

                    return out;
                }

                function utf16leSlice(buf, start, end) {
                    var bytes = buf.slice(start, end);
                    var res = '';

                    for (var i = 0; i < bytes.length; i += 2) {
                        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                    }

                    return res;
                }

                Buffer.prototype.slice = function slice(start, end) {
                    var len = this.length;

                    start = ~~start;
                    end = end === undefined ? len : ~~end;

                    if (start < 0) {
                        start += len;

                        if (start < 0) start = 0;
                    } else if (start > len) {
                        start = len;
                    }

                    if (end < 0) {
                        end += len;

                        if (end < 0) end = 0;
                    } else if (end > len) {
                        end = len;
                    }

                    if (end < start) end = start;

                    var newBuf;

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        newBuf = Buffer._augment(this.subarray(start, end));
                    } else {
                        var sliceLen = end - start;

                        newBuf = new Buffer(sliceLen, undefined);

                        for (var i = 0; i < sliceLen; i++) {
                            newBuf[i] = this[i + start];
                        }
                    }

                    if (newBuf.length) newBuf.parent = this.parent || this;

                    return newBuf;
                };

                /*
                 * Need to make sure that buffer isn't trying to write out of bounds.
                 */
                function checkOffset(offset, ext, length) {
                    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');

                    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
                }

                Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                    offset |= 0;
                    byteLength |= 0;

                    if (!noAssert) checkOffset(offset, byteLength, this.length);

                    var val = this[offset];
                    var mul = 1;
                    var i = 0;

                    while (++i < byteLength && (mul *= 0x100)) {
                        val += this[offset + i] * mul;
                    }

                    return val;
                };

                Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                    offset |= 0;
                    byteLength |= 0;

                    if (!noAssert) {
                        checkOffset(offset, byteLength, this.length);
                    }

                    var val = this[offset + --byteLength];
                    var mul = 1;

                    while (byteLength > 0 && (mul *= 0x100)) {
                        val += this[offset + --byteLength] * mul;
                    }

                    return val;
                };

                Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 1, this.length);

                    return this[offset];
                };

                Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);

                    return this[offset] | this[offset + 1] << 8;
                };

                Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);

                    return this[offset] << 8 | this[offset + 1];
                };

                Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return (this[offset] |
                        this[offset + 1] << 8 |
                        this[offset + 2] << 16) +
                        this[offset + 3] * 0x1000000;
                };

                Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return this[offset] * 0x1000000 +
                        (this[offset + 1] << 16 |
                        this[offset + 2] << 8 |
                        this[offset + 3]);
                };

                Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                    offset |= 0;
                    byteLength |= 0;

                    if (!noAssert) checkOffset(offset, byteLength, this.length);

                    var val = this[offset];
                    var mul = 1;
                    var i = 0;

                    while (++i < byteLength && (mul *= 0x100)) {
                        val += this[offset + i] * mul;
                    }
                    mul *= 0x80;

                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                    return val;
                };

                Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                    offset |= 0;
                    byteLength |= 0;

                    if (!noAssert) checkOffset(offset, byteLength, this.length);

                    var i = byteLength;
                    var mul = 1;
                    var val = this[offset + --i];

                    while (i > 0 && (mul *= 0x100)) {
                        val += this[offset + --i] * mul;
                    }
                    mul *= 0x80;

                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                    return val;
                };

                Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 1, this.length);

                    if (!(this[offset] & 0x80)) return this[offset];

                    return (0xff - this[offset] + 1) * -1;
                };

                Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    var val = this[offset] | this[offset + 1] << 8;

                    return val & 0x8000 ? val | 0xFFFF0000 : val;
                };

                Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    var val = this[offset + 1] | this[offset] << 8;

                    return val & 0x8000 ? val | 0xFFFF0000 : val;
                };

                Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return this[offset] |
                        this[offset + 1] << 8 |
                        this[offset + 2] << 16 |
                        this[offset + 3] << 24;
                };

                Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return this[offset] << 24 |
                        this[offset + 1] << 16 |
                        this[offset + 2] << 8 |
                        this[offset + 3];
                };

                Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return ieee754.read(this, offset, true, 23, 4);
                };

                Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return ieee754.read(this, offset, false, 23, 4);
                };

                Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 8, this.length);

                    return ieee754.read(this, offset, true, 52, 8);
                };

                Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 8, this.length);

                    return ieee754.read(this, offset, false, 52, 8);
                };

                function checkInt(buf, value, offset, ext, max, min) {
                    if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance');

                    if (value > max || value < min) throw new RangeError('value is out of bounds');

                    if (offset + ext > buf.length) throw new RangeError('index out of range');
                }

                Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset |= 0;
                    byteLength |= 0;

                    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

                    var mul = 1;
                    var i = 0;

                    this[offset] = value & 0xFF;

                    while (++i < byteLength && (mul *= 0x100)) {
                        this[offset + i] = value / mul & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset |= 0;
                    byteLength |= 0;

                    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

                    var i = byteLength - 1;
                    var mul = 1;

                    this[offset + i] = value & 0xFF;

                    while (--i >= 0 && (mul *= 0x100)) {
                        this[offset + i] = value / mul & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);

                    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
                    this[offset] = value;

                    return offset + 1;
                };

                function objectWriteUInt16(buf, value, offset, littleEndian) {
                    if (value < 0) value = 0xffff + value + 1;

                    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>>
                        (littleEndian ? i : 1 - i) * 8;
                    }
                }

                Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value;
                        this[offset + 1] = value >>> 8;
                    } else {
                        objectWriteUInt16(this, value, offset, true);
                    }

                    return offset + 2;
                };

                Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 8;
                        this[offset + 1] = value;
                    } else {
                        objectWriteUInt16(this, value, offset, false);
                    }

                    return offset + 2;
                };

                function objectWriteUInt32(buf, value, offset, littleEndian) {
                    if (value < 0) value = 0xffffffff + value + 1;

                    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
                    }
                }

                Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset + 3] = value >>> 24;
                        this[offset + 2] = value >>> 16;
                        this[offset + 1] = value >>> 8;
                        this[offset] = value;
                    } else {
                        objectWriteUInt32(this, value, offset, true);
                    }

                    return offset + 4;
                };

                Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 24;
                        this[offset + 1] = value >>> 16;
                        this[offset + 2] = value >>> 8;
                        this[offset + 3] = value;
                    } else {
                        objectWriteUInt32(this, value, offset, false);
                    }

                    return offset + 4;
                };

                Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);

                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }

                    var i = 0;
                    var mul = 1;
                    var sub = value < 0 ? 1 : 0;

                    this[offset] = value & 0xFF;

                    while (++i < byteLength && (mul *= 0x100)) {
                        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);

                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }

                    var i = byteLength - 1;
                    var mul = 1;
                    var sub = value < 0 ? 1 : 0;

                    this[offset + i] = value & 0xFF;

                    while (--i >= 0 && (mul *= 0x100)) {
                        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);

                    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);

                    if (value < 0) value = 0xff + value + 1;
                    this[offset] = value;

                    return offset + 1;
                };

                Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value;
                        this[offset + 1] = value >>> 8;
                    } else {
                        objectWriteUInt16(this, value, offset, true);
                    }

                    return offset + 2;
                };

                Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 8;
                        this[offset + 1] = value;
                    } else {
                        objectWriteUInt16(this, value, offset, false);
                    }

                    return offset + 2;
                };

                Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value;
                        this[offset + 1] = value >>> 8;
                        this[offset + 2] = value >>> 16;
                        this[offset + 3] = value >>> 24;
                    } else {
                        objectWriteUInt32(this, value, offset, true);
                    }

                    return offset + 4;
                };

                Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset |= 0;

                    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

                    if (value < 0) value = 0xffffffff + value + 1;

                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 24;
                        this[offset + 1] = value >>> 16;
                        this[offset + 2] = value >>> 8;
                        this[offset + 3] = value;
                    } else {
                        objectWriteUInt32(this, value, offset, false);
                    }

                    return offset + 4;
                };

                function checkIEEE754(buf, value, offset, ext, max, min) {
                    if (value > max || value < min) throw new RangeError('value is out of bounds');

                    if (offset + ext > buf.length) throw new RangeError('index out of range');

                    if (offset < 0) throw new RangeError('index out of range');
                }

                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 23, 4);

                    return offset + 4;
                }

                Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, true, noAssert);
                };

                Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, false, noAssert);
                };

                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 52, 8);

                    return offset + 8;
                }

                Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, true, noAssert);
                };

                Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, false, noAssert);
                };

                // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
                Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                    if (!start) start = 0;

                    if (!end && end !== 0) end = this.length;

                    if (targetStart >= target.length) targetStart = target.length;

                    if (!targetStart) targetStart = 0;

                    if (end > 0 && end < start) end = start;

                    // Copy 0 bytes; we're done
                    if (end === start) return 0;

                    if (target.length === 0 || this.length === 0) return 0;

                    // Fatal error conditions
                    if (targetStart < 0) {
                        throw new RangeError('targetStart out of bounds');
                    }

                    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');

                    if (end < 0) throw new RangeError('sourceEnd out of bounds');

                    // Are we oob?
                    if (end > this.length) end = this.length;

                    if (target.length - targetStart < end - start) {
                        end = target.length - targetStart + start;
                    }

                    var len = end - start;

                    if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                        for (var i = 0; i < len; i++) {
                            target[i + targetStart] = this[i + start];
                        }
                    } else {
                        target._set(this.subarray(start, start + len), targetStart);
                    }

                    return len;
                };

                // fill(value, start=0, end=buffer.length)
                Buffer.prototype.fill = function fill(value, start, end) {
                    if (!value) value = 0;

                    if (!start) start = 0;

                    if (!end) end = this.length;

                    if (end < start) throw new RangeError('end < start');

                    // Fill 0 bytes; we're done
                    if (end === start) return;

                    if (this.length === 0) return;

                    if (start < 0 || start >= this.length) throw new RangeError('start out of bounds');

                    if (end < 0 || end > this.length) throw new RangeError('end out of bounds');

                    var i;

                    if (typeof value === 'number') {
                        for (i = start; i < end; i++) {
                            this[i] = value;
                        }
                    } else {
                        var bytes = utf8ToBytes(value.toString());
                        var len = bytes.length;

                        for (i = start; i < end; i++) {
                            this[i] = bytes[i % len];
                        }
                    }

                    return this;
                };

                /**
                 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
                 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
                 */
                Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
                    if (typeof Uint8Array !== 'undefined') {
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            return (new Buffer(this)).buffer;
                        }
                        var buf = new Uint8Array(this.length);

                        for (var i = 0, len = buf.length; i < len; i += 1) {
                            buf[i] = this[i];
                        }

                        return buf.buffer;

                    }
                    throw new TypeError('Buffer.toArrayBuffer not supported in this browser');

                };

                // HELPER FUNCTIONS
                // ================

                var BP = Buffer.prototype;

                /**
                 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
                 */
                Buffer._augment = function _augment(arr) {
                    arr.constructor = Buffer;
                    arr._isBuffer = true;

                    // save reference to original Uint8Array set method before overwriting
                    arr._set = arr.set;

                    // deprecated, will be removed in node 0.13+
                    arr.get = BP.get;
                    arr.set = BP.set;

                    arr.write = BP.write;
                    arr.toString = BP.toString;
                    arr.toLocaleString = BP.toString;
                    arr.toJSON = BP.toJSON;
                    arr.equals = BP.equals;
                    arr.compare = BP.compare;
                    arr.indexOf = BP.indexOf;
                    arr.copy = BP.copy;
                    arr.slice = BP.slice;
                    arr.readUIntLE = BP.readUIntLE;
                    arr.readUIntBE = BP.readUIntBE;
                    arr.readUInt8 = BP.readUInt8;
                    arr.readUInt16LE = BP.readUInt16LE;
                    arr.readUInt16BE = BP.readUInt16BE;
                    arr.readUInt32LE = BP.readUInt32LE;
                    arr.readUInt32BE = BP.readUInt32BE;
                    arr.readIntLE = BP.readIntLE;
                    arr.readIntBE = BP.readIntBE;
                    arr.readInt8 = BP.readInt8;
                    arr.readInt16LE = BP.readInt16LE;
                    arr.readInt16BE = BP.readInt16BE;
                    arr.readInt32LE = BP.readInt32LE;
                    arr.readInt32BE = BP.readInt32BE;
                    arr.readFloatLE = BP.readFloatLE;
                    arr.readFloatBE = BP.readFloatBE;
                    arr.readDoubleLE = BP.readDoubleLE;
                    arr.readDoubleBE = BP.readDoubleBE;
                    arr.writeUInt8 = BP.writeUInt8;
                    arr.writeUIntLE = BP.writeUIntLE;
                    arr.writeUIntBE = BP.writeUIntBE;
                    arr.writeUInt16LE = BP.writeUInt16LE;
                    arr.writeUInt16BE = BP.writeUInt16BE;
                    arr.writeUInt32LE = BP.writeUInt32LE;
                    arr.writeUInt32BE = BP.writeUInt32BE;
                    arr.writeIntLE = BP.writeIntLE;
                    arr.writeIntBE = BP.writeIntBE;
                    arr.writeInt8 = BP.writeInt8;
                    arr.writeInt16LE = BP.writeInt16LE;
                    arr.writeInt16BE = BP.writeInt16BE;
                    arr.writeInt32LE = BP.writeInt32LE;
                    arr.writeInt32BE = BP.writeInt32BE;
                    arr.writeFloatLE = BP.writeFloatLE;
                    arr.writeFloatBE = BP.writeFloatBE;
                    arr.writeDoubleLE = BP.writeDoubleLE;
                    arr.writeDoubleBE = BP.writeDoubleBE;
                    arr.fill = BP.fill;
                    arr.inspect = BP.inspect;
                    arr.toArrayBuffer = BP.toArrayBuffer;

                    return arr;
                };

                var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g;

                function base64clean(str) {
                    // Node strips out invalid characters like \n and \t from the string, base64-js does not
                    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
                    // Node converts strings with length < 2 to ''
                    if (str.length < 2) return '';
                    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                    while (str.length % 4 !== 0) {
                        str += '=';
                    }

                    return str;
                }

                function stringtrim(str) {
                    if (str.trim) return str.trim();

                    return str.replace(/^\s+|\s+$/g, '');
                }

                function toHex(n) {
                    if (n < 16) return '0' + n.toString(16);

                    return n.toString(16);
                }

                function utf8ToBytes(string, units) {
                    units = units || Infinity;
                    var codePoint;
                    var length = string.length;
                    var leadSurrogate = null;
                    var bytes = [];
                    var i = 0;

                    for (; i < length; i++) {
                        codePoint = string.charCodeAt(i);

                        // is surrogate component
                        if (codePoint > 0xD7FF && codePoint < 0xE000) {
                            // last char was a lead
                            if (leadSurrogate) {
                                // 2 leads in a row
                                if (codePoint < 0xDC00) {
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                    leadSurrogate = codePoint;
                                    continue;
                                } else {
                                    // valid surrogate pair
                                    codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
                                    leadSurrogate = null;
                                }
                            } else {
                                // no lead yet

                                if (codePoint > 0xDBFF) {
                                    // unexpected trail
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                    continue;
                                } else if (i + 1 === length) {
                                    // unpaired lead
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                    continue;
                                } else {
                                    // valid lead
                                    leadSurrogate = codePoint;
                                    continue;
                                }
                            }
                        } else if (leadSurrogate) {
                            // valid bmp char, but last char was a lead
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                            leadSurrogate = null;
                        }

                        // encode utf8
                        if (codePoint < 0x80) {
                            if ((units -= 1) < 0) break;
                            bytes.push(codePoint);
                        } else if (codePoint < 0x800) {
                            if ((units -= 2) < 0) break;
                            bytes.push(
                                codePoint >> 0x6 | 0xC0,
                                codePoint & 0x3F | 0x80
                            );
                        } else if (codePoint < 0x10000) {
                            if ((units -= 3) < 0) break;
                            bytes.push(
                                codePoint >> 0xC | 0xE0,
                                codePoint >> 0x6 & 0x3F | 0x80,
                                codePoint & 0x3F | 0x80
                            );
                        } else if (codePoint < 0x200000) {
                            if ((units -= 4) < 0) break;
                            bytes.push(
                                codePoint >> 0x12 | 0xF0,
                                codePoint >> 0xC & 0x3F | 0x80,
                                codePoint >> 0x6 & 0x3F | 0x80,
                                codePoint & 0x3F | 0x80
                            );
                        } else {
                            throw new Error('Invalid code point');
                        }
                    }

                    return bytes;
                }

                function asciiToBytes(str) {
                    var byteArray = [];

                    for (var i = 0; i < str.length; i++) {
                        // Node's code seems to be doing this and not & 0x7F..
                        byteArray.push(str.charCodeAt(i) & 0xFF);
                    }

                    return byteArray;
                }

                function utf16leToBytes(str, units) {
                    var c, hi, lo;
                    var byteArray = [];

                    for (var i = 0; i < str.length; i++) {
                        if ((units -= 2) < 0) break;

                        c = str.charCodeAt(i);
                        hi = c >> 8;
                        lo = c % 256;
                        byteArray.push(lo);
                        byteArray.push(hi);
                    }

                    return byteArray;
                }

                function base64ToBytes(str) {
                    return base64.toByteArray(base64clean(str));
                }

                function blitBuffer(src, dst, offset, length) {
                    for (var i = 0; i < length; i++) {
                        if (i + offset >= dst.length || i >= src.length) break;
                        dst[i + offset] = src[i];
                    }

                    return i;
                }

                function decodeUtf8Char(str) {
                    try {
                        return decodeURIComponent(str);
                    } catch (err) {
                        return String.fromCharCode(0xFFFD); // UTF 8 invalid char
                    }
                }

            },{
                'base64-js': 14,'ieee754': 15,'is-array': 16
            }],14: [function (require, module, exports) {
                var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

                (function (exports) {
                    'use strict';

                    var Arr = typeof Uint8Array !== 'undefined' ?
                        Uint8Array
                        : Array;

                    var PLUS   = '+'.charCodeAt(0);
                    var SLASH  = '/'.charCodeAt(0);
                    var NUMBER = '0'.charCodeAt(0);
                    var LOWER  = 'a'.charCodeAt(0);
                    var UPPER  = 'A'.charCodeAt(0);
                    var PLUS_URL_SAFE = '-'.charCodeAt(0);
                    var SLASH_URL_SAFE = '_'.charCodeAt(0);

                    function decode(elt) {
                        var code = elt.charCodeAt(0);

                        if (code === PLUS ||
                            code === PLUS_URL_SAFE)
                            return 62; // '+'
                        if (code === SLASH ||
                            code === SLASH_URL_SAFE)
                            return 63; // '/'
                        if (code < NUMBER)
                            return -1; //no match
                        if (code < NUMBER + 10)
                            return code - NUMBER + 26 + 26;

                        if (code < UPPER + 26)
                            return code - UPPER;

                        if (code < LOWER + 26)
                            return code - LOWER + 26;
                    }

                    function b64ToByteArray(b64) {
                        var i, j, l, tmp, placeHolders, arr;

                        if (b64.length % 4 > 0) {
                            throw new Error('Invalid string. Length must be a multiple of 4.');
                        }

                        // the number of equal signs (place holders)
                        // if there are two placeholders, than the two characters before it
                        // represent one byte
                        // if there is only one, then the three characters before it represent 2 bytes
                        // this is just a cheap hack to not do indexOf twice
                        var len = b64.length;

                        placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;

                        // base64 is 4/3 + up to two characters of the original data
                        arr = new Arr(b64.length * 3 / 4 - placeHolders);

                        // if there are placeholders, only get up to the last complete 4 chars
                        l = placeHolders > 0 ? b64.length - 4 : b64.length;

                        var L = 0;

                        function push(v) {
                            arr[L++] = v;
                        }

                        for (i = 0, j = 0; i < l; i += 4, j += 3) {
                            tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
                            push((tmp & 0xFF0000) >> 16);
                            push((tmp & 0xFF00) >> 8);
                            push(tmp & 0xFF);
                        }

                        if (placeHolders === 2) {
                            tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
                            push(tmp & 0xFF);
                        } else if (placeHolders === 1) {
                            tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
                            push(tmp >> 8 & 0xFF);
                            push(tmp & 0xFF);
                        }

                        return arr;
                    }

                    function uint8ToBase64(uint8) {
                        var i,
                            extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                            output = '',
                            temp, length;

                        function encode(num) {
                            return lookup.charAt(num);
                        }

                        function tripletToBase64(num) {
                            return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
                        }

                        // go through the array every three bytes, we'll deal with trailing stuff later
                        for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                            temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
                            output += tripletToBase64(temp);
                        }

                        // pad the end with zeros, but make sure to not forget the extra bytes
                        switch (extraBytes) {
                            case 1:
                                temp = uint8[uint8.length - 1];
                                output += encode(temp >> 2);
                                output += encode(temp << 4 & 0x3F);
                                output += '==';
                                break;

                            case 2:
                                temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
                                output += encode(temp >> 10);
                                output += encode(temp >> 4 & 0x3F);
                                output += encode(temp << 2 & 0x3F);
                                output += '=';
                                break;
                        }

                        return output;
                    }

                    exports.toByteArray = b64ToByteArray;
                    exports.fromByteArray = uint8ToBase64;
                }(typeof exports === 'undefined' ? this.base64js = {} : exports));

            },{}],15: [function (require, module, exports) {
                exports.read = function (buffer, offset, isLE, mLen, nBytes) {
                    var e, m;
                    var eLen = nBytes * 8 - mLen - 1;
                    var eMax = (1 << eLen) - 1;
                    var eBias = eMax >> 1;
                    var nBits = -7;
                    var i = isLE ? nBytes - 1 : 0;
                    var d = isLE ? -1 : 1;
                    var s = buffer[offset + i];

                    i += d;

                    e = s & (1 << -nBits) - 1;
                    s >>= -nBits;
                    nBits += eLen;

                    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

                    m = e & (1 << -nBits) - 1;
                    e >>= -nBits;
                    nBits += mLen;

                    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

                    if (e === 0) {
                        e = 1 - eBias;
                    } else if (e === eMax) {
                        return m ? NaN : (s ? -1 : 1) * Infinity;
                    } else {
                        m += Math.pow(2, mLen);
                        e -= eBias;
                    }

                    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
                };

                exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
                    var e, m, c;
                    var eLen = nBytes * 8 - mLen - 1;
                    var eMax = (1 << eLen) - 1;
                    var eBias = eMax >> 1;
                    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                    var i = isLE ? 0 : nBytes - 1;
                    var d = isLE ? 1 : -1;
                    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

                    value = Math.abs(value);

                    if (isNaN(value) || value === Infinity) {
                        m = isNaN(value) ? 1 : 0;
                        e = eMax;
                    } else {
                        e = Math.floor(Math.log(value) / Math.LN2);

                        if (value * (c = Math.pow(2, -e)) < 1) {
                            e--;
                            c *= 2;
                        }

                        if (e + eBias >= 1) {
                            value += rt / c;
                        } else {
                            value += rt * Math.pow(2, 1 - eBias);
                        }

                        if (value * c >= 2) {
                            e++;
                            c /= 2;
                        }

                        if (e + eBias >= eMax) {
                            m = 0;
                            e = eMax;
                        } else if (e + eBias >= 1) {
                            m = (value * c - 1) * Math.pow(2, mLen);
                            e += eBias;
                        } else {
                            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                            e = 0;
                        }
                    }

                    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

                    e = e << mLen | m;
                    eLen += mLen;

                    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

                    buffer[offset + i - d] |= s * 128;
                };

            },{}],16: [function (require, module, exports) {

                /**
                 * isArray
                 */

                var isArray = Array.isArray;

                /**
                 * toString
                 */

                var str = Object.prototype.toString;

                /**
                 * Whether or not the given `val`
                 * is an array.
                 *
                 * example:
                 *
                 *        isArray([]);
                 *        // > true
                 *        isArray(arguments);
                 *        // > false
                 *        isArray('');
                 *        // > false
                 *
                 * @param {mixed} val
                 * @return {bool}
                 */

                module.exports = isArray || function (val) {
                    return !!val && '[object Array]' == str.call(val);
                };

            },{}],17: [function (require, module, exports) {
                // shim for using process in browser

                var process = module.exports = {};
                var queue = [];
                var draining = false;

                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    draining = true;
                    var currentQueue;
                    var len = queue.length;

                    while (len) {
                        currentQueue = queue;
                        queue = [];
                        var i = -1;

                        while (++i < len) {
                            currentQueue[i]();
                        }
                        len = queue.length;
                    }
                    draining = false;
                }
                process.nextTick = function (fun) {
                    queue.push(fun);

                    if (!draining) {
                        setTimeout(drainQueue, 0);
                    }
                };

                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};

                function noop() {}

                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;

                process.binding = function (name) {
                    throw new Error('process.binding is not supported');
                };

                // TODO(shtylman)
                process.cwd = function () {
                    return '/';
                };
                process.chdir = function (dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function () {
                    return 0;
                };

            },{}],18: [function (require, module, exports) {
                (function (Buffer) {
                    (function () {
                        'use strict';

                        function btoa(str) {
                            var buffer

                                ;

                            if (str instanceof Buffer) {
                                buffer = str;
                            } else {
                                buffer = new Buffer(str.toString(), 'binary');
                            }

                            return buffer.toString('base64');
                        }

                        module.exports = btoa;
                    }());

                }).call(this, require('buffer').Buffer);
                //# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9idG9hL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uICgpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZnVuY3Rpb24gYnRvYShzdHIpIHtcbiAgICB2YXIgYnVmZmVyXG4gICAgICA7XG5cbiAgICBpZiAoc3RyIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoc3RyLnRvU3RyaW5nKCksICdiaW5hcnknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gYnRvYTtcbn0oKSk7XG4iXX0=
            },{
                'buffer': 13
            }],19: [function (require, module, exports) {
                /* jshint node: true */
                (function () {
                    'use strict';

                    function CookieAccessInfo(domain, path, secure, script) {
                        if (this instanceof CookieAccessInfo) {
                            this.domain = domain || undefined;
                            this.path = path || '/';
                            this.secure = !!secure;
                            this.script = !!script;

                            return this;
                        }

                        return new CookieAccessInfo(domain, path, secure, script);
                    }
                    exports.CookieAccessInfo = CookieAccessInfo;

                    function Cookie(cookiestr, request_domain, request_path) {
                        if (cookiestr instanceof Cookie) {
                            return cookiestr;
                        }

                        if (this instanceof Cookie) {
                            this.name = null;
                            this.value = null;
                            this.expiration_date = Infinity;
                            this.path = String(request_path || '/');
                            this.explicit_path = false;
                            this.domain = request_domain || null;
                            this.explicit_domain = false;
                            this.secure = false; //how to define default?
                            this.noscript = false; //httponly
                            if (cookiestr) {
                                this.parse(cookiestr, request_domain, request_path);
                            }

                            return this;
                        }

                        return new Cookie(cookiestr);
                    }
                    exports.Cookie = Cookie;

                    Cookie.prototype.toString = function toString() {
                        var str = [this.name + '=' + this.value];

                        if (this.expiration_date !== Infinity) {
                            str.push('expires=' + (new Date(this.expiration_date)).toGMTString());
                        }

                        if (this.domain) {
                            str.push('domain=' + this.domain);
                        }

                        if (this.path) {
                            str.push('path=' + this.path);
                        }

                        if (this.secure) {
                            str.push('secure');
                        }

                        if (this.noscript) {
                            str.push('httponly');
                        }

                        return str.join('; ');
                    };

                    Cookie.prototype.toValueString = function toValueString() {
                        return this.name + '=' + this.value;
                    };

                    var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;

                    Cookie.prototype.parse = function parse(str, request_domain, request_path) {
                        if (this instanceof Cookie) {
                            var parts = str.split(';').filter(function (value) {
                                    return !!value;
                                }),
                                pair = parts[0].match(/([^=]+)=([\s\S]*)/),
                                key = pair[1],
                                value = pair[2],
                                i;

                            this.name = key;
                            this.value = value;

                            for (i = 1; i < parts.length; i += 1) {
                                pair = parts[i].match(/([^=]+)(?:=([\s\S]*))?/);
                                key = pair[1].trim().toLowerCase();
                                value = pair[2];

                                switch (key) {
                                    case 'httponly':
                                        this.noscript = true;
                                        break;

                                    case 'expires':
                                        this.expiration_date = value ?
                                            Number(Date.parse(value)) :
                                            Infinity;
                                        break;

                                    case 'path':
                                        this.path = value ?
                                            value.trim() :
                                            '';
                                        this.explicit_path = true;
                                        break;

                                    case 'domain':
                                        this.domain = value ?
                                            value.trim() :
                                            '';
                                        this.explicit_domain = !!this.domain;
                                        break;

                                    case 'secure':
                                        this.secure = true;
                                        break;
                                }
                            }

                            if (!this.explicit_path) {
                                this.path = request_path || '/';
                            }

                            if (!this.explicit_domain) {
                                this.domain = request_domain;
                            }

                            return this;
                        }

                        return new Cookie().parse(str, request_domain, request_path);
                    };

                    Cookie.prototype.matches = function matches(access_info) {
                        if (this.noscript && access_info.script ||
                            this.secure && !access_info.secure ||
                            !this.collidesWith(access_info)) {
                            return false;
                        }

                        return true;
                    };

                    Cookie.prototype.collidesWith = function collidesWith(access_info) {
                        if (this.path && !access_info.path || this.domain && !access_info.domain) {
                            return false;
                        }

                        if (this.path && access_info.path.indexOf(this.path) !== 0) {
                            return false;
                        }

                        if (!this.explicit_path) {
                            if (this.path !== access_info.path) {
                                return false;
                            }
                        }
                        var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, '');
                        var cookie_domain = this.domain && this.domain.replace(/^[\.]/, '');

                        if (cookie_domain === access_domain) {
                            return true;
                        }

                        if (cookie_domain) {
                            if (!this.explicit_domain) {
                                return false; // we already checked if the domains were exactly the same
                            }
                            var wildcard = access_domain.indexOf(cookie_domain);

                            if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
                                return false;
                            }

                            return true;
                        }

                        return true;
                    };

                    function CookieJar() {
                        var cookies, cookies_list, collidable_cookie;

                        if (this instanceof CookieJar) {
                            cookies = Object.create(null); //name: [Cookie]

                            this.setCookie = function setCookie(cookie, request_domain, request_path) {
                                var remove, i;

                                cookie = new Cookie(cookie, request_domain, request_path);
                                //Delete the cookie if the set is past the current time
                                remove = cookie.expiration_date <= Date.now();

                                if (cookies[cookie.name] !== undefined) {
                                    cookies_list = cookies[cookie.name];

                                    for (i = 0; i < cookies_list.length; i += 1) {
                                        collidable_cookie = cookies_list[i];

                                        if (collidable_cookie.collidesWith(cookie)) {
                                            if (remove) {
                                                cookies_list.splice(i, 1);

                                                if (cookies_list.length === 0) {
                                                    delete cookies[cookie.name];
                                                }

                                                return false;
                                            }
                                            cookies_list[i] = cookie;

                                            return cookie;
                                        }
                                    }

                                    if (remove) {
                                        return false;
                                    }
                                    cookies_list.push(cookie);

                                    return cookie;
                                }

                                if (remove) {
                                    return false;
                                }
                                cookies[cookie.name] = [cookie];

                                return cookies[cookie.name];
                            };
                            //returns a cookie
                            this.getCookie = function getCookie(cookie_name, access_info) {
                                var cookie, i;

                                cookies_list = cookies[cookie_name];

                                if (!cookies_list) {
                                    return;
                                }

                                for (i = 0; i < cookies_list.length; i += 1) {
                                    cookie = cookies_list[i];

                                    if (cookie.expiration_date <= Date.now()) {
                                        if (cookies_list.length === 0) {
                                            delete cookies[cookie.name];
                                        }
                                        continue;
                                    }

                                    if (cookie.matches(access_info)) {
                                        return cookie;
                                    }
                                }
                            };
                            //returns a list of cookies
                            this.getCookies = function getCookies(access_info) {
                                var matches = [],
 cookie_name, cookie;

                                for (cookie_name in cookies) {
                                    cookie = this.getCookie(cookie_name, access_info);

                                    if (cookie) {
                                        matches.push(cookie);
                                    }
                                }
                                matches.toString = function toString() {
                                    return matches.join(':');
                                };
                                matches.toValueString = function toValueString() {
                                    return matches.map(function (c) {
                                        return c.toValueString();
                                    }).join(';');
                                };

                                return matches;
                            };

                            return this;
                        }

                        return new CookieJar();
                    }
                    exports.CookieJar = CookieJar;

                    //returns list of cookies that were set correctly. Cookies that are expired and removed are not returned.
                    CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
                        cookies = Array.isArray(cookies) ?
                            cookies :
                            cookies.split(cookie_str_splitter);
                        var successful = [],
                            i,
                            cookie;

                        cookies = cookies.map(Cookie);

                        for (i = 0; i < cookies.length; i += 1) {
                            cookie = cookies[i];

                            if (this.setCookie(cookie, request_domain, request_path)) {
                                successful.push(cookie);
                            }
                        }

                        return successful;
                    };
                }());

            },{}],20: [function (require, module, exports) {
                /*!
                 * jQuery JavaScript Library v2.1.4
                 * http://jquery.com/
                 *
                 * Includes Sizzle.js
                 * http://sizzlejs.com/
                 *
                 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
                 * Released under the MIT license
                 * http://jquery.org/license
                 *
                 * Date: 2015-04-28T16:01Z
                 */

                (function (global, factory) {

                    if (typeof module === 'object' && typeof module.exports === 'object') {
                        // For CommonJS and CommonJS-like environments where a proper `window`
                        // is present, execute the factory and get jQuery.
                        // For environments that do not have a `window` with a `document`
                        // (such as Node.js), expose a factory as module.exports.
                        // This accentuates the need for the creation of a real `window`.
                        // e.g. var jQuery = require("jquery")(window);
                        // See ticket #14549 for more info.
                        module.exports = global.document ?
                            factory(global, true) :
                            function (w) {
                                if (!w.document) {
                                    throw new Error('jQuery requires a window with a document');
                                }

                                return factory(w);
                            };
                    } else {
                        factory(global);
                    }

                    // Pass this if window is not defined yet
                }(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {

                    // Support: Firefox 18+
                    // Can't be in strict mode, several libs including ASP.NET trace
                    // the stack via arguments.caller.callee and Firefox dies if
                    // you try to trace through "use strict" call chains. (#13335)
                    //

                    var arr = [];

                    var slice = arr.slice;

                    var concat = arr.concat;

                    var push = arr.push;

                    var indexOf = arr.indexOf;

                    var class2type = {};

                    var toString = class2type.toString;

                    var hasOwn = class2type.hasOwnProperty;

                    var support = {};

                    var
                    // Use the correct document accordingly with window argument (sandbox)
                        document = window.document,

                        version = '2.1.4',

                    // Define a local copy of jQuery
                        jQuery = function (selector, context) {
                            // The jQuery object is actually just the init constructor 'enhanced'
                            // Need init if jQuery is called (just allow error to be thrown if not included)
                            return new jQuery.fn.init(selector, context);
                        },

                    // Support: Android<4.1
                    // Make sure we trim BOM and NBSP
                        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

                    // Matches dashed string for camelizing
                        rmsPrefix = /^-ms-/,
                        rdashAlpha = /-([\da-z])/gi,

                    // Used by jQuery.camelCase as callback to replace()
                        fcamelCase = function (all, letter) {
                            return letter.toUpperCase();
                        };

                    jQuery.fn = jQuery.prototype = {
                        // The current version of jQuery being used
                        jquery: version,

                        constructor: jQuery,

                        // Start with an empty selector
                        selector: '',

                        // The default length of a jQuery object is 0
                        length: 0,

                        toArray: function () {
                            return slice.call(this);
                        },

                        // Get the Nth element in the matched element set OR
                        // Get the whole matched element set as a clean array
                        get: function (num) {
                            return num != null ?

                                // Return just the one element from the set
                                 num < 0 ? this[ num + this.length ] : this[ num ]  :

                                // Return all the elements in a clean array
                                slice.call(this);
                        },

                        // Take an array of elements and push it onto the stack
                        // (returning the new matched element set)
                        pushStack: function (elems) {

                            // Build a new jQuery matched element set
                            var ret = jQuery.merge(this.constructor(), elems);

                            // Add the old object onto the stack (as a reference)
                            ret.prevObject = this;
                            ret.context = this.context;

                            // Return the newly-formed element set
                            return ret;
                        },

                        // Execute a callback for every element in the matched set.
                        // (You can seed the arguments with an array of args, but this is
                        // only used internally.)
                        each: function (callback, args) {
                            return jQuery.each(this, callback, args);
                        },

                        map: function (callback) {
                            return this.pushStack(jQuery.map(this, function (elem, i) {
                                return callback.call(elem, i, elem);
                            }));
                        },

                        slice: function () {
                            return this.pushStack(slice.apply(this, arguments));
                        },

                        first: function () {
                            return this.eq(0);
                        },

                        last: function () {
                            return this.eq(-1);
                        },

                        eq: function (i) {
                            var len = this.length,
                                j = +i + (i < 0 ? len : 0);

                            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
                        },

                        end: function () {
                            return this.prevObject || this.constructor(null);
                        },

                        // For internal use only.
                        // Behaves like an Array's method, not like a jQuery method.
                        push: push,
                        sort: arr.sort,
                        splice: arr.splice
                    };

                    jQuery.extend = jQuery.fn.extend = function () {
                        var options, name, src, copy, copyIsArray, clone,
                            target = arguments[0] || {},
                            i = 1,
                            length = arguments.length,
                            deep = false;

                        // Handle a deep copy situation
                        if (typeof target === 'boolean') {
                            deep = target;

                            // Skip the boolean and the target
                            target = arguments[ i ] || {};
                            i++;
                        }

                        // Handle case when target is a string or something (possible in deep copy)
                        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
                            target = {};
                        }

                        // Extend jQuery itself if only one argument is passed
                        if (i === length) {
                            target = this;
                            i--;
                        }

                        for (; i < length; i++) {
                            // Only deal with non-null/undefined values
                            if ((options = arguments[ i ]) != null) {
                                // Extend the base object
                                for (name in options) {
                                    src = target[ name ];
                                    copy = options[ name ];

                                    // Prevent never-ending loop
                                    if (target === copy) {
                                        continue;
                                    }

                                    // Recurse if we're merging plain objects or arrays
                                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                                        if (copyIsArray) {
                                            copyIsArray = false;
                                            clone = src && jQuery.isArray(src) ? src : [];

                                        } else {
                                            clone = src && jQuery.isPlainObject(src) ? src : {};
                                        }

                                        // Never move original objects, clone them
                                        target[ name ] = jQuery.extend(deep, clone, copy);

                                        // Don't bring in undefined values
                                    } else if (copy !== undefined) {
                                        target[ name ] = copy;
                                    }
                                }
                            }
                        }

                        // Return the modified object
                        return target;
                    };

                    jQuery.extend({
                        // Unique for each copy of jQuery on the page
                        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),

                        // Assume jQuery is ready without the ready module
                        isReady: true,

                        error: function (msg) {
                            throw new Error(msg);
                        },

                        noop: function () {},

                        isFunction: function (obj) {
                            return jQuery.type(obj) === 'function';
                        },

                        isArray: Array.isArray,

                        isWindow: function (obj) {
                            return obj != null && obj === obj.window;
                        },

                        isNumeric: function (obj) {
                            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
                            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                            // subtraction forces infinities to NaN
                            // adding 1 corrects loss of precision from parseFloat (#15100)
                            return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
                        },

                        isPlainObject: function (obj) {
                            // Not plain objects:
                            // - Any object or value whose internal [[Class]] property is not "[object Object]"
                            // - DOM nodes
                            // - window
                            if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                                return false;
                            }

                            if (obj.constructor &&
                                !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                                return false;
                            }

                            // If the function hasn't returned already, we're confident that
                            // |obj| is a plain object, created by {} or constructed with new Object
                            return true;
                        },

                        isEmptyObject: function (obj) {
                            var name;

                            for (name in obj) {
                                return false;
                            }

                            return true;
                        },

                        type: function (obj) {
                            if (obj == null) {
                                return obj + '';
                            }
                            // Support: Android<4.0, iOS<6 (functionish RegExp)
                            return typeof obj === 'object' || typeof obj === 'function' ?
                            class2type[ toString.call(obj) ] || 'object' :
                                typeof obj;
                        },

                        // Evaluates a script in a global context
                        globalEval: function (code) {
                            var script,
                                indirect = eval;

                            code = jQuery.trim(code);

                            if (code) {
                                // If the code includes a valid, prologue position
                                // strict mode pragma, execute code by injecting a
                                // script tag into the document.
                                if (code.indexOf('use strict') === 1) {
                                    script = document.createElement('script');
                                    script.text = code;
                                    document.head.appendChild(script).parentNode.removeChild(script);
                                } else {
                                    // Otherwise, avoid the DOM node creation, insertion
                                    // and removal by using an indirect global eval
                                    indirect(code);
                                }
                            }
                        },

                        // Convert dashed to camelCase; used by the css and data modules
                        // Support: IE9-11+
                        // Microsoft forgot to hump their vendor prefix (#9572)
                        camelCase: function (string) {
                            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
                        },

                        nodeName: function (elem, name) {
                            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                        },

                        // args is for internal usage only
                        each: function (obj, callback, args) {
                            var value,
                                i = 0,
                                length = obj.length,
                                isArray = isArraylike(obj);

                            if (args) {
                                if (isArray) {
                                    for (; i < length; i++) {
                                        value = callback.apply(obj[ i ], args);

                                        if (value === false) {
                                            break;
                                        }
                                    }
                                } else {
                                    for (i in obj) {
                                        value = callback.apply(obj[ i ], args);

                                        if (value === false) {
                                            break;
                                        }
                                    }
                                }

                                // A special, fast, case for the most common use of each
                            } else if (isArray) {
                                for (; i < length; i++) {
                                    value = callback.call(obj[ i ], i, obj[ i ]);

                                    if (value === false) {
                                        break;
                                    }
                                }
                            } else {
                                for (i in obj) {
                                    value = callback.call(obj[ i ], i, obj[ i ]);

                                    if (value === false) {
                                        break;
                                    }
                                }
                            }

                            return obj;
                        },

                        // Support: Android<4.1
                        trim: function (text) {
                            return text == null ?
                                '' :
                                (text + '').replace(rtrim, '');
                        },

                        // results is for internal usage only
                        makeArray: function (arr, results) {
                            var ret = results || [];

                            if (arr != null) {
                                if (isArraylike(Object(arr))) {
                                    jQuery.merge(ret,
                                        typeof arr === 'string' ?
                                            [arr] : arr
                                    );
                                } else {
                                    push.call(ret, arr);
                                }
                            }

                            return ret;
                        },

                        inArray: function (elem, arr, i) {
                            return arr == null ? -1 : indexOf.call(arr, elem, i);
                        },

                        merge: function (first, second) {
                            var len = +second.length,
                                j = 0,
                                i = first.length;

                            for (; j < len; j++) {
                                first[ i++ ] = second[ j ];
                            }

                            first.length = i;

                            return first;
                        },

                        grep: function (elems, callback, invert) {
                            var callbackInverse,
                                matches = [],
                                i = 0,
                                length = elems.length,
                                callbackExpect = !invert;

                            // Go through the array, only saving the items
                            // that pass the validator function
                            for (; i < length; i++) {
                                callbackInverse = !callback(elems[ i ], i);

                                if (callbackInverse !== callbackExpect) {
                                    matches.push(elems[ i ]);
                                }
                            }

                            return matches;
                        },

                        // arg is for internal usage only
                        map: function (elems, callback, arg) {
                            var value,
                                i = 0,
                                length = elems.length,
                                isArray = isArraylike(elems),
                                ret = [];

                            // Go through the array, translating each of the items to their new values
                            if (isArray) {
                                for (; i < length; i++) {
                                    value = callback(elems[ i ], i, arg);

                                    if (value != null) {
                                        ret.push(value);
                                    }
                                }

                                // Go through every key on the object,
                            } else {
                                for (i in elems) {
                                    value = callback(elems[ i ], i, arg);

                                    if (value != null) {
                                        ret.push(value);
                                    }
                                }
                            }

                            // Flatten any nested arrays
                            return concat.apply([], ret);
                        },

                        // A global GUID counter for objects
                        guid: 1,

                        // Bind a function to a context, optionally partially applying any
                        // arguments.
                        proxy: function (fn, context) {
                            var tmp, args, proxy;

                            if (typeof context === 'string') {
                                tmp = fn[ context ];
                                context = fn;
                                fn = tmp;
                            }

                            // Quick check to determine if target is callable, in the spec
                            // this throws a TypeError, but we will just return undefined.
                            if (!jQuery.isFunction(fn)) {
                                return undefined;
                            }

                            // Simulated bind
                            args = slice.call(arguments, 2);
                            proxy = function () {
                                return fn.apply(context || this, args.concat(slice.call(arguments)));
                            };

                            // Set the guid of unique handler to the same of original handler, so it can be removed
                            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                            return proxy;
                        },

                        now: Date.now,

                        // jQuery.support is not used in Core but other projects attach their
                        // properties to it so it needs to exist.
                        support: support
                    });

                    // Populate the class2type map
                    jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
                        class2type[ '[object ' + name + ']' ] = name.toLowerCase();
                    });

                    function isArraylike(obj) {

                        // Support: iOS 8.2 (not reproducible in simulator)
                        // `in` check used to prevent JIT error (gh-2145)
                        // hasOwn isn't used here due to false negatives
                        // regarding Nodelist length in IE
                        var length = 'length' in obj && obj.length,
                            type = jQuery.type(obj);

                        if (type === 'function' || jQuery.isWindow(obj)) {
                            return false;
                        }

                        if (obj.nodeType === 1 && length) {
                            return true;
                        }

                        return type === 'array' || length === 0 ||
                            typeof length === 'number' && length > 0 &&  length - 1  in obj;
                    }
                    var Sizzle =

                        /*!
                         * Sizzle CSS Selector Engine v2.2.0-pre
                         * http://sizzlejs.com/
                         *
                         * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
                         * Released under the MIT license
                         * http://jquery.org/license
                         *
                         * Date: 2014-12-16
                         */
                        (function (window) {

                            var i,
                                support,
                                Expr,
                                getText,
                                isXML,
                                tokenize,
                                compile,
                                select,
                                outermostContext,
                                sortInput,
                                hasDuplicate,

                            // Local document vars
                                setDocument,
                                document,
                                docElem,
                                documentIsHTML,
                                rbuggyQSA,
                                rbuggyMatches,
                                matches,
                                contains,

                            // Instance-specific data
                                expando = 'sizzle' + 1 * new Date(),
                                preferredDoc = window.document,
                                dirruns = 0,
                                done = 0,
                                classCache = createCache(),
                                tokenCache = createCache(),
                                compilerCache = createCache(),
                                sortOrder = function (a, b) {
                                    if (a === b) {
                                        hasDuplicate = true;
                                    }

                                    return 0;
                                },

                            // General-purpose constants
                                MAX_NEGATIVE = 1 << 31,

                            // Instance methods
                                hasOwn = {}.hasOwnProperty,
                                arr = [],
                                pop = arr.pop,
                                push_native = arr.push,
                                push = arr.push,
                                slice = arr.slice,
                            // Use a stripped-down indexOf as it's faster than native
                            // http://jsperf.com/thor-indexof-vs-for/5
                                indexOf = function (list, elem) {
                                    var i = 0,
                                        len = list.length;

                                    for (; i < len; i++) {
                                        if (list[i] === elem) {
                                            return i;
                                        }
                                    }

                                    return -1;
                                },

                                booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',

                            // Regular expressions

                            // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                                whitespace = '[\\x20\\t\\r\\n\\f]',
                            // http://www.w3.org/TR/css3-syntax/#characters
                                characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+',

                            // Loosely modeled on CSS identifier characters
                            // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                            // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                                identifier = characterEncoding.replace('w', 'w#'),

                            // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                                attributes = '\\[' + whitespace + '*(' + characterEncoding + ')(?:' + whitespace +
                                        // Operator (capture 2)
                                    '*([*^$|!~]?=)' + whitespace +
                                        // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                                    '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\\"])*)"|(' + identifier + '))|)' + whitespace +
                                    '*\\]',

                                pseudos = ':(' + characterEncoding + ')(?:\\((' +
                                        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                                        // 1. quoted (capture 3; capture 4 or capture 5)
                                    '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\\"])*)")|' +
                                        // 2. simple (capture 6)
                                    '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' +
                                        // 3. anything else (capture 2)
                                    '.*' +
                                    ')\\)|)',

                            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                                rwhitespace = new RegExp(whitespace + '+', 'g'),
                                rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'),

                                rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'),
                                rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'),

                                rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'),

                                rpseudo = new RegExp(pseudos),
                                ridentifier = new RegExp('^' + identifier + '$'),

                                matchExpr = {
                                    'ID': new RegExp('^#(' + characterEncoding + ')'),
                                    'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                                    'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                                    'ATTR': new RegExp('^' + attributes),
                                    'PSEUDO': new RegExp('^' + pseudos),
                                    'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace +
                                    '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace +
                                    '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                                    'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                                    // For use in libraries implementing .is()
                                    // We use this for POS matching in `select`
                                    'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' +
                                    whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
                                },

                                rinputs = /^(?:input|select|textarea|button)$/i,
                                rheader = /^h\d$/i,

                                rnative = /^[^{]+\{\s*\[native \w/,

                            // Easily-parseable/retrievable ID or TAG or CLASS selectors
                                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                                rsibling = /[+~]/,
                                rescape = /'|\\/g,

                            // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                                runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'),
                                funescape = function (_, escaped, escapedWhitespace) {
                                    var high = '0x' + escaped - 0x10000;
                                    // NaN means non-codepoint
                                    // Support: Firefox<24
                                    // Workaround erroneous numeric interpretation of +"0x"

                                    return high !== high || escapedWhitespace ?
                                        escaped :
                                        high < 0 ?
                                            // BMP codepoint
                                            String.fromCharCode(high + 0x10000) :
                                            // Supplemental Plane codepoint (surrogate pair)
                                            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                                },

                            // Used for iframes
                            // See setDocument()
                            // Removing the function wrapper causes a "Permission Denied"
                            // error in IE
                                unloadHandler = function () {
                                    setDocument();
                                };

                            // Optimize for push.apply( _, NodeList )
                            try {
                                push.apply(
                                    arr = slice.call(preferredDoc.childNodes),
                                    preferredDoc.childNodes
                                );
                                // Support: Android<4.0
                                // Detect silently failing push.apply
                                arr[ preferredDoc.childNodes.length ].nodeType;
                            } catch (e) {
                                push = {
                                    apply: arr.length ?

                                                                        // Leverage slice if possible
                                                                        function (target, els) {
                                                                            push_native.apply(target, slice.call(els));
                                                                        } :

                                                                        // Support: IE<9
                                                                        // Otherwise append directly
                                                                        function (target, els) {
                                                                            var j = target.length,
                                                                                i = 0;
                                                                            // Can't trust NodeList.length

                                                                            while (target[j++] = els[i++]) {}
                                                                            target.length = j - 1;
                                                                        }
                                };
                            }

                            function Sizzle(selector, context, results, seed) {
                                var match, elem, m, nodeType,
                                // QSA vars
                                    i, groups, old, nid, newContext, newSelector;

                                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                                    setDocument(context);
                                }

                                context = context || document;
                                results = results || [];
                                nodeType = context.nodeType;

                                if (typeof selector !== 'string' || !selector ||
                                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                                    return results;
                                }

                                if (!seed && documentIsHTML) {

                                    // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
                                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                                        // Speed-up: Sizzle("#ID")
                                        if (m = match[1]) {
                                            if (nodeType === 9) {
                                                elem = context.getElementById(m);
                                                // Check parentNode to catch when Blackberry 4.6 returns
                                                // nodes that are no longer in the document (jQuery #6963)
                                                if (elem && elem.parentNode) {
                                                    // Handle the case where IE, Opera, and Webkit return items
                                                    // by name instead of ID
                                                    if (elem.id === m) {
                                                        results.push(elem);

                                                        return results;
                                                    }
                                                } else {
                                                    return results;
                                                }
                                            } else {
                                                // Context is not a document
                                                if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
                                                    contains(context, elem) && elem.id === m) {
                                                    results.push(elem);

                                                    return results;
                                                }
                                            }

                                            // Speed-up: Sizzle("TAG")
                                        } else if (match[2]) {
                                            push.apply(results, context.getElementsByTagName(selector));

                                            return results;

                                            // Speed-up: Sizzle(".CLASS")
                                        } else if ((m = match[3]) && support.getElementsByClassName) {
                                            push.apply(results, context.getElementsByClassName(m));

                                            return results;
                                        }
                                    }

                                    // QSA path
                                    if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                                        nid = old = expando;
                                        newContext = context;
                                        newSelector = nodeType !== 1 && selector;

                                        // qSA works strangely on Element-rooted queries
                                        // We can work around this by specifying an extra ID on the root
                                        // and working up from there (Thanks to Andrew Dupont for the technique)
                                        // IE 8 doesn't work on object elements
                                        if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                                            groups = tokenize(selector);

                                            if (old = context.getAttribute('id')) {
                                                nid = old.replace(rescape, '\\$&');
                                            } else {
                                                context.setAttribute('id', nid);
                                            }
                                            nid = '[id=\'' + nid + '\'] ';

                                            i = groups.length;

                                            while (i--) {
                                                groups[i] = nid + toSelector(groups[i]);
                                            }
                                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                                            newSelector = groups.join(',');
                                        }

                                        if (newSelector) {
                                            try {
                                                push.apply(results,
                                                    newContext.querySelectorAll(newSelector)
                                                );

                                                return results;
                                            } catch (qsaError) {
                                            } finally {
                                                if (!old) {
                                                    context.removeAttribute('id');
                                                }
                                            }
                                        }
                                    }
                                }

                                // All others
                                return select(selector.replace(rtrim, '$1'), context, results, seed);
                            }

                            /**
                             * Create key-value caches of limited size
                             * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
                             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                             *	deleting the oldest entry
                             */
                            function createCache() {
                                var keys = [];

                                function cache(key, value) {
                                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                                    if (keys.push(key + ' ') > Expr.cacheLength) {
                                        // Only keep the most recent entries
                                        delete cache[ keys.shift() ];
                                    }

                                    return cache[ key + ' ' ] = value;
                                }

                                return cache;
                            }

                            /**
                             * Mark a function for special use by Sizzle
                             * @param {Function} fn The function to mark
                             */
                            function markFunction(fn) {
                                fn[ expando ] = true;

                                return fn;
                            }

                            /**
                             * Support testing using an element
                             * @param {Function} fn Passed the created div and expects a boolean result
                             */
                            function assert(fn) {
                                var div = document.createElement('div');

                                try {
                                    return !!fn(div);
                                } catch (e) {
                                    return false;
                                } finally {
                                    // Remove from its parent by default
                                    if (div.parentNode) {
                                        div.parentNode.removeChild(div);
                                    }
                                    // release memory in IE
                                    div = null;
                                }
                            }

                            /**
                             * Adds the same handler for all of the specified attrs
                             * @param {String} attrs Pipe-separated list of attributes
                             * @param {Function} handler The method that will be applied
                             */
                            function addHandle(attrs, handler) {
                                var arr = attrs.split('|'),
                                    i = attrs.length;

                                while (i--) {
                                    Expr.attrHandle[ arr[i] ] = handler;
                                }
                            }

                            /**
                             * Checks document order of two siblings
                             * @param {Element} a
                             * @param {Element} b
                             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                             */
                            function siblingCheck(a, b) {
                                var cur = b && a,
                                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                                        (~b.sourceIndex || MAX_NEGATIVE) -
                                        (~a.sourceIndex || MAX_NEGATIVE);

                                // Use IE sourceIndex if available on both nodes
                                if (diff) {
                                    return diff;
                                }

                                // Check if b follows a
                                if (cur) {
                                    while (cur = cur.nextSibling) {
                                        if (cur === b) {
                                            return -1;
                                        }
                                    }
                                }

                                return a ? 1 : -1;
                            }

                            /**
                             * Returns a function to use in pseudos for input types
                             * @param {String} type
                             */
                            function createInputPseudo(type) {
                                return function (elem) {
                                    var name = elem.nodeName.toLowerCase();

                                    return name === 'input' && elem.type === type;
                                };
                            }

                            /**
                             * Returns a function to use in pseudos for buttons
                             * @param {String} type
                             */
                            function createButtonPseudo(type) {
                                return function (elem) {
                                    var name = elem.nodeName.toLowerCase();

                                    return (name === 'input' || name === 'button') && elem.type === type;
                                };
                            }

                            /**
                             * Returns a function to use in pseudos for positionals
                             * @param {Function} fn
                             */
                            function createPositionalPseudo(fn) {
                                return markFunction(function (argument) {
                                    argument = +argument;

                                    return markFunction(function (seed, matches) {
                                        var j,
                                            matchIndexes = fn([], seed.length, argument),
                                            i = matchIndexes.length;

                                        // Match elements found at the specified indexes
                                        while (i--) {
                                            if (seed[ j = matchIndexes[i] ]) {
                                                seed[j] = !(matches[j] = seed[j]);
                                            }
                                        }
                                    });
                                });
                            }

                            /**
                             * Checks a node for validity as a Sizzle context
                             * @param {Element|Object=} context
                             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                             */
                            function testContext(context) {
                                return context && typeof context.getElementsByTagName !== 'undefined' && context;
                            }

                            // Expose support vars for convenience
                            support = Sizzle.support = {};

                            /**
                             * Detects XML nodes
                             * @param {Element|Object} elem An element or a document
                             * @returns {Boolean} True iff elem is a non-HTML XML node
                             */
                            isXML = Sizzle.isXML = function (elem) {
                                // documentElement is verified for cases where it doesn't yet exist
                                // (such as loading iframes in IE - #4833)
                                var documentElement = elem && (elem.ownerDocument || elem).documentElement;

                                return documentElement ? documentElement.nodeName !== 'HTML' : false;
                            };

                            /**
                             * Sets document-related variables once based on the current document
                             * @param {Element|Object} [doc] An element or document object to use to set the document
                             * @returns {Object} Returns the current document
                             */
                            setDocument = Sizzle.setDocument = function (node) {
                                var hasCompare, parent,
                                    doc = node ? node.ownerDocument || node : preferredDoc;

                                // If no document and documentElement is available, return
                                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                                    return document;
                                }

                                // Set our document
                                document = doc;
                                docElem = doc.documentElement;
                                parent = doc.defaultView;

                                // Support: IE>8
                                // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                                // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                                // IE6-8 do not support the defaultView property so parent will be undefined
                                if (parent && parent !== parent.top) {
                                    // IE11 does not have attachEvent, so all must suffer
                                    if (parent.addEventListener) {
                                        parent.addEventListener('unload', unloadHandler, false);
                                    } else if (parent.attachEvent) {
                                        parent.attachEvent('onunload', unloadHandler);
                                    }
                                }

                                /* Support tests
                                 ---------------------------------------------------------------------- */
                                documentIsHTML = !isXML(doc);

                                /* Attributes
                                 ---------------------------------------------------------------------- */

                                // Support: IE<8
                                // Verify that getAttribute really returns attributes and not properties
                                // (excepting IE8 booleans)
                                support.attributes = assert(function (div) {
                                    div.className = 'i';

                                    return !div.getAttribute('className');
                                });

                                /* getElement(s)By*
                                 ---------------------------------------------------------------------- */

                                // Check if getElementsByTagName("*") returns only elements
                                support.getElementsByTagName = assert(function (div) {
                                    div.appendChild(doc.createComment(''));

                                    return !div.getElementsByTagName('*').length;
                                });

                                // Support: IE<9
                                support.getElementsByClassName = rnative.test(doc.getElementsByClassName);

                                // Support: IE<10
                                // Check if getElementById returns elements by name
                                // The broken getElementById methods don't pick up programatically-set names,
                                // so use a roundabout getElementsByName test
                                support.getById = assert(function (div) {
                                    docElem.appendChild(div).id = expando;

                                    return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                                });

                                // ID find and filter
                                if (support.getById) {
                                    Expr.find['ID'] = function (id, context) {
                                        if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                                            var m = context.getElementById(id);
                                            // Check parentNode to catch when Blackberry 4.6 returns
                                            // nodes that are no longer in the document #6963

                                            return m && m.parentNode ? [m] : [];
                                        }
                                    };
                                    Expr.filter['ID'] = function (id) {
                                        var attrId = id.replace(runescape, funescape);

                                        return function (elem) {
                                            return elem.getAttribute('id') === attrId;
                                        };
                                    };
                                } else {
                                    // Support: IE6/7
                                    // getElementById is not reliable as a find shortcut
                                    delete Expr.find['ID'];

                                    Expr.filter['ID'] =  function (id) {
                                        var attrId = id.replace(runescape, funescape);

                                        return function (elem) {
                                            var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');

                                            return node && node.value === attrId;
                                        };
                                    };
                                }

                                // Tag
                                Expr.find['TAG'] = support.getElementsByTagName ?
                                    function (tag, context) {
                                        if (typeof context.getElementsByTagName !== 'undefined') {
                                            return context.getElementsByTagName(tag);

                                            // DocumentFragment nodes don't have gEBTN
                                        } else if (support.qsa) {
                                            return context.querySelectorAll(tag);
                                        }
                                    } :

                                    function (tag, context) {
                                        var elem,
                                            tmp = [],
                                            i = 0,
                                        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                            results = context.getElementsByTagName(tag);

                                        // Filter out possible comments
                                        if (tag === '*') {
                                            while (elem = results[i++]) {
                                                if (elem.nodeType === 1) {
                                                    tmp.push(elem);
                                                }
                                            }

                                            return tmp;
                                        }

                                        return results;
                                    };

                                // Class
                                Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                                    if (documentIsHTML) {
                                        return context.getElementsByClassName(className);
                                    }
                                };

                                /* QSA/matchesSelector
                                 ---------------------------------------------------------------------- */

                                // QSA and matchesSelector support

                                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                                rbuggyMatches = [];

                                // qSa(:focus) reports false when true (Chrome 21)
                                // We allow this because of a bug in IE8/9 that throws an error
                                // whenever `document.activeElement` is accessed on an iframe
                                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                                // See http://bugs.jquery.com/ticket/13378
                                rbuggyQSA = [];

                                if (support.qsa = rnative.test(doc.querySelectorAll)) {
                                    // Build QSA regex
                                    // Regex strategy adopted from Diego Perini
                                    assert(function (div) {
                                        // Select is set to empty string on purpose
                                        // This is to test IE's treatment of not explicitly
                                        // setting a boolean content attribute,
                                        // since its presence should be enough
                                        // http://bugs.jquery.com/ticket/12359
                                        docElem.appendChild(div).innerHTML = '<a id=\'' + expando + '\'></a>' +
                                        '<select id=\'' + expando + '-\f]\' msallowcapture=\'\'>' +
                                        '<option selected=\'\'></option></select>';

                                        // Support: IE8, Opera 11-12.16
                                        // Nothing should be selected when empty strings follow ^= or $= or *=
                                        // The test attribute must be unknown in Opera but "safe" for WinRT
                                        // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                        if (div.querySelectorAll('[msallowcapture^=\'\']').length) {
                                            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"\")');
                                        }

                                        // Support: IE8
                                        // Boolean attributes and "value" are not treated correctly
                                        if (!div.querySelectorAll('[selected]').length) {
                                            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                                        }

                                        // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
                                        if (!div.querySelectorAll('[id~=' + expando + '-]').length) {
                                            rbuggyQSA.push('~=');
                                        }

                                        // Webkit/Opera - :checked should return selected option elements
                                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                        // IE8 throws error here and will not see later tests
                                        if (!div.querySelectorAll(':checked').length) {
                                            rbuggyQSA.push(':checked');
                                        }

                                        // Support: Safari 8+, iOS 8+
                                        // https://bugs.webkit.org/show_bug.cgi?id=136851
                                        // In-page `selector#id sibing-combinator selector` fails
                                        if (!div.querySelectorAll('a#' + expando + '+*').length) {
                                            rbuggyQSA.push('.#.+[+~]');
                                        }
                                    });

                                    assert(function (div) {
                                        // Support: Windows 8 Native Apps
                                        // The type and name attributes are restricted during .innerHTML assignment
                                        var input = doc.createElement('input');

                                        input.setAttribute('type', 'hidden');
                                        div.appendChild(input).setAttribute('name', 'D');

                                        // Support: IE8
                                        // Enforce case-sensitivity of name attribute
                                        if (div.querySelectorAll('[name=d]').length) {
                                            rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                                        }

                                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                        // IE8 throws error here and will not see later tests
                                        if (!div.querySelectorAll(':enabled').length) {
                                            rbuggyQSA.push(':enabled', ':disabled');
                                        }

                                        // Opera 10-11 does not throw on post-comma invalid pseudos
                                        div.querySelectorAll('*,:x');
                                        rbuggyQSA.push(',.*:');
                                    });
                                }

                                if (support.matchesSelector = rnative.test(matches = docElem.matches ||
                                    docElem.webkitMatchesSelector ||
                                    docElem.mozMatchesSelector ||
                                    docElem.oMatchesSelector ||
                                    docElem.msMatchesSelector)) {

                                    assert(function (div) {
                                        // Check to see if it's possible to do matchesSelector
                                        // on a disconnected node (IE 9)
                                        support.disconnectedMatch = matches.call(div, 'div');

                                        // This should fail with an exception
                                        // Gecko does not error, returns false instead
                                        matches.call(div, '[s!=\'\']:x');
                                        rbuggyMatches.push('!=', pseudos);
                                    });
                                }

                                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
                                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));

                                /* Contains
                                 ---------------------------------------------------------------------- */
                                hasCompare = rnative.test(docElem.compareDocumentPosition);

                                // Element contains another
                                // Purposefully does not implement inclusive descendent
                                // As in, an element does not contain itself
                                contains = hasCompare || rnative.test(docElem.contains) ?
                                    function (a, b) {
                                        var adown = a.nodeType === 9 ? a.documentElement : a,
                                            bup = b && b.parentNode;

                                        return a === bup || !!(bup && bup.nodeType === 1 && (
                                                adown.contains ?
                                                    adown.contains(bup) :
                                                a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                                            ));
                                    } :
                                    function (a, b) {
                                        if (b) {
                                            while (b = b.parentNode) {
                                                if (b === a) {
                                                    return true;
                                                }
                                            }
                                        }

                                        return false;
                                    };

                                /* Sorting
                                 ---------------------------------------------------------------------- */

                                // Document order sorting
                                sortOrder = hasCompare ?
                                    function (a, b) {

                                        // Flag for duplicate removal
                                        if (a === b) {
                                            hasDuplicate = true;

                                            return 0;
                                        }

                                        // Sort on method existence if only one input has compareDocumentPosition
                                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

                                        if (compare) {
                                            return compare;
                                        }

                                        // Calculate position if both inputs belong to the same document
                                        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
                                            a.compareDocumentPosition(b) :

                                            // Otherwise we know they are disconnected
                                            1;

                                        // Disconnected nodes
                                        if (compare & 1 ||
                                            !support.sortDetached && b.compareDocumentPosition(a) === compare) {

                                            // Choose the first element that is related to our preferred document
                                            if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                                return -1;
                                            }

                                            if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                                return 1;
                                            }

                                            // Maintain original order
                                            return sortInput ?
                                                 indexOf(sortInput, a) - indexOf(sortInput, b)  :
                                                0;
                                        }

                                        return compare & 4 ? -1 : 1;
                                    } :
                                    function (a, b) {
                                        // Exit early if the nodes are identical
                                        if (a === b) {
                                            hasDuplicate = true;

                                            return 0;
                                        }

                                        var cur,
                                            i = 0,
                                            aup = a.parentNode,
                                            bup = b.parentNode,
                                            ap = [a],
                                            bp = [b];

                                        // Parentless nodes are either documents or disconnected
                                        if (!aup || !bup) {
                                            return a === doc ? -1 :
                                                b === doc ? 1 :
                                                    aup ? -1 :
                                                        bup ? 1 :
                                                            sortInput ?
                                                                 indexOf(sortInput, a) - indexOf(sortInput, b)  :
                                                                0;

                                            // If the nodes are siblings, we can do a quick check
                                        } else if (aup === bup) {
                                            return siblingCheck(a, b);
                                        }

                                        // Otherwise we need full lists of their ancestors for comparison
                                        cur = a;

                                        while (cur = cur.parentNode) {
                                            ap.unshift(cur);
                                        }
                                        cur = b;

                                        while (cur = cur.parentNode) {
                                            bp.unshift(cur);
                                        }

                                        // Walk down the tree looking for a discrepancy
                                        while (ap[i] === bp[i]) {
                                            i++;
                                        }

                                        return i ?
                                            // Do a sibling check if the nodes have a common ancestor
                                            siblingCheck(ap[i], bp[i]) :

                                            // Otherwise nodes in our document sort first
                                            ap[i] === preferredDoc ? -1 :
                                                bp[i] === preferredDoc ? 1 :
                                                    0;
                                    };

                                return doc;
                            };

                            Sizzle.matches = function (expr, elements) {
                                return Sizzle(expr, null, null, elements);
                            };

                            Sizzle.matchesSelector = function (elem, expr) {
                                // Set document vars if needed
                                if ((elem.ownerDocument || elem) !== document) {
                                    setDocument(elem);
                                }

                                // Make sure that attribute selectors are quoted
                                expr = expr.replace(rattributeQuotes, '=\'$1\']');

                                if (support.matchesSelector && documentIsHTML &&
                                    (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                                    (!rbuggyQSA     || !rbuggyQSA.test(expr))) {

                                    try {
                                        var ret = matches.call(elem, expr);

                                        // IE 9's matchesSelector returns false on disconnected nodes
                                        if (ret || support.disconnectedMatch ||
                                                // As well, disconnected nodes are said to be in a document
                                                // fragment in IE 9
                                            elem.document && elem.document.nodeType !== 11) {
                                            return ret;
                                        }
                                    } catch (e) {}
                                }

                                return Sizzle(expr, document, null, [elem]).length > 0;
                            };

                            Sizzle.contains = function (context, elem) {
                                // Set document vars if needed
                                if ((context.ownerDocument || context) !== document) {
                                    setDocument(context);
                                }

                                return contains(context, elem);
                            };

                            Sizzle.attr = function (elem, name) {
                                // Set document vars if needed
                                if ((elem.ownerDocument || elem) !== document) {
                                    setDocument(elem);
                                }

                                var fn = Expr.attrHandle[ name.toLowerCase() ],
                                // Don't get fooled by Object.prototype properties (jQuery #13807)
                                    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                                        fn(elem, name, !documentIsHTML) :
                                        undefined;

                                return val !== undefined ?
                                    val :
                                    support.attributes || !documentIsHTML ?
                                        elem.getAttribute(name) :
                                        (val = elem.getAttributeNode(name)) && val.specified ?
                                            val.value :
                                            null;
                            };

                            Sizzle.error = function (msg) {
                                throw new Error('Syntax error, unrecognized expression: ' + msg);
                            };

                            /**
                             * Document sorting and removing duplicates
                             * @param {ArrayLike} results
                             */
                            Sizzle.uniqueSort = function (results) {
                                var elem,
                                    duplicates = [],
                                    j = 0,
                                    i = 0;

                                // Unless we *know* we can detect duplicates, assume their presence
                                hasDuplicate = !support.detectDuplicates;
                                sortInput = !support.sortStable && results.slice(0);
                                results.sort(sortOrder);

                                if (hasDuplicate) {
                                    while (elem = results[i++]) {
                                        if (elem === results[ i ]) {
                                            j = duplicates.push(i);
                                        }
                                    }

                                    while (j--) {
                                        results.splice(duplicates[ j ], 1);
                                    }
                                }

                                // Clear input after sorting to release objects
                                // See https://github.com/jquery/sizzle/pull/225
                                sortInput = null;

                                return results;
                            };

                            /**
                             * Utility function for retrieving the text value of an array of DOM nodes
                             * @param {Array|Element} elem
                             */
                            getText = Sizzle.getText = function (elem) {
                                var node,
                                    ret = '',
                                    i = 0,
                                    nodeType = elem.nodeType;

                                if (!nodeType) {
                                    // If no nodeType, this is expected to be an array
                                    while (node = elem[i++]) {
                                        // Do not traverse comment nodes
                                        ret += getText(node);
                                    }
                                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                                    // Use textContent for elements
                                    // innerText usage removed for consistency of new lines (jQuery #11153)
                                    if (typeof elem.textContent === 'string') {
                                        return elem.textContent;
                                    }
                                    // Traverse its children
                                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                        ret += getText(elem);
                                    }

                                } else if (nodeType === 3 || nodeType === 4) {
                                    return elem.nodeValue;
                                }
                                // Do not include comment or processing instruction nodes

                                return ret;
                            };

                            Expr = Sizzle.selectors = {

                                // Can be adjusted by the user
                                cacheLength: 50,

                                createPseudo: markFunction,

                                match: matchExpr,

                                attrHandle: {},

                                find: {},

                                relative: {
                                    '>': {
                                        dir: 'parentNode', first: true
                                    },
                                    ' ': {
                                        dir: 'parentNode'
                                    },
                                    '+': {
                                        dir: 'previousSibling', first: true
                                    },
                                    '~': {
                                        dir: 'previousSibling'
                                    }
                                },

                                preFilter: {
                                    'ATTR': function (match) {
                                        match[1] = match[1].replace(runescape, funescape);

                                        // Move the given value to match[3] whether quoted or unquoted
                                        match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);

                                        if (match[2] === '~=') {
                                            match[3] = ' ' + match[3] + ' ';
                                        }

                                        return match.slice(0, 4);
                                    },

                                    'CHILD': function (match) {
                                        /* matches from matchExpr["CHILD"]
                                         1 type (only|nth|...)
                                         2 what (child|of-type)
                                         3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                                         4 xn-component of xn+y argument ([+-]?\d*n|)
                                         5 sign of xn-component
                                         6 x of xn-component
                                         7 sign of y-component
                                         8 y of y-component
                                         */
                                        match[1] = match[1].toLowerCase();

                                        if (match[1].slice(0, 3) === 'nth') {
                                            // nth-* requires argument
                                            if (!match[3]) {
                                                Sizzle.error(match[0]);
                                            }

                                            // numeric x and y parameters for Expr.filter.CHILD
                                            // remember that false/true cast respectively to 0/1
                                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                                            match[5] = +(match[7] + match[8]  || match[3] === 'odd');

                                            // other types prohibit arguments
                                        } else if (match[3]) {
                                            Sizzle.error(match[0]);
                                        }

                                        return match;
                                    },

                                    'PSEUDO': function (match) {
                                        var excess,
                                            unquoted = !match[6] && match[2];

                                        if (matchExpr['CHILD'].test(match[0])) {
                                            return null;
                                        }

                                        // Accept quoted arguments as-is
                                        if (match[3]) {
                                            match[2] = match[4] || match[5] || '';

                                            // Strip excess characters from unquoted arguments
                                        } else if (unquoted && rpseudo.test(unquoted) &&
                                                // Get excess from tokenize (recursively)
                                            (excess = tokenize(unquoted, true)) &&
                                                // advance to the next closing parenthesis
                                            (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {

                                            // excess is a negative index
                                            match[0] = match[0].slice(0, excess);
                                            match[2] = unquoted.slice(0, excess);
                                        }

                                        // Return only captures needed by the pseudo filter method (type and argument)
                                        return match.slice(0, 3);
                                    }
                                },

                                filter: {

                                    'TAG': function (nodeNameSelector) {
                                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();

                                        return nodeNameSelector === '*' ?
                                            function () {
                                            return true;
                                        } :
                                            function (elem) {
                                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                            };
                                    },

                                    'CLASS': function (className) {
                                        var pattern = classCache[ className + ' ' ];

                                        return pattern ||
                                            (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) &&
                                            classCache(className, function (elem) {
                                                return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
                                            });
                                    },

                                    'ATTR': function (name, operator, check) {
                                        return function (elem) {
                                            var result = Sizzle.attr(elem, name);

                                            if (result == null) {
                                                return operator === '!=';
                                            }

                                            if (!operator) {
                                                return true;
                                            }

                                            result += '';

                                            return operator === '=' ? result === check :
                                                operator === '!=' ? result !== check :
                                                    operator === '^=' ? check && result.indexOf(check) === 0 :
                                                        operator === '*=' ? check && result.indexOf(check) > -1 :
                                                            operator === '$=' ? check && result.slice(-check.length) === check :
                                                                operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 :
                                                                    operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' :
                                                                        false;
                                        };
                                    },

                                    'CHILD': function (type, what, argument, first, last) {
                                        var simple = type.slice(0, 3) !== 'nth',
                                            forward = type.slice(-4) !== 'last',
                                            ofType = what === 'of-type';

                                        return first === 1 && last === 0 ?

                                            // Shortcut for :nth-*(n)
                                            function (elem) {
                                                return !!elem.parentNode;
                                            } :

                                            function (elem, context, xml) {
                                                var cache, outerCache, node, diff, nodeIndex, start,
                                                    dir = simple !== forward ? 'nextSibling' : 'previousSibling',
                                                    parent = elem.parentNode,
                                                    name = ofType && elem.nodeName.toLowerCase(),
                                                    useCache = !xml && !ofType;

                                                if (parent) {

                                                    // :(first|last|only)-(child|of-type)
                                                    if (simple) {
                                                        while (dir) {
                                                            node = elem;

                                                            while (node = node[ dir ]) {
                                                                if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                                    return false;
                                                                }
                                                            }
                                                            // Reverse direction for :only-* (if we haven't yet done so)
                                                            start = dir = type === 'only' && !start && 'nextSibling';
                                                        }

                                                        return true;
                                                    }

                                                    start = [forward ? parent.firstChild : parent.lastChild];

                                                    // non-xml :nth-child(...) stores cache data on `parent`
                                                    if (forward && useCache) {
                                                        // Seek `elem` from a previously-cached index
                                                        outerCache = parent[ expando ] || (parent[ expando ] = {});
                                                        cache = outerCache[ type ] || [];
                                                        nodeIndex = cache[0] === dirruns && cache[1];
                                                        diff = cache[0] === dirruns && cache[2];
                                                        node = nodeIndex && parent.childNodes[ nodeIndex ];

                                                        while (node = ++nodeIndex && node && node[ dir ] ||

                                                            // Fallback to seeking `elem` from the start
                                                        (diff = nodeIndex = 0) || start.pop()) {

                                                            // When found, cache indexes on `parent` and break
                                                            if (node.nodeType === 1 && ++diff && node === elem) {
                                                                outerCache[ type ] = [dirruns, nodeIndex, diff];
                                                                break;
                                                            }
                                                        }

                                                        // Use previously-cached element index if available
                                                    } else if (useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns) {
                                                        diff = cache[1];

                                                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                                    } else {
                                                        // Use the same loop as above to seek `elem` from the start
                                                        while (node = ++nodeIndex && node && node[ dir ] ||
                                                        (diff = nodeIndex = 0) || start.pop()) {

                                                            if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                                                // Cache the index of each encountered element
                                                                if (useCache) {
                                                                    (node[ expando ] || (node[ expando ] = {}))[ type ] = [dirruns, diff];
                                                                }

                                                                if (node === elem) {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }

                                                    // Incorporate the offset, then check against cycle size
                                                    diff -= last;

                                                    return diff === first ||  diff % first === 0 && diff / first >= 0;
                                                }
                                            };
                                    },

                                    'PSEUDO': function (pseudo, argument) {
                                        // pseudo-class names are case-insensitive
                                        // http://www.w3.org/TR/selectors/#pseudo-classes
                                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                        // Remember that setFilters inherits from pseudos
                                        var args,
                                            fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                                Sizzle.error('unsupported pseudo: ' + pseudo);

                                        // The user may use createPseudo to indicate that
                                        // arguments are needed to create the filter function
                                        // just as Sizzle does
                                        if (fn[ expando ]) {
                                            return fn(argument);
                                        }

                                        // But maintain support for old signatures
                                        if (fn.length > 1) {
                                            args = [pseudo, pseudo, '', argument];

                                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                                markFunction(function (seed, matches) {
                                                    var idx,
                                                        matched = fn(seed, argument),
                                                        i = matched.length;

                                                    while (i--) {
                                                        idx = indexOf(seed, matched[i]);
                                                        seed[ idx ] = !(matches[ idx ] = matched[i]);
                                                    }
                                                }) :
                                                function (elem) {
                                                    return fn(elem, 0, args);
                                                };
                                        }

                                        return fn;
                                    }
                                },

                                pseudos: {
                                    // Potentially complex pseudos
                                    'not': markFunction(function (selector) {
                                        // Trim the selector passed to compile
                                        // to avoid treating leading and trailing
                                        // spaces as combinators
                                        var input = [],
                                            results = [],
                                            matcher = compile(selector.replace(rtrim, '$1'));

                                        return matcher[ expando ] ?
                                            markFunction(function (seed, matches, context, xml) {
                                                var elem,
                                                    unmatched = matcher(seed, null, xml, []),
                                                    i = seed.length;

                                                // Match elements unmatched by `matcher`
                                                while (i--) {
                                                    if (elem = unmatched[i]) {
                                                        seed[i] = !(matches[i] = elem);
                                                    }
                                                }
                                            }) :
                                            function (elem, context, xml) {
                                                input[0] = elem;
                                                matcher(input, null, xml, results);
                                                // Don't keep the element (issue #299)
                                                input[0] = null;

                                                return !results.pop();
                                            };
                                    }),

                                    'has': markFunction(function (selector) {
                                        return function (elem) {
                                            return Sizzle(selector, elem).length > 0;
                                        };
                                    }),

                                    'contains': markFunction(function (text) {
                                        text = text.replace(runescape, funescape);

                                        return function (elem) {
                                            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                                        };
                                    }),

                                    // "Whether an element is represented by a :lang() selector
                                    // is based solely on the element's language value
                                    // being equal to the identifier C,
                                    // or beginning with the identifier C immediately followed by "-".
                                    // The matching of C against the element's language value is performed case-insensitively.
                                    // The identifier C does not have to be a valid language name."
                                    // http://www.w3.org/TR/selectors/#lang-pseudo
                                    'lang': markFunction(function (lang) {
                                        // lang value must be a valid identifier
                                        if (!ridentifier.test(lang || '')) {
                                            Sizzle.error('unsupported lang: ' + lang);
                                        }
                                        lang = lang.replace(runescape, funescape).toLowerCase();

                                        return function (elem) {
                                            var elemLang;

                                            do {
                                                if (elemLang = documentIsHTML ?
                                                        elem.lang :
                                                    elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {

                                                    elemLang = elemLang.toLowerCase();

                                                    return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                                                }
                                            } while ((elem = elem.parentNode) && elem.nodeType === 1);

                                            return false;
                                        };
                                    }),

                                    // Miscellaneous
                                    'target': function (elem) {
                                        var hash = window.location && window.location.hash;

                                        return hash && hash.slice(1) === elem.id;
                                    },

                                    'root': function (elem) {
                                        return elem === docElem;
                                    },

                                    'focus': function (elem) {
                                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                                    },

                                    // Boolean properties
                                    'enabled': function (elem) {
                                        return elem.disabled === false;
                                    },

                                    'disabled': function (elem) {
                                        return elem.disabled === true;
                                    },

                                    'checked': function (elem) {
                                        // In CSS3, :checked should return both checked and selected elements
                                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                        var nodeName = elem.nodeName.toLowerCase();

                                        return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                                    },

                                    'selected': function (elem) {
                                        // Accessing this property makes selected-by-default
                                        // options in Safari work properly
                                        if (elem.parentNode) {
                                            elem.parentNode.selectedIndex;
                                        }

                                        return elem.selected === true;
                                    },

                                    // Contents
                                    'empty': function (elem) {
                                        // http://www.w3.org/TR/selectors/#empty-pseudo
                                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                        //   but not by others (comment: 8; processing instruction: 7; etc.)
                                        // nodeType < 6 works because attributes (2) do not appear as children
                                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                            if (elem.nodeType < 6) {
                                                return false;
                                            }
                                        }

                                        return true;
                                    },

                                    'parent': function (elem) {
                                        return !Expr.pseudos['empty'](elem);
                                    },

                                    // Element/input types
                                    'header': function (elem) {
                                        return rheader.test(elem.nodeName);
                                    },

                                    'input': function (elem) {
                                        return rinputs.test(elem.nodeName);
                                    },

                                    'button': function (elem) {
                                        var name = elem.nodeName.toLowerCase();

                                        return name === 'input' && elem.type === 'button' || name === 'button';
                                    },

                                    'text': function (elem) {
                                        var attr;

                                        return elem.nodeName.toLowerCase() === 'input' &&
                                            elem.type === 'text' &&

                                                // Support: IE<8
                                                // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                            ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                                    },

                                    // Position-in-collection
                                    'first': createPositionalPseudo(function () {
                                        return [0];
                                    }),

                                    'last': createPositionalPseudo(function (matchIndexes, length) {
                                        return [length - 1];
                                    }),

                                    'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                                        return [argument < 0 ? argument + length : argument];
                                    }),

                                    'even': createPositionalPseudo(function (matchIndexes, length) {
                                        var i = 0;

                                        for (; i < length; i += 2) {
                                            matchIndexes.push(i);
                                        }

                                        return matchIndexes;
                                    }),

                                    'odd': createPositionalPseudo(function (matchIndexes, length) {
                                        var i = 1;

                                        for (; i < length; i += 2) {
                                            matchIndexes.push(i);
                                        }

                                        return matchIndexes;
                                    }),

                                    'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                                        var i = argument < 0 ? argument + length : argument;

                                        for (; --i >= 0;) {
                                            matchIndexes.push(i);
                                        }

                                        return matchIndexes;
                                    }),

                                    'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                                        var i = argument < 0 ? argument + length : argument;

                                        for (; ++i < length;) {
                                            matchIndexes.push(i);
                                        }

                                        return matchIndexes;
                                    })
                                }
                            };

                            Expr.pseudos['nth'] = Expr.pseudos['eq'];

                            // Add button/input type pseudos
                            for (i in {
                                radio: true, checkbox: true, file: true, password: true, image: true
                            }) {
                                Expr.pseudos[ i ] = createInputPseudo(i);
                            }

                            for (i in {
                                submit: true, reset: true
                            }) {
                                Expr.pseudos[ i ] = createButtonPseudo(i);
                            }

                            // Easy API for creating new setFilters
                            function setFilters() {}
                            setFilters.prototype = Expr.filters = Expr.pseudos;
                            Expr.setFilters = new setFilters();

                            tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                                var matched, match, tokens, type,
                                    soFar, groups, preFilters,
                                    cached = tokenCache[ selector + ' ' ];

                                if (cached) {
                                    return parseOnly ? 0 : cached.slice(0);
                                }

                                soFar = selector;
                                groups = [];
                                preFilters = Expr.preFilter;

                                while (soFar) {

                                    // Comma and first run
                                    if (!matched || (match = rcomma.exec(soFar))) {
                                        if (match) {
                                            // Don't consume trailing commas as valid
                                            soFar = soFar.slice(match[0].length) || soFar;
                                        }
                                        groups.push(tokens = []);
                                    }

                                    matched = false;

                                    // Combinators
                                    if (match = rcombinators.exec(soFar)) {
                                        matched = match.shift();
                                        tokens.push({
                                            value: matched,
                                            // Cast descendant combinators to space
                                            type: match[0].replace(rtrim, ' ')
                                        });
                                        soFar = soFar.slice(matched.length);
                                    }

                                    // Filters
                                    for (type in Expr.filter) {
                                        if ((match = matchExpr[ type ].exec(soFar)) && (!preFilters[ type ] ||
                                            (match = preFilters[ type ](match)))) {
                                            matched = match.shift();
                                            tokens.push({
                                                value: matched,
                                                type: type,
                                                matches: match
                                            });
                                            soFar = soFar.slice(matched.length);
                                        }
                                    }

                                    if (!matched) {
                                        break;
                                    }
                                }

                                // Return the length of the invalid excess
                                // if we're just parsing
                                // Otherwise, throw an error or return tokens
                                return parseOnly ?
                                    soFar.length :
                                    soFar ?
                                        Sizzle.error(selector) :
                                        // Cache the tokens
                                        tokenCache(selector, groups).slice(0);
                            };

                            function toSelector(tokens) {
                                var i = 0,
                                    len = tokens.length,
                                    selector = '';

                                for (; i < len; i++) {
                                    selector += tokens[i].value;
                                }

                                return selector;
                            }

                            function addCombinator(matcher, combinator, base) {
                                var dir = combinator.dir,
                                    checkNonElements = base && dir === 'parentNode',
                                    doneName = done++;

                                return combinator.first ?
                                    // Check against closest ancestor/preceding element
                                    function (elem, context, xml) {
                                        while (elem = elem[ dir ]) {
                                            if (elem.nodeType === 1 || checkNonElements) {
                                                return matcher(elem, context, xml);
                                            }
                                        }
                                    } :

                                    // Check against all ancestor/preceding elements
                                    function (elem, context, xml) {
                                        var oldCache, outerCache,
                                            newCache = [dirruns, doneName];

                                        // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                                        if (xml) {
                                            while (elem = elem[ dir ]) {
                                                if (elem.nodeType === 1 || checkNonElements) {
                                                    if (matcher(elem, context, xml)) {
                                                        return true;
                                                    }
                                                }
                                            }
                                        } else {
                                            while (elem = elem[ dir ]) {
                                                if (elem.nodeType === 1 || checkNonElements) {
                                                    outerCache = elem[ expando ] || (elem[ expando ] = {});

                                                    if ((oldCache = outerCache[ dir ]) &&
                                                        oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName) {

                                                        // Assign to newCache so results back-propagate to previous elements
                                                        return newCache[ 2 ] = oldCache[ 2 ];
                                                    }
                                                    // Reuse newcache so results back-propagate to previous elements
                                                    outerCache[ dir ] = newCache;

                                                    // A match means we're done; a fail means we have to keep checking
                                                    if (newCache[ 2 ] = matcher(elem, context, xml)) {
                                                        return true;
                                                    }

                                                }
                                            }
                                        }
                                    };
                            }

                            function elementMatcher(matchers) {
                                return matchers.length > 1 ?
                                    function (elem, context, xml) {
                                        var i = matchers.length;

                                        while (i--) {
                                            if (!matchers[i](elem, context, xml)) {
                                                return false;
                                            }
                                        }

                                        return true;
                                    } :
                                    matchers[0];
                            }

                            function multipleContexts(selector, contexts, results) {
                                var i = 0,
                                    len = contexts.length;

                                for (; i < len; i++) {
                                    Sizzle(selector, contexts[i], results);
                                }

                                return results;
                            }

                            function condense(unmatched, map, filter, context, xml) {
                                var elem,
                                    newUnmatched = [],
                                    i = 0,
                                    len = unmatched.length,
                                    mapped = map != null;

                                for (; i < len; i++) {
                                    if (elem = unmatched[i]) {
                                        if (!filter || filter(elem, context, xml)) {
                                            newUnmatched.push(elem);

                                            if (mapped) {
                                                map.push(i);
                                            }
                                        }
                                    }
                                }

                                return newUnmatched;
                            }

                            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                                if (postFilter && !postFilter[ expando ]) {
                                    postFilter = setMatcher(postFilter);
                                }

                                if (postFinder && !postFinder[ expando ]) {
                                    postFinder = setMatcher(postFinder, postSelector);
                                }

                                return markFunction(function (seed, results, context, xml) {
                                    var temp, i, elem,
                                        preMap = [],
                                        postMap = [],
                                        preexisting = results.length,

                                    // Get initial elements from seed or context
                                        elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),

                                    // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                        matcherIn = preFilter && (seed || !selector) ?
                                            condense(elems, preMap, preFilter, context, xml) :
                                            elems,

                                        matcherOut = matcher ?
                                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                            postFinder || (seed ? preFilter : preexisting || postFilter) ?

                                                // ...intermediate processing is necessary
                                                [] :

                                                // ...otherwise use results directly
                                                results :
                                            matcherIn;

                                    // Find primary matches
                                    if (matcher) {
                                        matcher(matcherIn, matcherOut, context, xml);
                                    }

                                    // Apply postFilter
                                    if (postFilter) {
                                        temp = condense(matcherOut, postMap);
                                        postFilter(temp, [], context, xml);

                                        // Un-match failing elements by moving them back to matcherIn
                                        i = temp.length;

                                        while (i--) {
                                            if (elem = temp[i]) {
                                                matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                                            }
                                        }
                                    }

                                    if (seed) {
                                        if (postFinder || preFilter) {
                                            if (postFinder) {
                                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                                temp = [];
                                                i = matcherOut.length;

                                                while (i--) {
                                                    if (elem = matcherOut[i]) {
                                                        // Restore matcherIn since elem is not yet a final match
                                                        temp.push(matcherIn[i] = elem);
                                                    }
                                                }
                                                postFinder(null, matcherOut = [], temp, xml);
                                            }

                                            // Move matched elements from seed to results to keep them synchronized
                                            i = matcherOut.length;

                                            while (i--) {
                                                if ((elem = matcherOut[i]) &&
                                                    (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                                    seed[temp] = !(results[temp] = elem);
                                                }
                                            }
                                        }

                                        // Add elements to results, through postFinder if defined
                                    } else {
                                        matcherOut = condense(
                                            matcherOut === results ?
                                                matcherOut.splice(preexisting, matcherOut.length) :
                                                matcherOut
                                        );

                                        if (postFinder) {
                                            postFinder(null, results, matcherOut, xml);
                                        } else {
                                            push.apply(results, matcherOut);
                                        }
                                    }
                                });
                            }

                            function matcherFromTokens(tokens) {
                                var checkContext, matcher, j,
                                    len = tokens.length,
                                    leadingRelative = Expr.relative[ tokens[0].type ],
                                    implicitRelative = leadingRelative || Expr.relative[' '],
                                    i = leadingRelative ? 1 : 0,

                                // The foundational matcher ensures that elements are reachable from top-level context(s)
                                    matchContext = addCombinator(function (elem) {
                                        return elem === checkContext;
                                    }, implicitRelative, true),
                                    matchAnyContext = addCombinator(function (elem) {
                                        return indexOf(checkContext, elem) > -1;
                                    }, implicitRelative, true),
                                    matchers = [function (elem, context, xml) {
                                        var ret =  !leadingRelative && (xml || context !== outermostContext)  || (
                                                (checkContext = context).nodeType ?
                                                    matchContext(elem, context, xml) :
                                                    matchAnyContext(elem, context, xml));
                                        // Avoid hanging onto element (issue #299)

                                        checkContext = null;

                                        return ret;
                                    }];

                                for (; i < len; i++) {
                                    if (matcher = Expr.relative[ tokens[i].type ]) {
                                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                                    } else {
                                        matcher = Expr.filter[ tokens[i].type ].apply(null, tokens[i].matches);

                                        // Return special upon seeing a positional matcher
                                        if (matcher[ expando ]) {
                                            // Find the next relative operator (if any) for proper handling
                                            j = ++i;

                                            for (; j < len; j++) {
                                                if (Expr.relative[ tokens[j].type ]) {
                                                    break;
                                                }
                                            }

                                            return setMatcher(
                                                i > 1 && elementMatcher(matchers),
                                                i > 1 && toSelector(
                                                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                                    tokens.slice(0, i - 1).concat({
                                                value: tokens[ i - 2 ].type === ' ' ? '*' : ''
                                            })
                                                ).replace(rtrim, '$1'),
                                                matcher,
                                                i < j && matcherFromTokens(tokens.slice(i, j)),
                                                j < len && matcherFromTokens(tokens = tokens.slice(j)),
                                                j < len && toSelector(tokens)
                                            );
                                        }
                                        matchers.push(matcher);
                                    }
                                }

                                return elementMatcher(matchers);
                            }

                            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                                var bySet = setMatchers.length > 0,
                                    byElement = elementMatchers.length > 0,
                                    superMatcher = function (seed, context, xml, results, outermost) {
                                        var elem, j, matcher,
                                            matchedCount = 0,
                                            i = '0',
                                            unmatched = seed && [],
                                            setMatched = [],
                                            contextBackup = outermostContext,
                                        // We must always have either seed elements or outermost context
                                            elems = seed || byElement && Expr.find['TAG']('*', outermost),
                                        // Use integer dirruns iff this is the outermost matcher
                                            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
                                            len = elems.length;

                                        if (outermost) {
                                            outermostContext = context !== document && context;
                                        }

                                        // Add elements passing elementMatchers directly to results
                                        // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                                        // Support: IE<9, Safari
                                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                        for (; i !== len && (elem = elems[i]) != null; i++) {
                                            if (byElement && elem) {
                                                j = 0;

                                                while (matcher = elementMatchers[j++]) {
                                                    if (matcher(elem, context, xml)) {
                                                        results.push(elem);
                                                        break;
                                                    }
                                                }

                                                if (outermost) {
                                                    dirruns = dirrunsUnique;
                                                }
                                            }

                                            // Track unmatched elements for set filters
                                            if (bySet) {
                                                // They will have gone through all possible matchers
                                                if (elem = !matcher && elem) {
                                                    matchedCount--;
                                                }

                                                // Lengthen the array for every element, matched or not
                                                if (seed) {
                                                    unmatched.push(elem);
                                                }
                                            }
                                        }

                                        // Apply set filters to unmatched elements
                                        matchedCount += i;

                                        if (bySet && i !== matchedCount) {
                                            j = 0;

                                            while (matcher = setMatchers[j++]) {
                                                matcher(unmatched, setMatched, context, xml);
                                            }

                                            if (seed) {
                                                // Reintegrate element matches to eliminate the need for sorting
                                                if (matchedCount > 0) {
                                                    while (i--) {
                                                        if (!(unmatched[i] || setMatched[i])) {
                                                            setMatched[i] = pop.call(results);
                                                        }
                                                    }
                                                }

                                                // Discard index placeholder values to get only actual matches
                                                setMatched = condense(setMatched);
                                            }

                                            // Add matches to results
                                            push.apply(results, setMatched);

                                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                            if (outermost && !seed && setMatched.length > 0 &&
                                                 matchedCount + setMatchers.length  > 1) {

                                                Sizzle.uniqueSort(results);
                                            }
                                        }

                                        // Override manipulation of globals by nested matchers
                                        if (outermost) {
                                            dirruns = dirrunsUnique;
                                            outermostContext = contextBackup;
                                        }

                                        return unmatched;
                                    };

                                return bySet ?
                                    markFunction(superMatcher) :
                                    superMatcher;
                            }

                            compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
                                var i,
                                    setMatchers = [],
                                    elementMatchers = [],
                                    cached = compilerCache[ selector + ' ' ];

                                if (!cached) {
                                    // Generate a function of recursive functions that can be used to check each element
                                    if (!match) {
                                        match = tokenize(selector);
                                    }
                                    i = match.length;

                                    while (i--) {
                                        cached = matcherFromTokens(match[i]);

                                        if (cached[ expando ]) {
                                            setMatchers.push(cached);
                                        } else {
                                            elementMatchers.push(cached);
                                        }
                                    }

                                    // Cache the compiled function
                                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                                    // Save selector and tokenization
                                    cached.selector = selector;
                                }

                                return cached;
                            };

                            /**
                             * A low-level selection function that works with Sizzle's compiled
                             *  selector functions
                             * @param {String|Function} selector A selector or a pre-compiled
                             *  selector function built with Sizzle.compile
                             * @param {Element} context
                             * @param {Array} [results]
                             * @param {Array} [seed] A set of elements to match against
                             */
                            select = Sizzle.select = function (selector, context, results, seed) {
                                var i, tokens, token, type, find,
                                    compiled = typeof selector === 'function' && selector,
                                    match = !seed && tokenize(selector = compiled.selector || selector);

                                results = results || [];

                                // Try to minimize operations if there is no seed and only one group
                                if (match.length === 1) {

                                    // Take a shortcut and set the context if the root selector is an ID
                                    tokens = match[0] = match[0].slice(0);

                                    if (tokens.length > 2 && (token = tokens[0]).type === 'ID' &&
                                        support.getById && context.nodeType === 9 && documentIsHTML &&
                                        Expr.relative[ tokens[1].type ]) {

                                        context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];

                                        if (!context) {
                                            return results;

                                            // Precompiled matchers will still verify ancestry, so step up a level
                                        } else if (compiled) {
                                            context = context.parentNode;
                                        }

                                        selector = selector.slice(tokens.shift().value.length);
                                    }

                                    // Fetch a seed set for right-to-left matching
                                    i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;

                                    while (i--) {
                                        token = tokens[i];

                                        // Abort if we hit a combinator
                                        if (Expr.relative[ type = token.type ]) {
                                            break;
                                        }

                                        if (find = Expr.find[ type ]) {
                                            // Search, expanding context for leading sibling combinators
                                            if (seed = find(
                                                    token.matches[0].replace(runescape, funescape),
                                                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                                                )) {

                                                // If seed is empty or no tokens remain, we can return early
                                                tokens.splice(i, 1);
                                                selector = seed.length && toSelector(tokens);

                                                if (!selector) {
                                                    push.apply(results, seed);

                                                    return results;
                                                }

                                                break;
                                            }
                                        }
                                    }
                                }

                                // Compile and execute a filtering function if one is not provided
                                // Provide `match` to avoid retokenization if we modified the selector above
                                (compiled || compile(selector, match))(
                                    seed,
                                    context,
                                    !documentIsHTML,
                                    results,
                                    rsibling.test(selector) && testContext(context.parentNode) || context
                                );

                                return results;
                            };

                            // One-time assignments

                            // Sort stability
                            support.sortStable = expando.split('').sort(sortOrder).join('') === expando;

                            // Support: Chrome 14-35+
                            // Always assume duplicates if they aren't passed to the comparison function
                            support.detectDuplicates = !!hasDuplicate;

                            // Initialize against the default document
                            setDocument();

                            // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                            // Detached nodes confoundingly follow *each other*
                            support.sortDetached = assert(function (div1) {
                                // Should return 1, but returns 4 (following)
                                return div1.compareDocumentPosition(document.createElement('div')) & 1;
                            });

                            // Support: IE<8
                            // Prevent attribute/property "interpolation"
                            // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                            if (!assert(function (div) {
                                    div.innerHTML = '<a href=\'#\'></a>';

                                    return div.firstChild.getAttribute('href') === '#';
                                })) {
                                addHandle('type|href|height|width', function (elem, name, isXML) {
                                    if (!isXML) {
                                        return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                                    }
                                });
                            }

                            // Support: IE<9
                            // Use defaultValue in place of getAttribute("value")
                            if (!support.attributes || !assert(function (div) {
                                    div.innerHTML = '<input/>';
                                    div.firstChild.setAttribute('value', '');

                                    return div.firstChild.getAttribute('value') === '';
                                })) {
                                addHandle('value', function (elem, name, isXML) {
                                    if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                                        return elem.defaultValue;
                                    }
                                });
                            }

                            // Support: IE<9
                            // Use getAttributeNode to fetch booleans when getAttribute lies
                            if (!assert(function (div) {
                                    return div.getAttribute('disabled') == null;
                                })) {
                                addHandle(booleans, function (elem, name, isXML) {
                                    var val;

                                    if (!isXML) {
                                        return elem[ name ] === true ? name.toLowerCase() :
                                            (val = elem.getAttributeNode(name)) && val.specified ?
                                                val.value :
                                                null;
                                    }
                                });
                            }

                            return Sizzle;

                        })(window);

                    jQuery.find = Sizzle;
                    jQuery.expr = Sizzle.selectors;
                    jQuery.expr[':'] = jQuery.expr.pseudos;
                    jQuery.unique = Sizzle.uniqueSort;
                    jQuery.text = Sizzle.getText;
                    jQuery.isXMLDoc = Sizzle.isXML;
                    jQuery.contains = Sizzle.contains;

                    var rneedsContext = jQuery.expr.match.needsContext;

                    var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);

                    var risSimple = /^.[^:#\[\.,]*$/;

                    // Implement the identical functionality for filter and not
                    function winnow(elements, qualifier, not) {
                        if (jQuery.isFunction(qualifier)) {
                            return jQuery.grep(elements, function (elem, i) {
                                /* jshint -W018 */
                                return !!qualifier.call(elem, i, elem) !== not;
                            });

                        }

                        if (qualifier.nodeType) {
                            return jQuery.grep(elements, function (elem) {
                                return elem === qualifier  !== not;
                            });

                        }

                        if (typeof qualifier === 'string') {
                            if (risSimple.test(qualifier)) {
                                return jQuery.filter(qualifier, elements, not);
                            }

                            qualifier = jQuery.filter(qualifier, elements);
                        }

                        return jQuery.grep(elements, function (elem) {
                            return indexOf.call(qualifier, elem) >= 0  !== not;
                        });
                    }

                    jQuery.filter = function (expr, elems, not) {
                        var elem = elems[ 0 ];

                        if (not) {
                            expr = ':not(' + expr + ')';
                        }

                        return elems.length === 1 && elem.nodeType === 1 ?
                            jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
                            jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                                return elem.nodeType === 1;
                            }));
                    };

                    jQuery.fn.extend({
                        find: function (selector) {
                            var i,
                                len = this.length,
                                ret = [],
                                self = this;

                            if (typeof selector !== 'string') {
                                return this.pushStack(jQuery(selector).filter(function () {
                                    for (i = 0; i < len; i++) {
                                        if (jQuery.contains(self[ i ], this)) {
                                            return true;
                                        }
                                    }
                                }));
                            }

                            for (i = 0; i < len; i++) {
                                jQuery.find(selector, self[ i ], ret);
                            }

                            // Needed because $( selector, context ) becomes $( context ).find( selector )
                            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                            ret.selector = this.selector ? this.selector + ' ' + selector : selector;

                            return ret;
                        },
                        filter: function (selector) {
                            return this.pushStack(winnow(this, selector || [], false));
                        },
                        not: function (selector) {
                            return this.pushStack(winnow(this, selector || [], true));
                        },
                        is: function (selector) {
                            return !!winnow(
                                this,

                                // If this is a positional/relative selector, check membership in the returned set
                                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                                typeof selector === 'string' && rneedsContext.test(selector) ?
                                    jQuery(selector) :
                                selector || [],
                                false
                            ).length;
                        }
                    });


                    // Initialize a jQuery object


                    // A central reference to the root jQuery(document)
                    var rootjQuery,

                    // A simple way to check for HTML strings
                    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
                    // Strict HTML recognition (#11290: must start with <)
                        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

                        init = jQuery.fn.init = function (selector, context) {
                            var match, elem;

                            // HANDLE: $(""), $(null), $(undefined), $(false)
                            if (!selector) {
                                return this;
                            }

                            // Handle HTML strings
                            if (typeof selector === 'string') {
                                if (selector[0] === '<' && selector[ selector.length - 1 ] === '>' && selector.length >= 3) {
                                    // Assume that strings that start and end with <> are HTML and skip the regex check
                                    match = [null, selector, null];

                                } else {
                                    match = rquickExpr.exec(selector);
                                }

                                // Match html or make sure no context is specified for #id
                                if (match && (match[1] || !context)) {

                                    // HANDLE: $(html) -> $(array)
                                    if (match[1]) {
                                        context = context instanceof jQuery ? context[0] : context;

                                        // Option to run scripts is true for back-compat
                                        // Intentionally let the error be thrown if parseHTML is not present
                                        jQuery.merge(this, jQuery.parseHTML(
                                            match[1],
                                            context && context.nodeType ? context.ownerDocument || context : document,
                                            true
                                        ));

                                        // HANDLE: $(html, props)
                                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                            for (match in context) {
                                                // Properties of context are called as methods if possible
                                                if (jQuery.isFunction(this[ match ])) {
                                                    this[ match ](context[ match ]);

                                                    // ...and otherwise set as attributes
                                                } else {
                                                    this.attr(match, context[ match ]);
                                                }
                                            }
                                        }

                                        return this;

                                        // HANDLE: $(#id)
                                    }
                                    elem = document.getElementById(match[2]);

                                    // Support: Blackberry 4.6
                                    // gEBID returns nodes no longer in the document (#6963)
                                    if (elem && elem.parentNode) {
                                        // Inject the element directly into the jQuery object
                                        this.length = 1;
                                        this[0] = elem;
                                    }

                                    this.context = document;
                                    this.selector = selector;

                                    return this;


                                    // HANDLE: $(expr, $(...))
                                } else if (!context || context.jquery) {
                                    return (context || rootjQuery).find(selector);

                                    // HANDLE: $(expr, context)
                                    // (which is just equivalent to: $(context).find(expr)
                                }

                                return this.constructor(context).find(selector);


                                // HANDLE: $(DOMElement)
                            } else if (selector.nodeType) {
                                this.context = this[0] = selector;
                                this.length = 1;

                                return this;

                                // HANDLE: $(function)
                                // Shortcut for document ready
                            } else if (jQuery.isFunction(selector)) {
                                return typeof rootjQuery.ready !== 'undefined' ?
                                    rootjQuery.ready(selector) :
                                    // Execute immediately if ready is not present
                                    selector(jQuery);
                            }

                            if (selector.selector !== undefined) {
                                this.selector = selector.selector;
                                this.context = selector.context;
                            }

                            return jQuery.makeArray(selector, this);
                        };

                    // Give the init function the jQuery prototype for later instantiation
                    init.prototype = jQuery.fn;

                    // Initialize central reference
                    rootjQuery = jQuery(document);

                    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
                    // Methods guaranteed to produce a unique set when starting from a unique set
                        guaranteedUnique = {
                            children: true,
                            contents: true,
                            next: true,
                            prev: true
                        };

                    jQuery.extend({
                        dir: function (elem, dir, until) {
                            var matched = [],
                                truncate = until !== undefined;

                            while ((elem = elem[ dir ]) && elem.nodeType !== 9) {
                                if (elem.nodeType === 1) {
                                    if (truncate && jQuery(elem).is(until)) {
                                        break;
                                    }
                                    matched.push(elem);
                                }
                            }

                            return matched;
                        },

                        sibling: function (n, elem) {
                            var matched = [];

                            for (; n; n = n.nextSibling) {
                                if (n.nodeType === 1 && n !== elem) {
                                    matched.push(n);
                                }
                            }

                            return matched;
                        }
                    });

                    jQuery.fn.extend({
                        has: function (target) {
                            var targets = jQuery(target, this),
                                l = targets.length;

                            return this.filter(function () {
                                var i = 0;

                                for (; i < l; i++) {
                                    if (jQuery.contains(this, targets[i])) {
                                        return true;
                                    }
                                }
                            });
                        },

                        closest: function (selectors, context) {
                            var cur,
                                i = 0,
                                l = this.length,
                                matched = [],
                                pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ?
                                    jQuery(selectors, context || this.context) :
                                    0;

                            for (; i < l; i++) {
                                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                                    // Always skip document fragments
                                    if (cur.nodeType < 11 && (pos ?
                                        pos.index(cur) > -1 :

                                            // Don't pass non-elements to Sizzle
                                        cur.nodeType === 1 &&
                                        jQuery.find.matchesSelector(cur, selectors))) {

                                        matched.push(cur);
                                        break;
                                    }
                                }
                            }

                            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
                        },

                        // Determine the position of an element within the set
                        index: function (elem) {

                            // No argument, return index in parent
                            if (!elem) {
                                return this[ 0 ] && this[ 0 ].parentNode  ? this.first().prevAll().length : -1;
                            }

                            // Index in selector
                            if (typeof elem === 'string') {
                                return indexOf.call(jQuery(elem), this[ 0 ]);
                            }

                            // Locate the position of the desired element
                            return indexOf.call(this,

                                // If it receives a jQuery object, the first element is used
                                elem.jquery ? elem[ 0 ] : elem
                            );
                        },

                        add: function (selector, context) {
                            return this.pushStack(
                                jQuery.unique(
                                    jQuery.merge(this.get(), jQuery(selector, context))
                                )
                            );
                        },

                        addBack: function (selector) {
                            return this.add(selector == null ?
                                    this.prevObject : this.prevObject.filter(selector)
                            );
                        }
                    });

                    function sibling(cur, dir) {
                        while ((cur = cur[dir]) && cur.nodeType !== 1) {}

                        return cur;
                    }

                    jQuery.each({
                        parent: function (elem) {
                            var parent = elem.parentNode;

                            return parent && parent.nodeType !== 11 ? parent : null;
                        },
                        parents: function (elem) {
                            return jQuery.dir(elem, 'parentNode');
                        },
                        parentsUntil: function (elem, i, until) {
                            return jQuery.dir(elem, 'parentNode', until);
                        },
                        next: function (elem) {
                            return sibling(elem, 'nextSibling');
                        },
                        prev: function (elem) {
                            return sibling(elem, 'previousSibling');
                        },
                        nextAll: function (elem) {
                            return jQuery.dir(elem, 'nextSibling');
                        },
                        prevAll: function (elem) {
                            return jQuery.dir(elem, 'previousSibling');
                        },
                        nextUntil: function (elem, i, until) {
                            return jQuery.dir(elem, 'nextSibling', until);
                        },
                        prevUntil: function (elem, i, until) {
                            return jQuery.dir(elem, 'previousSibling', until);
                        },
                        siblings: function (elem) {
                            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
                        },
                        children: function (elem) {
                            return jQuery.sibling(elem.firstChild);
                        },
                        contents: function (elem) {
                            return elem.contentDocument || jQuery.merge([], elem.childNodes);
                        }
                    }, function (name, fn) {
                        jQuery.fn[ name ] = function (until, selector) {
                            var matched = jQuery.map(this, fn, until);

                            if (name.slice(-5) !== 'Until') {
                                selector = until;
                            }

                            if (selector && typeof selector === 'string') {
                                matched = jQuery.filter(selector, matched);
                            }

                            if (this.length > 1) {
                                // Remove duplicates
                                if (!guaranteedUnique[ name ]) {
                                    jQuery.unique(matched);
                                }

                                // Reverse order for parents* and prev-derivatives
                                if (rparentsprev.test(name)) {
                                    matched.reverse();
                                }
                            }

                            return this.pushStack(matched);
                        };
                    });
                    var rnotwhite = (/\S+/g);



                    // String to Object options format cache
                    var optionsCache = {};

                    // Convert String-formatted options into Object-formatted ones and store in cache
                    function createOptions(options) {
                        var object = optionsCache[ options ] = {};

                        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
                            object[ flag ] = true;
                        });

                        return object;
                    }

                    /*
                     * Create a callback list using the following parameters:
                     *
                     *	options: an optional list of space-separated options that will change how
                     *			the callback list behaves or a more traditional option object
                     *
                     * By default a callback list will act like an event callback list and can be
                     * "fired" multiple times.
                     *
                     * Possible options:
                     *
                     *	once:			will ensure the callback list can only be fired once (like a Deferred)
                     *
                     *	memory:			will keep track of previous values and will call any callback added
                     *					after the list has been fired right away with the latest "memorized"
                     *					values (like a Deferred)
                     *
                     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
                     *
                     *	stopOnFalse:	interrupt callings when a callback returns false
                     *
                     */
                    jQuery.Callbacks = function (options) {

                        // Convert options from String-formatted to Object-formatted if needed
                        // (we check in cache first)
                        options = typeof options === 'string' ?
                             optionsCache[ options ] || createOptions(options)  :
                            jQuery.extend({}, options);

                        var // Last fire value (for non-forgettable lists)
                            memory,
                        // Flag to know if list was already fired
                            fired,
                        // Flag to know if list is currently firing
                            firing,
                        // First callback to fire (used internally by add and fireWith)
                            firingStart,
                        // End of the loop when firing
                            firingLength,
                        // Index of currently firing callback (modified by remove if needed)
                            firingIndex,
                        // Actual callback list
                            list = [],
                        // Stack of fire calls for repeatable lists
                            stack = !options.once && [],
                        // Fire callbacks
                            fire = function (data) {
                                memory = options.memory && data;
                                fired = true;
                                firingIndex = firingStart || 0;
                                firingStart = 0;
                                firingLength = list.length;
                                firing = true;

                                for (; list && firingIndex < firingLength; firingIndex++) {
                                    if (list[ firingIndex ].apply(data[ 0 ], data[ 1 ]) === false && options.stopOnFalse) {
                                        memory = false; // To prevent further calls using add
                                        break;
                                    }
                                }
                                firing = false;

                                if (list) {
                                    if (stack) {
                                        if (stack.length) {
                                            fire(stack.shift());
                                        }
                                    } else if (memory) {
                                        list = [];
                                    } else {
                                        self.disable();
                                    }
                                }
                            },
                        // Actual Callbacks object
                            self = {
                                // Add a callback or a collection of callbacks to the list
                                add: function () {
                                    if (list) {
                                        // First, we save the current length
                                        var start = list.length;

                                        (function add(args) {
                                            jQuery.each(args, function (_, arg) {
                                                var type = jQuery.type(arg);

                                                if (type === 'function') {
                                                    if (!options.unique || !self.has(arg)) {
                                                        list.push(arg);
                                                    }
                                                } else if (arg && arg.length && type !== 'string') {
                                                    // Inspect recursively
                                                    add(arg);
                                                }
                                            });
                                        })(arguments);
                                        // Do we need to add the callbacks to the
                                        // current firing batch?
                                        if (firing) {
                                            firingLength = list.length;
                                            // With memory, if we're not firing then
                                            // we should call right away
                                        } else if (memory) {
                                            firingStart = start;
                                            fire(memory);
                                        }
                                    }

                                    return this;
                                },
                                // Remove a callback from the list
                                remove: function () {
                                    if (list) {
                                        jQuery.each(arguments, function (_, arg) {
                                            var index;

                                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                                list.splice(index, 1);
                                                // Handle firing indexes
                                                if (firing) {
                                                    if (index <= firingLength) {
                                                        firingLength--;
                                                    }

                                                    if (index <= firingIndex) {
                                                        firingIndex--;
                                                    }
                                                }
                                            }
                                        });
                                    }

                                    return this;
                                },
                                // Check if a given callback is in the list.
                                // If no argument is given, return whether or not list has callbacks attached.
                                has: function (fn) {
                                    return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                                },
                                // Remove all callbacks from the list
                                empty: function () {
                                    list = [];
                                    firingLength = 0;

                                    return this;
                                },
                                // Have the list do nothing anymore
                                disable: function () {
                                    list = stack = memory = undefined;

                                    return this;
                                },
                                // Is it disabled?
                                disabled: function () {
                                    return !list;
                                },
                                // Lock the list in its current state
                                lock: function () {
                                    stack = undefined;

                                    if (!memory) {
                                        self.disable();
                                    }

                                    return this;
                                },
                                // Is it locked?
                                locked: function () {
                                    return !stack;
                                },
                                // Call all callbacks with the given context and arguments
                                fireWith: function (context, args) {
                                    if (list && (!fired || stack)) {
                                        args = args || [];
                                        args = [context, args.slice ? args.slice() : args];

                                        if (firing) {
                                            stack.push(args);
                                        } else {
                                            fire(args);
                                        }
                                    }

                                    return this;
                                },
                                // Call all the callbacks with the given arguments
                                fire: function () {
                                    self.fireWith(this, arguments);

                                    return this;
                                },
                                // To know if the callbacks have already been called at least once
                                fired: function () {
                                    return !!fired;
                                }
                            };

                        return self;
                    };

                    jQuery.extend({

                        Deferred: function (func) {
                            var tuples = [
                                    // action, add listener, listener list, final state
                                    ['resolve', 'done', jQuery.Callbacks('once memory'), 'resolved'],
                                    ['reject', 'fail', jQuery.Callbacks('once memory'), 'rejected'],
                                    ['notify', 'progress', jQuery.Callbacks('memory')]
                                ],
                                state = 'pending',
                                promise = {
                                    state: function () {
                                        return state;
                                    },
                                    always: function () {
                                        deferred.done(arguments).fail(arguments);

                                        return this;
                                    },
                                    then: function ( /* fnDone, fnFail, fnProgress */) {
                                        var fns = arguments;

                                        return jQuery.Deferred(function (newDefer) {
                                            jQuery.each(tuples, function (i, tuple) {
                                                var fn = jQuery.isFunction(fns[ i ]) && fns[ i ];
                                                // deferred[ done | fail | progress ] for forwarding actions to newDefer

                                                deferred[ tuple[1] ](function () {
                                                    var returned = fn && fn.apply(this, arguments);

                                                    if (returned && jQuery.isFunction(returned.promise)) {
                                                        returned.promise()
                                                            .done(newDefer.resolve)
                                                            .fail(newDefer.reject)
                                                            .progress(newDefer.notify);
                                                    } else {
                                                        newDefer[ tuple[ 0 ] + 'With' ](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                                    }
                                                });
                                            });
                                            fns = null;
                                        }).promise();
                                    },
                                    // Get a promise for this deferred
                                    // If obj is provided, the promise aspect is added to the object
                                    promise: function (obj) {
                                        return obj != null ? jQuery.extend(obj, promise) : promise;
                                    }
                                },
                                deferred = {};

                            // Keep pipe for back-compat
                            promise.pipe = promise.then;

                            // Add list-specific methods
                            jQuery.each(tuples, function (i, tuple) {
                                var list = tuple[ 2 ],
                                    stateString = tuple[ 3 ];

                                // promise[ done | fail | progress ] = list.add
                                promise[ tuple[1] ] = list.add;

                                // Handle state
                                if (stateString) {
                                    list.add(function () {
                                        // state = [ resolved | rejected ]
                                        state = stateString;

                                        // [ reject_list | resolve_list ].disable; progress_list.lock
                                    }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock);
                                }

                                // deferred[ resolve | reject | notify ]
                                deferred[ tuple[0] ] = function () {
                                    deferred[ tuple[0] + 'With' ](this === deferred ? promise : this, arguments);

                                    return this;
                                };
                                deferred[ tuple[0] + 'With' ] = list.fireWith;
                            });

                            // Make the deferred a promise
                            promise.promise(deferred);

                            // Call given func if any
                            if (func) {
                                func.call(deferred, deferred);
                            }

                            // All done!
                            return deferred;
                        },

                        // Deferred helper
                        when: function (subordinate /* , ..., subordinateN */) {
                            var i = 0,
                                resolveValues = slice.call(arguments),
                                length = resolveValues.length,

                            // the count of uncompleted subordinates
                                remaining = length !== 1 ||  subordinate && jQuery.isFunction(subordinate.promise)  ? length : 0,

                            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                            // Update function for both resolve and progress values
                                updateFunc = function (i, contexts, values) {
                                    return function (value) {
                                        contexts[ i ] = this;
                                        values[ i ] = arguments.length > 1 ? slice.call(arguments) : value;

                                        if (values === progressValues) {
                                            deferred.notifyWith(contexts, values);
                                        } else if (!--remaining) {
                                            deferred.resolveWith(contexts, values);
                                        }
                                    };
                                },

                                progressValues, progressContexts, resolveContexts;

                            // Add listeners to Deferred subordinates; treat others as resolved
                            if (length > 1) {
                                progressValues = new Array(length);
                                progressContexts = new Array(length);
                                resolveContexts = new Array(length);

                                for (; i < length; i++) {
                                    if (resolveValues[ i ] && jQuery.isFunction(resolveValues[ i ].promise)) {
                                        resolveValues[ i ].promise()
                                            .done(updateFunc(i, resolveContexts, resolveValues))
                                            .fail(deferred.reject)
                                            .progress(updateFunc(i, progressContexts, progressValues));
                                    } else {
                                        --remaining;
                                    }
                                }
                            }

                            // If we're not waiting on anything, resolve the master
                            if (!remaining) {
                                deferred.resolveWith(resolveContexts, resolveValues);
                            }

                            return deferred.promise();
                        }
                    });


                    // The deferred used on DOM ready
                    var readyList;

                    jQuery.fn.ready = function (fn) {
                        // Add the callback
                        jQuery.ready.promise().done(fn);

                        return this;
                    };

                    jQuery.extend({
                        // Is the DOM ready to be used? Set to true once it occurs.
                        isReady: false,

                        // A counter to track how many items to wait for before
                        // the ready event fires. See #6781
                        readyWait: 1,

                        // Hold (or release) the ready event
                        holdReady: function (hold) {
                            if (hold) {
                                jQuery.readyWait++;
                            } else {
                                jQuery.ready(true);
                            }
                        },

                        // Handle when the DOM is ready
                        ready: function (wait) {

                            // Abort if there are pending holds or we're already ready
                            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                                return;
                            }

                            // Remember that the DOM is ready
                            jQuery.isReady = true;

                            // If a normal DOM Ready event fired, decrement, and wait if need be
                            if (wait !== true && --jQuery.readyWait > 0) {
                                return;
                            }

                            // If there are functions bound, to execute
                            readyList.resolveWith(document, [jQuery]);

                            // Trigger any bound ready events
                            if (jQuery.fn.triggerHandler) {
                                jQuery(document).triggerHandler('ready');
                                jQuery(document).off('ready');
                            }
                        }
                    });

                    /**
                     * The ready event handler and self cleanup method
                     */
                    function completed() {
                        document.removeEventListener('DOMContentLoaded', completed, false);
                        window.removeEventListener('load', completed, false);
                        jQuery.ready();
                    }

                    jQuery.ready.promise = function (obj) {
                        if (!readyList) {

                            readyList = jQuery.Deferred();

                            // Catch cases where $(document).ready() is called after the browser event has already occurred.
                            // We once tried to use readyState "interactive" here, but it caused issues like the one
                            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
                            if (document.readyState === 'complete') {
                                // Handle it asynchronously to allow scripts the opportunity to delay ready
                                setTimeout(jQuery.ready);

                            } else {

                                // Use the handy event callback
                                document.addEventListener('DOMContentLoaded', completed, false);

                                // A fallback to window.onload, that will always work
                                window.addEventListener('load', completed, false);
                            }
                        }

                        return readyList.promise(obj);
                    };

                    // Kick off the DOM ready check even if the user does not
                    jQuery.ready.promise();




                    // Multifunctional method to get and set values of a collection
                    // The value/s can optionally be executed if it's a function
                    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
                        var i = 0,
                            len = elems.length,
                            bulk = key == null;

                        // Sets many values
                        if (jQuery.type(key) === 'object') {
                            chainable = true;

                            for (i in key) {
                                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
                            }

                            // Sets one value
                        } else if (value !== undefined) {
                            chainable = true;

                            if (!jQuery.isFunction(value)) {
                                raw = true;
                            }

                            if (bulk) {
                                // Bulk operations run against the entire set
                                if (raw) {
                                    fn.call(elems, value);
                                    fn = null;

                                    // ...except when executing function values
                                } else {
                                    bulk = fn;
                                    fn = function (elem, key, value) {
                                        return bulk.call(jQuery(elem), value);
                                    };
                                }
                            }

                            if (fn) {
                                for (; i < len; i++) {
                                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                                }
                            }
                        }

                        return chainable ?
                            elems :

                            // Gets
                            bulk ?
                                fn.call(elems) :
                                len ? fn(elems[0], key) : emptyGet;
                    };


                    /**
                     * Determines whether an object can have data
                     */
                    jQuery.acceptData = function (owner) {
                        // Accepts only:
                        //  - Node
                        //    - Node.ELEMENT_NODE
                        //    - Node.DOCUMENT_NODE
                        //  - Object
                        //    - Any
                        /* jshint -W018 */
                        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
                    };

                    function Data() {
                        // Support: Android<4,
                        // Old WebKit does not have Object.preventExtensions/freeze method,
                        // return new empty object instead with no [[set]] accessor
                        Object.defineProperty(this.cache = {}, 0, {
                            get: function () {
                                return {};
                            }
                        });

                        this.expando = jQuery.expando + Data.uid++;
                    }

                    Data.uid = 1;
                    Data.accepts = jQuery.acceptData;

                    Data.prototype = {
                        key: function (owner) {
                            // We can accept data for non-element nodes in modern browsers,
                            // but we should not, see #8335.
                            // Always return the key for a frozen object.
                            if (!Data.accepts(owner)) {
                                return 0;
                            }

                            var descriptor = {},
                            // Check if the owner object already has a cache key
                                unlock = owner[ this.expando ];

                            // If not, create one
                            if (!unlock) {
                                unlock = Data.uid++;

                                // Secure it in a non-enumerable, non-writable property
                                try {
                                    descriptor[ this.expando ] = {
                                        value: unlock
                                    };
                                    Object.defineProperties(owner, descriptor);

                                    // Support: Android<4
                                    // Fallback to a less secure definition
                                } catch (e) {
                                    descriptor[ this.expando ] = unlock;
                                    jQuery.extend(owner, descriptor);
                                }
                            }

                            // Ensure the cache object
                            if (!this.cache[ unlock ]) {
                                this.cache[ unlock ] = {};
                            }

                            return unlock;
                        },
                        set: function (owner, data, value) {
                            var prop,
                            // There may be an unlock assigned to this node,
                            // if there is no entry for this "owner", create one inline
                            // and set the unlock as though an owner entry had always existed
                                unlock = this.key(owner),
                                cache = this.cache[ unlock ];

                            // Handle: [ owner, key, value ] args
                            if (typeof data === 'string') {
                                cache[ data ] = value;

                                // Handle: [ owner, { properties } ] args
                            } else {
                                // Fresh assignments by object are shallow copied
                                if (jQuery.isEmptyObject(cache)) {
                                    jQuery.extend(this.cache[ unlock ], data);
                                    // Otherwise, copy the properties one-by-one to the cache object
                                } else {
                                    for (prop in data) {
                                        cache[ prop ] = data[ prop ];
                                    }
                                }
                            }

                            return cache;
                        },
                        get: function (owner, key) {
                            // Either a valid cache is found, or will be created.
                            // New caches will be created and the unlock returned,
                            // allowing direct access to the newly created
                            // empty data object. A valid owner object must be provided.
                            var cache = this.cache[ this.key(owner) ];

                            return key === undefined ?
                                cache : cache[ key ];
                        },
                        access: function (owner, key, value) {
                            var stored;
                            // In cases where either:
                            //
                            //   1. No key was specified
                            //   2. A string key was specified, but no value provided
                            //
                            // Take the "read" path and allow the get method to determine
                            // which value to return, respectively either:
                            //
                            //   1. The entire cache object
                            //   2. The data stored at the key
                            //

                            if (key === undefined ||
                                key && typeof key === 'string' && value === undefined) {

                                stored = this.get(owner, key);

                                return stored !== undefined ?
                                    stored : this.get(owner, jQuery.camelCase(key));
                            }

                            // [*]When the key is not a string, or both a key and value
                            // are specified, set or extend (existing objects) with either:
                            //
                            //   1. An object of properties
                            //   2. A key and value
                            //
                            this.set(owner, key, value);

                            // Since the "set" path can have two possible entry points
                            // return the expected data based on which path was taken[*]
                            return value !== undefined ? value : key;
                        },
                        remove: function (owner, key) {
                            var i, name, camel,
                                unlock = this.key(owner),
                                cache = this.cache[ unlock ];

                            if (key === undefined) {
                                this.cache[ unlock ] = {};

                            } else {
                                // Support array or space separated string of keys
                                if (jQuery.isArray(key)) {
                                    // If "name" is an array of keys...
                                    // When data is initially created, via ("key", "val") signature,
                                    // keys will be converted to camelCase.
                                    // Since there is no way to tell _how_ a key was added, remove
                                    // both plain key and camelCase key. #12786
                                    // This will only penalize the array argument path.
                                    name = key.concat(key.map(jQuery.camelCase));
                                } else {
                                    camel = jQuery.camelCase(key);
                                    // Try the string as a key before any manipulation
                                    if (key in cache) {
                                        name = [key, camel];
                                    } else {
                                        // If a key with the spaces exists, use it.
                                        // Otherwise, create an array by matching non-whitespace
                                        name = camel;
                                        name = name in cache ?
                                            [name] :  name.match(rnotwhite) || [];
                                    }
                                }

                                i = name.length;

                                while (i--) {
                                    delete cache[ name[ i ] ];
                                }
                            }
                        },
                        hasData: function (owner) {
                            return !jQuery.isEmptyObject(
                                this.cache[ owner[ this.expando ] ] || {}
                            );
                        },
                        discard: function (owner) {
                            if (owner[ this.expando ]) {
                                delete this.cache[ owner[ this.expando ] ];
                            }
                        }
                    };
                    var data_priv = new Data();

                    var data_user = new Data();



                    //	Implementation Summary
                    //
                    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
                    //	2. Improve the module's maintainability by reducing the storage
                    //		paths to a single mechanism.
                    //	3. Use the same single mechanism to support "private" and "user" data.
                    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
                    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
                    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

                    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                        rmultiDash = /([A-Z])/g;

                    function dataAttr(elem, key, data) {
                        var name;

                        // If nothing was found internally, try to fetch any
                        // data from the HTML5 data-* attribute
                        if (data === undefined && elem.nodeType === 1) {
                            name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
                            data = elem.getAttribute(name);

                            if (typeof data === 'string') {
                                try {
                                    data = data === 'true' ? true :
                                        data === 'false' ? false :
                                            data === 'null' ? null :
                                                // Only convert to a number if it doesn't change the string
                                                +data + '' === data ? +data :
                                                    rbrace.test(data) ? jQuery.parseJSON(data) :
                                                        data;
                                } catch (e) {}

                                // Make sure we set the data so it isn't changed later
                                data_user.set(elem, key, data);
                            } else {
                                data = undefined;
                            }
                        }

                        return data;
                    }

                    jQuery.extend({
                        hasData: function (elem) {
                            return data_user.hasData(elem) || data_priv.hasData(elem);
                        },

                        data: function (elem, name, data) {
                            return data_user.access(elem, name, data);
                        },

                        removeData: function (elem, name) {
                            data_user.remove(elem, name);
                        },

                        // TODO: Now that all calls to _data and _removeData have been replaced
                        // with direct calls to data_priv methods, these can be deprecated.
                        _data: function (elem, name, data) {
                            return data_priv.access(elem, name, data);
                        },

                        _removeData: function (elem, name) {
                            data_priv.remove(elem, name);
                        }
                    });

                    jQuery.fn.extend({
                        data: function (key, value) {
                            var i, name, data,
                                elem = this[ 0 ],
                                attrs = elem && elem.attributes;

                            // Gets all values
                            if (key === undefined) {
                                if (this.length) {
                                    data = data_user.get(elem);

                                    if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
                                        i = attrs.length;

                                        while (i--) {

                                            // Support: IE11+
                                            // The attrs elements can be null (#14894)
                                            if (attrs[ i ]) {
                                                name = attrs[ i ].name;

                                                if (name.indexOf('data-') === 0) {
                                                    name = jQuery.camelCase(name.slice(5));
                                                    dataAttr(elem, name, data[ name ]);
                                                }
                                            }
                                        }
                                        data_priv.set(elem, 'hasDataAttrs', true);
                                    }
                                }

                                return data;
                            }

                            // Sets multiple values
                            if (typeof key === 'object') {
                                return this.each(function () {
                                    data_user.set(this, key);
                                });
                            }

                            return access(this, function (value) {
                                var data,
                                    camelKey = jQuery.camelCase(key);

                                // The calling jQuery object (element matches) is not empty
                                // (and therefore has an element appears at this[ 0 ]) and the
                                // `value` parameter was not undefined. An empty jQuery object
                                // will result in `undefined` for elem = this[ 0 ] which will
                                // throw an exception if an attempt to read a data cache is made.
                                if (elem && value === undefined) {
                                    // Attempt to get data from the cache
                                    // with the key as-is
                                    data = data_user.get(elem, key);

                                    if (data !== undefined) {
                                        return data;
                                    }

                                    // Attempt to get data from the cache
                                    // with the key camelized
                                    data = data_user.get(elem, camelKey);

                                    if (data !== undefined) {
                                        return data;
                                    }

                                    // Attempt to "discover" the data in
                                    // HTML5 custom data-* attrs
                                    data = dataAttr(elem, camelKey, undefined);

                                    if (data !== undefined) {
                                        return data;
                                    }

                                    // We tried really hard, but the data doesn't exist.
                                    return;
                                }

                                // Set the data...
                                this.each(function () {
                                    // First, attempt to store a copy or reference of any
                                    // data that might've been store with a camelCased key.
                                    var data = data_user.get(this, camelKey);

                                    // For HTML5 data-* attribute interop, we have to
                                    // store property names with dashes in a camelCase form.
                                    // This might not apply to all properties...*
                                    data_user.set(this, camelKey, value);

                                    // *... In the case of properties that might _actually_
                                    // have dashes, we need to also store a copy of that
                                    // unchanged property.
                                    if (key.indexOf('-') !== -1 && data !== undefined) {
                                        data_user.set(this, key, value);
                                    }
                                });
                            }, null, value, arguments.length > 1, null, true);
                        },

                        removeData: function (key) {
                            return this.each(function () {
                                data_user.remove(this, key);
                            });
                        }
                    });

                    jQuery.extend({
                        queue: function (elem, type, data) {
                            var queue;

                            if (elem) {
                                type = (type || 'fx') + 'queue';
                                queue = data_priv.get(elem, type);

                                // Speed up dequeue by getting out quickly if this is just a lookup
                                if (data) {
                                    if (!queue || jQuery.isArray(data)) {
                                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                                    } else {
                                        queue.push(data);
                                    }
                                }

                                return queue || [];
                            }
                        },

                        dequeue: function (elem, type) {
                            type = type || 'fx';

                            var queue = jQuery.queue(elem, type),
                                startLength = queue.length,
                                fn = queue.shift(),
                                hooks = jQuery._queueHooks(elem, type),
                                next = function () {
                                    jQuery.dequeue(elem, type);
                                };

                            // If the fx queue is dequeued, always remove the progress sentinel
                            if (fn === 'inprogress') {
                                fn = queue.shift();
                                startLength--;
                            }

                            if (fn) {

                                // Add a progress sentinel to prevent the fx queue from being
                                // automatically dequeued
                                if (type === 'fx') {
                                    queue.unshift('inprogress');
                                }

                                // Clear up the last queue stop function
                                delete hooks.stop;
                                fn.call(elem, next, hooks);
                            }

                            if (!startLength && hooks) {
                                hooks.empty.fire();
                            }
                        },

                        // Not public - generate a queueHooks object, or return the current one
                        _queueHooks: function (elem, type) {
                            var key = type + 'queueHooks';

                            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                                    empty: jQuery.Callbacks('once memory').add(function () {
                                        data_priv.remove(elem, [type + 'queue', key]);
                                    })
                                });
                        }
                    });

                    jQuery.fn.extend({
                        queue: function (type, data) {
                            var setter = 2;

                            if (typeof type !== 'string') {
                                data = type;
                                type = 'fx';
                                setter--;
                            }

                            if (arguments.length < setter) {
                                return jQuery.queue(this[0], type);
                            }

                            return data === undefined ?
                                this :
                                this.each(function () {
                                    var queue = jQuery.queue(this, type, data);

                                    // Ensure a hooks for this queue
                                    jQuery._queueHooks(this, type);

                                    if (type === 'fx' && queue[0] !== 'inprogress') {
                                        jQuery.dequeue(this, type);
                                    }
                                });
                        },
                        dequeue: function (type) {
                            return this.each(function () {
                                jQuery.dequeue(this, type);
                            });
                        },
                        clearQueue: function (type) {
                            return this.queue(type || 'fx', []);
                        },
                        // Get a promise resolved when queues of a certain type
                        // are emptied (fx is the type by default)
                        promise: function (type, obj) {
                            var tmp,
                                count = 1,
                                defer = jQuery.Deferred(),
                                elements = this,
                                i = this.length,
                                resolve = function () {
                                    if (!--count) {
                                        defer.resolveWith(elements, [elements]);
                                    }
                                };

                            if (typeof type !== 'string') {
                                obj = type;
                                type = undefined;
                            }
                            type = type || 'fx';

                            while (i--) {
                                tmp = data_priv.get(elements[ i ], type + 'queueHooks');

                                if (tmp && tmp.empty) {
                                    count++;
                                    tmp.empty.add(resolve);
                                }
                            }
                            resolve();

                            return defer.promise(obj);
                        }
                    });
                    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

                    var cssExpand = ['Top', 'Right', 'Bottom', 'Left'];

                    var isHidden = function (elem, el) {
                        // isHidden might be called from jQuery#filter function;
                        // in that case, element will be second argument
                        elem = el || elem;

                        return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
                    };

                    var rcheckableType = (/^(?:checkbox|radio)$/i);

                    (function () {
                        var fragment = document.createDocumentFragment(),
                            div = fragment.appendChild(document.createElement('div')),
                            input = document.createElement('input');

                        // Support: Safari<=5.1
                        // Check state lost if the name is set (#11217)
                        // Support: Windows Web Apps (WWA)
                        // `name` and `type` must use .setAttribute for WWA (#14901)
                        input.setAttribute('type', 'radio');
                        input.setAttribute('checked', 'checked');
                        input.setAttribute('name', 't');

                        div.appendChild(input);

                        // Support: Safari<=5.1, Android<4.2
                        // Older WebKit doesn't clone checked state correctly in fragments
                        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

                        // Support: IE<=11+
                        // Make sure textarea (and checkbox) defaultValue is properly cloned
                        div.innerHTML = '<textarea>x</textarea>';
                        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
                    })();
                    var strundefined = typeof undefined;

                    support.focusinBubbles = 'onfocusin' in window;

                    var
                        rkeyEvent = /^key/,
                        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
                        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
                        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

                    function returnTrue() {
                        return true;
                    }

                    function returnFalse() {
                        return false;
                    }

                    function safeActiveElement() {
                        try {
                            return document.activeElement;
                        } catch (err) { }
                    }

                    /*
                     * Helper functions for managing events -- not part of the public interface.
                     * Props to Dean Edwards' addEvent library for many of the ideas.
                     */
                    jQuery.event = {

                        global: {},

                        add: function (elem, types, handler, data, selector) {

                            var handleObjIn, eventHandle, tmp,
                                events, t, handleObj,
                                special, handlers, type, namespaces, origType,
                                elemData = data_priv.get(elem);

                            // Don't attach events to noData or text/comment nodes (but allow plain objects)
                            if (!elemData) {
                                return;
                            }

                            // Caller can pass in an object of custom data in lieu of the handler
                            if (handler.handler) {
                                handleObjIn = handler;
                                handler = handleObjIn.handler;
                                selector = handleObjIn.selector;
                            }

                            // Make sure that the handler has a unique ID, used to find/remove it later
                            if (!handler.guid) {
                                handler.guid = jQuery.guid++;
                            }

                            // Init the element's event structure and main handler, if this is the first
                            if (!(events = elemData.events)) {
                                events = elemData.events = {};
                            }

                            if (!(eventHandle = elemData.handle)) {
                                eventHandle = elemData.handle = function (e) {
                                    // Discard the second event of a jQuery.event.trigger() and
                                    // when an event is called after a page has unloaded
                                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
                                        jQuery.event.dispatch.apply(elem, arguments) : undefined;
                                };
                            }

                            // Handle multiple events separated by a space
                            types = (types || '').match(rnotwhite) || [''];
                            t = types.length;

                            while (t--) {
                                tmp = rtypenamespace.exec(types[t]) || [];
                                type = origType = tmp[1];
                                namespaces = (tmp[2] || '').split('.').sort();

                                // There *must* be a type, no attaching namespace-only handlers
                                if (!type) {
                                    continue;
                                }

                                // If event changes its type, use the special event handlers for the changed type
                                special = jQuery.event.special[ type ] || {};

                                // If selector defined, determine special event api type, otherwise given type
                                type = (selector ? special.delegateType : special.bindType) || type;

                                // Update special based on newly reset type
                                special = jQuery.event.special[ type ] || {};

                                // handleObj is passed to all event handlers
                                handleObj = jQuery.extend({
                                    type: type,
                                    origType: origType,
                                    data: data,
                                    handler: handler,
                                    guid: handler.guid,
                                    selector: selector,
                                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                                    namespace: namespaces.join('.')
                                }, handleObjIn);

                                // Init the event handler queue if we're the first
                                if (!(handlers = events[ type ])) {
                                    handlers = events[ type ] = [];
                                    handlers.delegateCount = 0;

                                    // Only use addEventListener if the special events handler returns false
                                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                                        if (elem.addEventListener) {
                                            elem.addEventListener(type, eventHandle, false);
                                        }
                                    }
                                }

                                if (special.add) {
                                    special.add.call(elem, handleObj);

                                    if (!handleObj.handler.guid) {
                                        handleObj.handler.guid = handler.guid;
                                    }
                                }

                                // Add to the element's handler list, delegates in front
                                if (selector) {
                                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                                } else {
                                    handlers.push(handleObj);
                                }

                                // Keep track of which events have ever been used, for event optimization
                                jQuery.event.global[ type ] = true;
                            }

                        },

                        // Detach an event or set of events from an element
                        remove: function (elem, types, handler, selector, mappedTypes) {

                            var j, origCount, tmp,
                                events, t, handleObj,
                                special, handlers, type, namespaces, origType,
                                elemData = data_priv.hasData(elem) && data_priv.get(elem);

                            if (!elemData || !(events = elemData.events)) {
                                return;
                            }

                            // Once for each type.namespace in types; type may be omitted
                            types = (types || '').match(rnotwhite) || [''];
                            t = types.length;

                            while (t--) {
                                tmp = rtypenamespace.exec(types[t]) || [];
                                type = origType = tmp[1];
                                namespaces = (tmp[2] || '').split('.').sort();

                                // Unbind all events (on this namespace, if provided) for the element
                                if (!type) {
                                    for (type in events) {
                                        jQuery.event.remove(elem, type + types[ t ], handler, selector, true);
                                    }
                                    continue;
                                }

                                special = jQuery.event.special[ type ] || {};
                                type = (selector ? special.delegateType : special.bindType) || type;
                                handlers = events[ type ] || [];
                                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');

                                // Remove matching events
                                origCount = j = handlers.length;

                                while (j--) {
                                    handleObj = handlers[ j ];

                                    if ((mappedTypes || origType === handleObj.origType) &&
                                        (!handler || handler.guid === handleObj.guid) &&
                                        (!tmp || tmp.test(handleObj.namespace)) &&
                                        (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                                        handlers.splice(j, 1);

                                        if (handleObj.selector) {
                                            handlers.delegateCount--;
                                        }

                                        if (special.remove) {
                                            special.remove.call(elem, handleObj);
                                        }
                                    }
                                }

                                // Remove generic event handler if we removed something and no more handlers exist
                                // (avoids potential for endless recursion during removal of special event handlers)
                                if (origCount && !handlers.length) {
                                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                                        jQuery.removeEvent(elem, type, elemData.handle);
                                    }

                                    delete events[ type ];
                                }
                            }

                            // Remove the expando if it's no longer used
                            if (jQuery.isEmptyObject(events)) {
                                delete elemData.handle;
                                data_priv.remove(elem, 'events');
                            }
                        },

                        trigger: function (event, data, elem, onlyHandlers) {

                            var i, cur, tmp, bubbleType, ontype, handle, special,
                                eventPath = [elem || document],
                                type = hasOwn.call(event, 'type') ? event.type : event,
                                namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];

                            cur = tmp = elem = elem || document;

                            // Don't do events on text and comment nodes
                            if (elem.nodeType === 3 || elem.nodeType === 8) {
                                return;
                            }

                            // focus/blur morphs to focusin/out; ensure we're not firing them right now
                            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                                return;
                            }

                            if (type.indexOf('.') >= 0) {
                                // Namespaced trigger; create a regexp to match event type in handle()
                                namespaces = type.split('.');
                                type = namespaces.shift();
                                namespaces.sort();
                            }
                            ontype = type.indexOf(':') < 0 && 'on' + type;

                            // Caller can pass in a jQuery.Event object, Object, or just an event type string
                            event = event[ jQuery.expando ] ?
                                event :
                                new jQuery.Event(type, typeof event === 'object' && event);

                            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                            event.isTrigger = onlyHandlers ? 2 : 3;
                            event.namespace = namespaces.join('.');
                            event.namespace_re = event.namespace ?
                                new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') :
                                null;

                            // Clean up the event in case it is being reused
                            event.result = undefined;

                            if (!event.target) {
                                event.target = elem;
                            }

                            // Clone any incoming data and prepend the event, creating the handler arg list
                            data = data == null ?
                                [event] :
                                jQuery.makeArray(data, [event]);

                            // Allow special events to draw outside the lines
                            special = jQuery.event.special[ type ] || {};

                            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                                return;
                            }

                            // Determine event propagation path in advance, per W3C events spec (#9951)
                            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                                bubbleType = special.delegateType || type;

                                if (!rfocusMorph.test(bubbleType + type)) {
                                    cur = cur.parentNode;
                                }

                                for (; cur; cur = cur.parentNode) {
                                    eventPath.push(cur);
                                    tmp = cur;
                                }

                                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                                if (tmp === (elem.ownerDocument || document)) {
                                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                                }
                            }

                            // Fire handlers on the event path
                            i = 0;

                            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                                event.type = i > 1 ?
                                    bubbleType :
                                special.bindType || type;

                                // jQuery handler
                                handle = (data_priv.get(cur, 'events') || {})[ event.type ] && data_priv.get(cur, 'handle');

                                if (handle) {
                                    handle.apply(cur, data);
                                }

                                // Native handler
                                handle = ontype && cur[ ontype ];

                                if (handle && handle.apply && jQuery.acceptData(cur)) {
                                    event.result = handle.apply(cur, data);

                                    if (event.result === false) {
                                        event.preventDefault();
                                    }
                                }
                            }
                            event.type = type;

                            // If nobody prevented the default action, do it now
                            if (!onlyHandlers && !event.isDefaultPrevented()) {

                                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) &&
                                    jQuery.acceptData(elem)) {

                                    // Call a native DOM method on the target with the same name name as the event.
                                    // Don't do default actions on window, that's where global variables be (#6170)
                                    if (ontype && jQuery.isFunction(elem[ type ]) && !jQuery.isWindow(elem)) {

                                        // Don't re-trigger an onFOO event when we call its FOO() method
                                        tmp = elem[ ontype ];

                                        if (tmp) {
                                            elem[ ontype ] = null;
                                        }

                                        // Prevent re-triggering of the same event, since we already bubbled it above
                                        jQuery.event.triggered = type;
                                        elem[ type ]();
                                        jQuery.event.triggered = undefined;

                                        if (tmp) {
                                            elem[ ontype ] = tmp;
                                        }
                                    }
                                }
                            }

                            return event.result;
                        },

                        dispatch: function (event) {

                            // Make a writable jQuery.Event from the native event object
                            event = jQuery.event.fix(event);

                            var i, j, ret, matched, handleObj,
                                handlerQueue = [],
                                args = slice.call(arguments),
                                handlers = (data_priv.get(this, 'events') || {})[ event.type ] || [],
                                special = jQuery.event.special[ event.type ] || {};

                            // Use the fix-ed jQuery.Event rather than the (read-only) native event
                            args[0] = event;
                            event.delegateTarget = this;

                            // Call the preDispatch hook for the mapped type, and let it bail if desired
                            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                                return;
                            }

                            // Determine handlers
                            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

                            // Run delegates first; they may want to stop propagation beneath us
                            i = 0;

                            while ((matched = handlerQueue[ i++ ]) && !event.isPropagationStopped()) {
                                event.currentTarget = matched.elem;

                                j = 0;

                                while ((handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped()) {

                                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                                    // a subset or equal to those in the bound event (both can have no namespace).
                                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

                                        event.handleObj = handleObj;
                                        event.data = handleObj.data;

                                        ret = ((jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler)
                                            .apply(matched.elem, args);

                                        if (ret !== undefined) {
                                            if ((event.result = ret) === false) {
                                                event.preventDefault();
                                                event.stopPropagation();
                                            }
                                        }
                                    }
                                }
                            }

                            // Call the postDispatch hook for the mapped type
                            if (special.postDispatch) {
                                special.postDispatch.call(this, event);
                            }

                            return event.result;
                        },

                        handlers: function (event, handlers) {
                            var i, matches, sel, handleObj,
                                handlerQueue = [],
                                delegateCount = handlers.delegateCount,
                                cur = event.target;

                            // Find delegate handlers
                            // Black-hole SVG <use> instance trees (#13180)
                            // Avoid non-left-click bubbling in Firefox (#3861)
                            if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {

                                for (; cur !== this; cur = cur.parentNode || this) {

                                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                                    if (cur.disabled !== true || event.type !== 'click') {
                                        matches = [];

                                        for (i = 0; i < delegateCount; i++) {
                                            handleObj = handlers[ i ];

                                            // Don't conflict with Object.prototype properties (#13203)
                                            sel = handleObj.selector + ' ';

                                            if (matches[ sel ] === undefined) {
                                                matches[ sel ] = handleObj.needsContext ?
                                                jQuery(sel, this).index(cur) >= 0 :
                                                    jQuery.find(sel, this, null, [cur]).length;
                                            }

                                            if (matches[ sel ]) {
                                                matches.push(handleObj);
                                            }
                                        }

                                        if (matches.length) {
                                            handlerQueue.push({
                                                elem: cur, handlers: matches
                                            });
                                        }
                                    }
                                }
                            }

                            // Add the remaining (directly-bound) handlers
                            if (delegateCount < handlers.length) {
                                handlerQueue.push({
                                    elem: this, handlers: handlers.slice(delegateCount)
                                });
                            }

                            return handlerQueue;
                        },

                        // Includes some event props shared by KeyEvent and MouseEvent
                        props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),

                        fixHooks: {},

                        keyHooks: {
                            props: 'char charCode key keyCode'.split(' '),
                            filter: function (event, original) {

                                // Add which for key events
                                if (event.which == null) {
                                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                                }

                                return event;
                            }
                        },

                        mouseHooks: {
                            props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
                            filter: function (event, original) {
                                var eventDoc, doc, body,
                                    button = original.button;

                                // Calculate pageX/Y if missing and clientX/Y available
                                if (event.pageX == null && original.clientX != null) {
                                    eventDoc = event.target.ownerDocument || document;
                                    doc = eventDoc.documentElement;
                                    body = eventDoc.body;

                                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                                    event.pageY = original.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
                                }

                                // Add which for click: 1 === left; 2 === middle; 3 === right
                                // Note: button is not normalized, so don't use it
                                if (!event.which && button !== undefined) {
                                    event.which =  button & 1 ? 1 :  button & 2 ? 3 :  button & 4 ? 2 : 0;
                                }

                                return event;
                            }
                        },

                        fix: function (event) {
                            if (event[ jQuery.expando ]) {
                                return event;
                            }

                            // Create a writable copy of the event object and normalize some properties
                            var i, prop, copy,
                                type = event.type,
                                originalEvent = event,
                                fixHook = this.fixHooks[ type ];

                            if (!fixHook) {
                                this.fixHooks[ type ] = fixHook =
                                    rmouseEvent.test(type) ? this.mouseHooks :
                                        rkeyEvent.test(type) ? this.keyHooks :
                                        {};
                            }
                            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

                            event = new jQuery.Event(originalEvent);

                            i = copy.length;

                            while (i--) {
                                prop = copy[ i ];
                                event[ prop ] = originalEvent[ prop ];
                            }

                            // Support: Cordova 2.5 (WebKit) (#13255)
                            // All events should have a target; Cordova deviceready doesn't
                            if (!event.target) {
                                event.target = document;
                            }

                            // Support: Safari 6.0+, Chrome<28
                            // Target should not be a text node (#504, #13143)
                            if (event.target.nodeType === 3) {
                                event.target = event.target.parentNode;
                            }

                            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
                        },

                        special: {
                            load: {
                                // Prevent triggered image.load events from bubbling to window.load
                                noBubble: true
                            },
                            focus: {
                                // Fire native event if possible so blur/focus sequence is correct
                                trigger: function () {
                                    if (this !== safeActiveElement() && this.focus) {
                                        this.focus();

                                        return false;
                                    }
                                },
                                delegateType: 'focusin'
                            },
                            blur: {
                                trigger: function () {
                                    if (this === safeActiveElement() && this.blur) {
                                        this.blur();

                                        return false;
                                    }
                                },
                                delegateType: 'focusout'
                            },
                            click: {
                                // For checkbox, fire native event so checked state will be right
                                trigger: function () {
                                    if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
                                        this.click();

                                        return false;
                                    }
                                },

                                // For cross-browser consistency, don't fire native .click() on links
                                _default: function (event) {
                                    return jQuery.nodeName(event.target, 'a');
                                }
                            },

                            beforeunload: {
                                postDispatch: function (event) {

                                    // Support: Firefox 20+
                                    // Firefox doesn't alert if the returnValue field is not set.
                                    if (event.result !== undefined && event.originalEvent) {
                                        event.originalEvent.returnValue = event.result;
                                    }
                                }
                            }
                        },

                        simulate: function (type, elem, event, bubble) {
                            // Piggyback on a donor event to simulate a different one.
                            // Fake originalEvent to avoid donor's stopPropagation, but if the
                            // simulated event prevents default then we do the same on the donor.
                            var e = jQuery.extend(
                                new jQuery.Event(),
                                event,
                                {
                                    type: type,
                                    isSimulated: true,
                                    originalEvent: {}
                                }
                            );

                            if (bubble) {
                                jQuery.event.trigger(e, null, elem);
                            } else {
                                jQuery.event.dispatch.call(elem, e);
                            }

                            if (e.isDefaultPrevented()) {
                                event.preventDefault();
                            }
                        }
                    };

                    jQuery.removeEvent = function (elem, type, handle) {
                        if (elem.removeEventListener) {
                            elem.removeEventListener(type, handle, false);
                        }
                    };

                    jQuery.Event = function (src, props) {
                        // Allow instantiation without the 'new' keyword
                        if (!(this instanceof jQuery.Event)) {
                            return new jQuery.Event(src, props);
                        }

                        // Event object
                        if (src && src.type) {
                            this.originalEvent = src;
                            this.type = src.type;

                            // Events bubbling up the document may have been marked as prevented
                            // by a handler lower down the tree; reflect the correct value.
                            this.isDefaultPrevented = src.defaultPrevented ||
                            src.defaultPrevented === undefined &&
                                // Support: Android<4.0
                            src.returnValue === false ?
                                returnTrue :
                                returnFalse;

                            // Event type
                        } else {
                            this.type = src;
                        }

                        // Put explicitly provided properties onto the event object
                        if (props) {
                            jQuery.extend(this, props);
                        }

                        // Create a timestamp if incoming event doesn't have one
                        this.timeStamp = src && src.timeStamp || jQuery.now();

                        // Mark it as fixed
                        this[ jQuery.expando ] = true;
                    };

                    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
                    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
                    jQuery.Event.prototype = {
                        isDefaultPrevented: returnFalse,
                        isPropagationStopped: returnFalse,
                        isImmediatePropagationStopped: returnFalse,

                        preventDefault: function () {
                            var e = this.originalEvent;

                            this.isDefaultPrevented = returnTrue;

                            if (e && e.preventDefault) {
                                e.preventDefault();
                            }
                        },
                        stopPropagation: function () {
                            var e = this.originalEvent;

                            this.isPropagationStopped = returnTrue;

                            if (e && e.stopPropagation) {
                                e.stopPropagation();
                            }
                        },
                        stopImmediatePropagation: function () {
                            var e = this.originalEvent;

                            this.isImmediatePropagationStopped = returnTrue;

                            if (e && e.stopImmediatePropagation) {
                                e.stopImmediatePropagation();
                            }

                            this.stopPropagation();
                        }
                    };

                    // Create mouseenter/leave events using mouseover/out and event-time checks
                    // Support: Chrome 15+
                    jQuery.each({
                        mouseenter: 'mouseover',
                        mouseleave: 'mouseout',
                        pointerenter: 'pointerover',
                        pointerleave: 'pointerout'
                    }, function (orig, fix) {
                        jQuery.event.special[ orig ] = {
                            delegateType: fix,
                            bindType: fix,

                            handle: function (event) {
                                var ret,
                                    target = this,
                                    related = event.relatedTarget,
                                    handleObj = event.handleObj;

                                // For mousenter/leave call the handler if related is outside the target.
                                // NB: No relatedTarget if the mouse left/entered the browser window
                                if (!related || related !== target && !jQuery.contains(target, related)) {
                                    event.type = handleObj.origType;
                                    ret = handleObj.handler.apply(this, arguments);
                                    event.type = fix;
                                }

                                return ret;
                            }
                        };
                    });

                    // Support: Firefox, Chrome, Safari
                    // Create "bubbling" focus and blur events
                    if (!support.focusinBubbles) {
                        jQuery.each({
                            focus: 'focusin', blur: 'focusout'
                        }, function (orig, fix) {

                            // Attach a single capturing handler on the document while someone wants focusin/focusout
                            var handler = function (event) {
                                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                            };

                            jQuery.event.special[ fix ] = {
                                setup: function () {
                                    var doc = this.ownerDocument || this,
                                        attaches = data_priv.access(doc, fix);

                                    if (!attaches) {
                                        doc.addEventListener(orig, handler, true);
                                    }
                                    data_priv.access(doc, fix, (attaches || 0) + 1);
                                },
                                teardown: function () {
                                    var doc = this.ownerDocument || this,
                                        attaches = data_priv.access(doc, fix) - 1;

                                    if (!attaches) {
                                        doc.removeEventListener(orig, handler, true);
                                        data_priv.remove(doc, fix);

                                    } else {
                                        data_priv.access(doc, fix, attaches);
                                    }
                                }
                            };
                        });
                    }

                    jQuery.fn.extend({

                        on: function (types, selector, data, fn, /*INTERNAL*/ one) {
                            var origFn, type;

                            // Types can be a map of types/handlers
                            if (typeof types === 'object') {
                                // ( types-Object, selector, data )
                                if (typeof selector !== 'string') {
                                    // ( types-Object, data )
                                    data = data || selector;
                                    selector = undefined;
                                }

                                for (type in types) {
                                    this.on(type, selector, data, types[ type ], one);
                                }

                                return this;
                            }

                            if (data == null && fn == null) {
                                // ( types, fn )
                                fn = selector;
                                data = selector = undefined;
                            } else if (fn == null) {
                                if (typeof selector === 'string') {
                                    // ( types, selector, fn )
                                    fn = data;
                                    data = undefined;
                                } else {
                                    // ( types, data, fn )
                                    fn = data;
                                    data = selector;
                                    selector = undefined;
                                }
                            }

                            if (fn === false) {
                                fn = returnFalse;
                            } else if (!fn) {
                                return this;
                            }

                            if (one === 1) {
                                origFn = fn;
                                fn = function (event) {
                                    // Can use an empty set, since event contains the info
                                    jQuery().off(event);

                                    return origFn.apply(this, arguments);
                                };
                                // Use same guid so caller can remove using origFn
                                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                            }

                            return this.each(function () {
                                jQuery.event.add(this, types, fn, data, selector);
                            });
                        },
                        one: function (types, selector, data, fn) {
                            return this.on(types, selector, data, fn, 1);
                        },
                        off: function (types, selector, fn) {
                            var handleObj, type;

                            if (types && types.preventDefault && types.handleObj) {
                                // ( event )  dispatched jQuery.Event
                                handleObj = types.handleObj;
                                jQuery(types.delegateTarget).off(
                                    handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType,
                                    handleObj.selector,
                                    handleObj.handler
                                );

                                return this;
                            }

                            if (typeof types === 'object') {
                                // ( types-object [, selector] )
                                for (type in types) {
                                    this.off(type, selector, types[ type ]);
                                }

                                return this;
                            }

                            if (selector === false || typeof selector === 'function') {
                                // ( types [, fn] )
                                fn = selector;
                                selector = undefined;
                            }

                            if (fn === false) {
                                fn = returnFalse;
                            }

                            return this.each(function () {
                                jQuery.event.remove(this, types, fn, selector);
                            });
                        },

                        trigger: function (type, data) {
                            return this.each(function () {
                                jQuery.event.trigger(type, data, this);
                            });
                        },
                        triggerHandler: function (type, data) {
                            var elem = this[0];

                            if (elem) {
                                return jQuery.event.trigger(type, data, elem, true);
                            }
                        }
                    });

                    var
                        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
                        rtagName = /<([\w:]+)/,
                        rhtml = /<|&#?\w+;/,
                        rnoInnerhtml = /<(?:script|style|link)/i,
                    // checked="checked" or checked
                        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                        rscriptType = /^$|\/(?:java|ecma)script/i,
                        rscriptTypeMasked = /^true\/(.*)/,
                        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

                    // We have to close these tags to support XHTML (#13200)
                        wrapMap = {

                            // Support: IE9
                            option: [1, '<select multiple=\'multiple\'>', '</select>'],

                            thead: [1, '<table>', '</table>'],
                            col: [2, '<table><colgroup>', '</colgroup></table>'],
                            tr: [2, '<table><tbody>', '</tbody></table>'],
                            td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],

                            _default: [0, '', '']
                        };

                    // Support: IE9
                    wrapMap.optgroup = wrapMap.option;

                    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
                    wrapMap.th = wrapMap.td;

                    // Support: 1.x compatibility
                    // Manipulating tables requires a tbody
                    function manipulationTarget(elem, content) {
                        return jQuery.nodeName(elem, 'table') &&
                        jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ?

                        elem.getElementsByTagName('tbody')[0] ||
                        elem.appendChild(elem.ownerDocument.createElement('tbody')) :
                            elem;
                    }

                    // Replace/restore the type attribute of script elements for safe DOM manipulation
                    function disableScript(elem) {
                        elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;

                        return elem;
                    }
                    function restoreScript(elem) {
                        var match = rscriptTypeMasked.exec(elem.type);

                        if (match) {
                            elem.type = match[ 1 ];
                        } else {
                            elem.removeAttribute('type');
                        }

                        return elem;
                    }

                    // Mark scripts as having already been evaluated
                    function setGlobalEval(elems, refElements) {
                        var i = 0,
                            l = elems.length;

                        for (; i < l; i++) {
                            data_priv.set(
                                elems[ i ], 'globalEval', !refElements || data_priv.get(refElements[ i ], 'globalEval')
                            );
                        }
                    }

                    function cloneCopyEvent(src, dest) {
                        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

                        if (dest.nodeType !== 1) {
                            return;
                        }

                        // 1. Copy private data: events, handlers, etc.
                        if (data_priv.hasData(src)) {
                            pdataOld = data_priv.access(src);
                            pdataCur = data_priv.set(dest, pdataOld);
                            events = pdataOld.events;

                            if (events) {
                                delete pdataCur.handle;
                                pdataCur.events = {};

                                for (type in events) {
                                    for (i = 0, l = events[ type ].length; i < l; i++) {
                                        jQuery.event.add(dest, type, events[ type ][ i ]);
                                    }
                                }
                            }
                        }

                        // 2. Copy user data
                        if (data_user.hasData(src)) {
                            udataOld = data_user.access(src);
                            udataCur = jQuery.extend({}, udataOld);

                            data_user.set(dest, udataCur);
                        }
                    }

                    function getAll(context, tag) {
                        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') :
                            context.querySelectorAll ? context.querySelectorAll(tag || '*') :
                                [];

                        return tag === undefined || tag && jQuery.nodeName(context, tag) ?
                            jQuery.merge([context], ret) :
                            ret;
                    }

                    // Fix IE bugs, see support tests
                    function fixInput(src, dest) {
                        var nodeName = dest.nodeName.toLowerCase();

                        // Fails to persist the checked state of a cloned checkbox or radio button.
                        if (nodeName === 'input' && rcheckableType.test(src.type)) {
                            dest.checked = src.checked;

                            // Fails to return the selected option to the default selected state when cloning options
                        } else if (nodeName === 'input' || nodeName === 'textarea') {
                            dest.defaultValue = src.defaultValue;
                        }
                    }

                    jQuery.extend({
                        clone: function (elem, dataAndEvents, deepDataAndEvents) {
                            var i, l, srcElements, destElements,
                                clone = elem.cloneNode(true),
                                inPage = jQuery.contains(elem.ownerDocument, elem);

                            // Fix IE cloning issues
                            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
                                !jQuery.isXMLDoc(elem)) {

                                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                                destElements = getAll(clone);
                                srcElements = getAll(elem);

                                for (i = 0, l = srcElements.length; i < l; i++) {
                                    fixInput(srcElements[ i ], destElements[ i ]);
                                }
                            }

                            // Copy the events from the original to the clone
                            if (dataAndEvents) {
                                if (deepDataAndEvents) {
                                    srcElements = srcElements || getAll(elem);
                                    destElements = destElements || getAll(clone);

                                    for (i = 0, l = srcElements.length; i < l; i++) {
                                        cloneCopyEvent(srcElements[ i ], destElements[ i ]);
                                    }
                                } else {
                                    cloneCopyEvent(elem, clone);
                                }
                            }

                            // Preserve script evaluation history
                            destElements = getAll(clone, 'script');

                            if (destElements.length > 0) {
                                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
                            }

                            // Return the cloned set
                            return clone;
                        },

                        buildFragment: function (elems, context, scripts, selection) {
                            var elem, tmp, tag, wrap, contains, j,
                                fragment = context.createDocumentFragment(),
                                nodes = [],
                                i = 0,
                                l = elems.length;

                            for (; i < l; i++) {
                                elem = elems[ i ];

                                if (elem || elem === 0) {

                                    // Add nodes directly
                                    if (jQuery.type(elem) === 'object') {
                                        // Support: QtWebKit, PhantomJS
                                        // push.apply(_, arraylike) throws on ancient WebKit
                                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                                        // Convert non-html into a text node
                                    } else if (!rhtml.test(elem)) {
                                        nodes.push(context.createTextNode(elem));

                                        // Convert html into DOM nodes
                                    } else {
                                        tmp = tmp || fragment.appendChild(context.createElement('div'));

                                        // Deserialize a standard representation
                                        tag = (rtagName.exec(elem) || ['', ''])[ 1 ].toLowerCase();
                                        wrap = wrapMap[ tag ] || wrapMap._default;
                                        tmp.innerHTML = wrap[ 1 ] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[ 2 ];

                                        // Descend through wrappers to the right content
                                        j = wrap[ 0 ];

                                        while (j--) {
                                            tmp = tmp.lastChild;
                                        }

                                        // Support: QtWebKit, PhantomJS
                                        // push.apply(_, arraylike) throws on ancient WebKit
                                        jQuery.merge(nodes, tmp.childNodes);

                                        // Remember the top-level container
                                        tmp = fragment.firstChild;

                                        // Ensure the created nodes are orphaned (#12392)
                                        tmp.textContent = '';
                                    }
                                }
                            }

                            // Remove wrapper from fragment
                            fragment.textContent = '';

                            i = 0;

                            while (elem = nodes[ i++ ]) {

                                // #4087 - If origin and destination elements are the same, and this is
                                // that element, do not do anything
                                if (selection && jQuery.inArray(elem, selection) !== -1) {
                                    continue;
                                }

                                contains = jQuery.contains(elem.ownerDocument, elem);

                                // Append to fragment
                                tmp = getAll(fragment.appendChild(elem), 'script');

                                // Preserve script evaluation history
                                if (contains) {
                                    setGlobalEval(tmp);
                                }

                                // Capture executables
                                if (scripts) {
                                    j = 0;

                                    while (elem = tmp[ j++ ]) {
                                        if (rscriptType.test(elem.type || '')) {
                                            scripts.push(elem);
                                        }
                                    }
                                }
                            }

                            return fragment;
                        },

                        cleanData: function (elems) {
                            var data, elem, type, key,
                                special = jQuery.event.special,
                                i = 0;

                            for (; (elem = elems[ i ]) !== undefined; i++) {
                                if (jQuery.acceptData(elem)) {
                                    key = elem[ data_priv.expando ];

                                    if (key && (data = data_priv.cache[ key ])) {
                                        if (data.events) {
                                            for (type in data.events) {
                                                if (special[ type ]) {
                                                    jQuery.event.remove(elem, type);

                                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                                } else {
                                                    jQuery.removeEvent(elem, type, data.handle);
                                                }
                                            }
                                        }

                                        if (data_priv.cache[ key ]) {
                                            // Discard any remaining `private` data
                                            delete data_priv.cache[ key ];
                                        }
                                    }
                                }
                                // Discard any remaining `user` data
                                delete data_user.cache[ elem[ data_user.expando ] ];
                            }
                        }
                    });

                    jQuery.fn.extend({
                        text: function (value) {
                            return access(this, function (value) {
                                return value === undefined ?
                                    jQuery.text(this) :
                                    this.empty().each(function () {
                                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                            this.textContent = value;
                                        }
                                    });
                            }, null, value, arguments.length);
                        },

                        append: function () {
                            return this.domManip(arguments, function (elem) {
                                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                    var target = manipulationTarget(this, elem);

                                    target.appendChild(elem);
                                }
                            });
                        },

                        prepend: function () {
                            return this.domManip(arguments, function (elem) {
                                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                    var target = manipulationTarget(this, elem);

                                    target.insertBefore(elem, target.firstChild);
                                }
                            });
                        },

                        before: function () {
                            return this.domManip(arguments, function (elem) {
                                if (this.parentNode) {
                                    this.parentNode.insertBefore(elem, this);
                                }
                            });
                        },

                        after: function () {
                            return this.domManip(arguments, function (elem) {
                                if (this.parentNode) {
                                    this.parentNode.insertBefore(elem, this.nextSibling);
                                }
                            });
                        },

                        remove: function (selector, keepData /* Internal Use Only */) {
                            var elem,
                                elems = selector ? jQuery.filter(selector, this) : this,
                                i = 0;

                            for (; (elem = elems[i]) != null; i++) {
                                if (!keepData && elem.nodeType === 1) {
                                    jQuery.cleanData(getAll(elem));
                                }

                                if (elem.parentNode) {
                                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                                        setGlobalEval(getAll(elem, 'script'));
                                    }
                                    elem.parentNode.removeChild(elem);
                                }
                            }

                            return this;
                        },

                        empty: function () {
                            var elem,
                                i = 0;

                            for (; (elem = this[i]) != null; i++) {
                                if (elem.nodeType === 1) {

                                    // Prevent memory leaks
                                    jQuery.cleanData(getAll(elem, false));

                                    // Remove any remaining nodes
                                    elem.textContent = '';
                                }
                            }

                            return this;
                        },

                        clone: function (dataAndEvents, deepDataAndEvents) {
                            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                            return this.map(function () {
                                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                            });
                        },

                        html: function (value) {
                            return access(this, function (value) {
                                var elem = this[ 0 ] || {},
                                    i = 0,
                                    l = this.length;

                                if (value === undefined && elem.nodeType === 1) {
                                    return elem.innerHTML;
                                }

                                // See if we can take a shortcut and just use innerHTML
                                if (typeof value === 'string' && !rnoInnerhtml.test(value) &&
                                    !wrapMap[ (rtagName.exec(value) || ['', ''])[ 1 ].toLowerCase() ]) {

                                    value = value.replace(rxhtmlTag, '<$1></$2>');

                                    try {
                                        for (; i < l; i++) {
                                            elem = this[ i ] || {};

                                            // Remove element nodes and prevent memory leaks
                                            if (elem.nodeType === 1) {
                                                jQuery.cleanData(getAll(elem, false));
                                                elem.innerHTML = value;
                                            }
                                        }

                                        elem = 0;

                                        // If using innerHTML throws an exception, use the fallback method
                                    } catch (e) {}
                                }

                                if (elem) {
                                    this.empty().append(value);
                                }
                            }, null, value, arguments.length);
                        },

                        replaceWith: function () {
                            var arg = arguments[ 0 ];

                            // Make the changes, replacing each context element with the new content
                            this.domManip(arguments, function (elem) {
                                arg = this.parentNode;

                                jQuery.cleanData(getAll(this));

                                if (arg) {
                                    arg.replaceChild(elem, this);
                                }
                            });

                            // Force removal if there was no new content (e.g., from empty arguments)
                            return arg && (arg.length || arg.nodeType) ? this : this.remove();
                        },

                        detach: function (selector) {
                            return this.remove(selector, true);
                        },

                        domManip: function (args, callback) {

                            // Flatten any nested arrays
                            args = concat.apply([], args);

                            var fragment, first, scripts, hasScripts, node, doc,
                                i = 0,
                                l = this.length,
                                set = this,
                                iNoClone = l - 1,
                                value = args[ 0 ],
                                isFunction = jQuery.isFunction(value);

                            // We can't cloneNode fragments that contain checked, in WebKit
                            if (isFunction ||
                                 l > 1 && typeof value === 'string' &&
                                !support.checkClone && rchecked.test(value)) {
                                return this.each(function (index) {
                                    var self = set.eq(index);

                                    if (isFunction) {
                                        args[ 0 ] = value.call(this, index, self.html());
                                    }
                                    self.domManip(args, callback);
                                });
                            }

                            if (l) {
                                fragment = jQuery.buildFragment(args, this[ 0 ].ownerDocument, false, this);
                                first = fragment.firstChild;

                                if (fragment.childNodes.length === 1) {
                                    fragment = first;
                                }

                                if (first) {
                                    scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                                    hasScripts = scripts.length;

                                    // Use the original fragment for the last item instead of the first because it can end up
                                    // being emptied incorrectly in certain situations (#8070).
                                    for (; i < l; i++) {
                                        node = fragment;

                                        if (i !== iNoClone) {
                                            node = jQuery.clone(node, true, true);

                                            // Keep references to cloned scripts for later restoration
                                            if (hasScripts) {
                                                // Support: QtWebKit
                                                // jQuery.merge because push.apply(_, arraylike) throws
                                                jQuery.merge(scripts, getAll(node, 'script'));
                                            }
                                        }

                                        callback.call(this[ i ], node, i);
                                    }

                                    if (hasScripts) {
                                        doc = scripts[ scripts.length - 1 ].ownerDocument;

                                        // Reenable scripts
                                        jQuery.map(scripts, restoreScript);

                                        // Evaluate executable scripts on first document insertion
                                        for (i = 0; i < hasScripts; i++) {
                                            node = scripts[ i ];

                                            if (rscriptType.test(node.type || '') &&
                                                !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {

                                                if (node.src) {
                                                    // Optional AJAX dependency, but won't run scripts if not present
                                                    if (jQuery._evalUrl) {
                                                        jQuery._evalUrl(node.src);
                                                    }
                                                } else {
                                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            return this;
                        }
                    });

                    jQuery.each({
                        appendTo: 'append',
                        prependTo: 'prepend',
                        insertBefore: 'before',
                        insertAfter: 'after',
                        replaceAll: 'replaceWith'
                    }, function (name, original) {
                        jQuery.fn[ name ] = function (selector) {
                            var elems,
                                ret = [],
                                insert = jQuery(selector),
                                last = insert.length - 1,
                                i = 0;

                            for (; i <= last; i++) {
                                elems = i === last ? this : this.clone(true);
                                jQuery(insert[ i ])[ original ](elems);

                                // Support: QtWebKit
                                // .get() because push.apply(_, arraylike) throws
                                push.apply(ret, elems.get());
                            }

                            return this.pushStack(ret);
                        };
                    });

                    var iframe,
                        elemdisplay = {};

                    /**
                     * Retrieve the actual display of a element
                     * @param {String} name nodeName of the element
                     * @param {Object} doc Document object
                     */
                    // Called only from within defaultDisplay
                    function actualDisplay(name, doc) {
                        var style,
                            elem = jQuery(doc.createElement(name)).appendTo(doc.body),

                        // getDefaultComputedStyle might be reliably used only on attached element
                            display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[ 0 ])) ?

                                // Use of this method is a temporary fix (more like optimization) until something better comes along,
                                // since it was removed from specification and supported only in FF
                                style.display : jQuery.css(elem[ 0 ], 'display');

                        // We don't have any data stored on the element,
                        // so use "detach" method as fast way to get rid of the element
                        elem.detach();

                        return display;
                    }

                    /**
                     * Try to determine the default display value of an element
                     * @param {String} nodeName
                     */
                    function defaultDisplay(nodeName) {
                        var doc = document,
                            display = elemdisplay[ nodeName ];

                        if (!display) {
                            display = actualDisplay(nodeName, doc);

                            // If the simple way fails, read from inside an iframe
                            if (display === 'none' || !display) {

                                // Use the already-created iframe if possible
                                iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);

                                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                                doc = iframe[ 0 ].contentDocument;

                                // Support: IE
                                doc.write();
                                doc.close();

                                display = actualDisplay(nodeName, doc);
                                iframe.detach();
                            }

                            // Store the correct default display
                            elemdisplay[ nodeName ] = display;
                        }

                        return display;
                    }
                    var rmargin = (/^margin/);

                    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');

                    var getStyles = function (elem) {
                        // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
                        // IE throws on elements created in popups
                        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                        if (elem.ownerDocument.defaultView.opener) {
                            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
                        }

                        return window.getComputedStyle(elem, null);
                    };

                    function curCSS(elem, name, computed) {
                        var width, minWidth, maxWidth, ret,
                            style = elem.style;

                        computed = computed || getStyles(elem);

                        // Support: IE9
                        // getPropertyValue is only needed for .css('filter') (#12537)
                        if (computed) {
                            ret = computed.getPropertyValue(name) || computed[ name ];
                        }

                        if (computed) {

                            if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                                ret = jQuery.style(elem, name);
                            }

                            // Support: iOS < 6
                            // A tribute to the "awesome hack by Dean Edwards"
                            // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                            if (rnumnonpx.test(ret) && rmargin.test(name)) {

                                // Remember the original values
                                width = style.width;
                                minWidth = style.minWidth;
                                maxWidth = style.maxWidth;

                                // Put in the new values to get a computed value out
                                style.minWidth = style.maxWidth = style.width = ret;
                                ret = computed.width;

                                // Revert the changed values
                                style.width = width;
                                style.minWidth = minWidth;
                                style.maxWidth = maxWidth;
                            }
                        }

                        return ret !== undefined ?
                            // Support: IE
                            // IE returns zIndex value as an integer.
                        ret + '' :
                            ret;
                    }

                    function addGetHookIf(conditionFn, hookFn) {
                        // Define the hook, we'll check on the first run if it's really needed.
                        return {
                            get: function () {
                                if (conditionFn()) {
                                    // Hook not needed (or it's not possible to use it due
                                    // to missing dependency), remove it.
                                    delete this.get;

                                    return;
                                }

                                // Hook needed; redefine it so that the support test is not executed again.
                                return (this.get = hookFn).apply(this, arguments);
                            }
                        };
                    }

                    (function () {
                        var pixelPositionVal, boxSizingReliableVal,
                            docElem = document.documentElement,
                            container = document.createElement('div'),
                            div = document.createElement('div');

                        if (!div.style) {
                            return;
                        }

                        // Support: IE9-11+
                        // Style of cloned element affects source element cloned (#8908)
                        div.style.backgroundClip = 'content-box';
                        div.cloneNode(true).style.backgroundClip = '';
                        support.clearCloneStyle = div.style.backgroundClip === 'content-box';

                        container.style.cssText = 'border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;' +
                        'position:absolute';
                        container.appendChild(div);

                        // Executing both pixelPosition & boxSizingReliable tests require only one layout
                        // so they're executed at the same time to save the second computation.
                        function computePixelPositionAndBoxSizingReliable() {
                            div.style.cssText =
                                // Support: Firefox<29, Android 2.3
                                // Vendor-prefix box-sizing
                                '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;' +
                                'box-sizing:border-box;display:block;margin-top:1%;top:1%;' +
                                'border:1px;padding:1px;width:4px;position:absolute';
                            div.innerHTML = '';
                            docElem.appendChild(container);

                            var divStyle = window.getComputedStyle(div, null);

                            pixelPositionVal = divStyle.top !== '1%';
                            boxSizingReliableVal = divStyle.width === '4px';

                            docElem.removeChild(container);
                        }

                        // Support: node.js jsdom
                        // Don't assume that getComputedStyle is a property of the global object
                        if (window.getComputedStyle) {
                            jQuery.extend(support, {
                                pixelPosition: function () {

                                    // This test is executed only once but we still do memoizing
                                    // since we can use the boxSizingReliable pre-computing.
                                    // No need to check if the test was already performed, though.
                                    computePixelPositionAndBoxSizingReliable();

                                    return pixelPositionVal;
                                },
                                boxSizingReliable: function () {
                                    if (boxSizingReliableVal == null) {
                                        computePixelPositionAndBoxSizingReliable();
                                    }

                                    return boxSizingReliableVal;
                                },
                                reliableMarginRight: function () {

                                    // Support: Android 2.3
                                    // Check if div with explicit width and no margin-right incorrectly
                                    // gets computed margin-right based on width of container. (#3333)
                                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                                    // This support function is only executed once so no memoizing is needed.
                                    var ret,
                                        marginDiv = div.appendChild(document.createElement('div'));

                                    // Reset CSS: box-sizing; display; margin; border; padding
                                    marginDiv.style.cssText = div.style.cssText =
                                        // Support: Firefox<29, Android 2.3
                                        // Vendor-prefix box-sizing
                                        '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;' +
                                        'box-sizing:content-box;display:block;margin:0;border:0;padding:0';
                                    marginDiv.style.marginRight = marginDiv.style.width = '0';
                                    div.style.width = '1px';
                                    docElem.appendChild(container);

                                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);

                                    docElem.removeChild(container);
                                    div.removeChild(marginDiv);

                                    return ret;
                                }
                            });
                        }
                    })();


                    // A method for quickly swapping in/out CSS properties to get correct calculations.
                    jQuery.swap = function (elem, options, callback, args) {
                        var ret, name,
                            old = {};

                        // Remember the old values, and insert the new ones
                        for (name in options) {
                            old[ name ] = elem.style[ name ];
                            elem.style[ name ] = options[ name ];
                        }

                        ret = callback.apply(elem, args || []);

                        // Revert the old values
                        for (name in options) {
                            elem.style[ name ] = old[ name ];
                        }

                        return ret;
                    };

                    var
                    // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
                    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                        rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'),
                        rrelNum = new RegExp('^([+-])=(' + pnum + ')', 'i'),

                        cssShow = {
                        position: 'absolute', visibility: 'hidden', display: 'block'
                    },
                        cssNormalTransform = {
                            letterSpacing: '0',
                            fontWeight: '400'
                        },

                        cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];

                    // Return a css property mapped to a potentially vendor prefixed property
                    function vendorPropName(style, name) {

                        // Shortcut for names that are not vendor prefixed
                        if (name in style) {
                            return name;
                        }

                        // Check for vendor prefixed names
                        var capName = name[0].toUpperCase() + name.slice(1),
                            origName = name,
                            i = cssPrefixes.length;

                        while (i--) {
                            name = cssPrefixes[ i ] + capName;

                            if (name in style) {
                                return name;
                            }
                        }

                        return origName;
                    }

                    function setPositiveNumber(elem, value, subtract) {
                        var matches = rnumsplit.exec(value);

                        return matches ?
                            // Guard against undefined "subtract", e.g., when used as in cssHooks
                        Math.max(0, matches[ 1 ] - (subtract || 0)) + (matches[ 2 ] || 'px') :
                            value;
                    }

                    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
                        var i = extra === (isBorderBox ? 'border' : 'content') ?
                                // If we already have the right measurement, avoid augmentation
                                4 :
                                // Otherwise initialize for horizontal or vertical properties
                                name === 'width' ? 1 : 0,

                            val = 0;

                        for (; i < 4; i += 2) {
                            // Both box models exclude margin, so add it if we want it
                            if (extra === 'margin') {
                                val += jQuery.css(elem, extra + cssExpand[ i ], true, styles);
                            }

                            if (isBorderBox) {
                                // border-box includes padding, so remove it if we want content
                                if (extra === 'content') {
                                    val -= jQuery.css(elem, 'padding' + cssExpand[ i ], true, styles);
                                }

                                // At this point, extra isn't border nor margin, so remove border
                                if (extra !== 'margin') {
                                    val -= jQuery.css(elem, 'border' + cssExpand[ i ] + 'Width', true, styles);
                                }
                            } else {
                                // At this point, extra isn't content, so add padding
                                val += jQuery.css(elem, 'padding' + cssExpand[ i ], true, styles);

                                // At this point, extra isn't content nor padding, so add border
                                if (extra !== 'padding') {
                                    val += jQuery.css(elem, 'border' + cssExpand[ i ] + 'Width', true, styles);
                                }
                            }
                        }

                        return val;
                    }

                    function getWidthOrHeight(elem, name, extra) {

                        // Start with offset property, which is equivalent to the border-box value
                        var valueIsBorderBox = true,
                            val = name === 'width' ? elem.offsetWidth : elem.offsetHeight,
                            styles = getStyles(elem),
                            isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';

                        // Some non-html elements return undefined for offsetWidth, so check for null/undefined
                        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                        if (val <= 0 || val == null) {
                            // Fall back to computed then uncomputed css if necessary
                            val = curCSS(elem, name, styles);

                            if (val < 0 || val == null) {
                                val = elem.style[ name ];
                            }

                            // Computed unit is not pixels. Stop here and return.
                            if (rnumnonpx.test(val)) {
                                return val;
                            }

                            // Check for style in case a browser which returns unreliable values
                            // for getComputedStyle silently falls back to the reliable elem.style
                            valueIsBorderBox = isBorderBox &&
                            (support.boxSizingReliable() || val === elem.style[ name ]);

                            // Normalize "", auto, and prepare for extra
                            val = parseFloat(val) || 0;
                        }

                        // Use the active box-sizing model to add/subtract irrelevant styles
                        return val +
                            augmentWidthOrHeight(
                                elem,
                                name,
                                extra || (isBorderBox ? 'border' : 'content'),
                                valueIsBorderBox,
                                styles
                            ) +
                             'px';
                    }

                    function showHide(elements, show) {
                        var display, elem, hidden,
                            values = [],
                            index = 0,
                            length = elements.length;

                        for (; index < length; index++) {
                            elem = elements[ index ];

                            if (!elem.style) {
                                continue;
                            }

                            values[ index ] = data_priv.get(elem, 'olddisplay');
                            display = elem.style.display;

                            if (show) {
                                // Reset the inline display of this element to learn if it is
                                // being hidden by cascaded rules or not
                                if (!values[ index ] && display === 'none') {
                                    elem.style.display = '';
                                }

                                // Set elements which have been overridden with display: none
                                // in a stylesheet to whatever the default browser style is
                                // for such an element
                                if (elem.style.display === '' && isHidden(elem)) {
                                    values[ index ] = data_priv.access(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                                }
                            } else {
                                hidden = isHidden(elem);

                                if (display !== 'none' || !hidden) {
                                    data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                                }
                            }
                        }

                        // Set the display of most of the elements in a second loop
                        // to avoid the constant reflow
                        for (index = 0; index < length; index++) {
                            elem = elements[ index ];

                            if (!elem.style) {
                                continue;
                            }

                            if (!show || elem.style.display === 'none' || elem.style.display === '') {
                                elem.style.display = show ? values[ index ] || '' : 'none';
                            }
                        }

                        return elements;
                    }

                    jQuery.extend({

                        // Add in style property hooks for overriding the default
                        // behavior of getting and setting a style property
                        cssHooks: {
                            opacity: {
                                get: function (elem, computed) {
                                    if (computed) {

                                        // We should always get a number back from opacity
                                        var ret = curCSS(elem, 'opacity');

                                        return ret === '' ? '1' : ret;
                                    }
                                }
                            }
                        },

                        // Don't automatically add "px" to these possibly-unitless properties
                        cssNumber: {
                            'columnCount': true,
                            'fillOpacity': true,
                            'flexGrow': true,
                            'flexShrink': true,
                            'fontWeight': true,
                            'lineHeight': true,
                            'opacity': true,
                            'order': true,
                            'orphans': true,
                            'widows': true,
                            'zIndex': true,
                            'zoom': true
                        },

                        // Add in properties whose names you wish to fix before
                        // setting or getting the value
                        cssProps: {
                            'float': 'cssFloat'
                        },

                        // Get and set the style property on a DOM Node
                        style: function (elem, name, value, extra) {

                            // Don't set styles on text and comment nodes
                            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                                return;
                            }

                            // Make sure that we're working with the right name
                            var ret, type, hooks,
                                origName = jQuery.camelCase(name),
                                style = elem.style;

                            name = jQuery.cssProps[ origName ] || (jQuery.cssProps[ origName ] = vendorPropName(style, origName));

                            // Gets hook for the prefixed version, then unprefixed version
                            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                            // Check if we're setting a value
                            if (value !== undefined) {
                                type = typeof value;

                                // Convert "+=" or "-=" to relative numbers (#7345)
                                if (type === 'string' && (ret = rrelNum.exec(value))) {
                                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                                    // Fixes bug #9237
                                    type = 'number';
                                }

                                // Make sure that null and NaN values aren't set (#7116)
                                if (value == null || value !== value) {
                                    return;
                                }

                                // If a number, add 'px' to the (except for certain CSS properties)
                                if (type === 'number' && !jQuery.cssNumber[ origName ]) {
                                    value += 'px';
                                }

                                // Support: IE9-11+
                                // background-* props affect original clone's values
                                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                                    style[ name ] = 'inherit';
                                }

                                // If a hook was provided, use that value, otherwise just set the specified value
                                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                                    style[ name ] = value;
                                }

                            } else {
                                // If a hook was provided get the non-computed value from there
                                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                                    return ret;
                                }

                                // Otherwise just get the value from the style object
                                return style[ name ];
                            }
                        },

                        css: function (elem, name, extra, styles) {
                            var val, num, hooks,
                                origName = jQuery.camelCase(name);

                            // Make sure that we're working with the right name
                            name = jQuery.cssProps[ origName ] || (jQuery.cssProps[ origName ] = vendorPropName(elem.style, origName));

                            // Try prefixed name followed by the unprefixed name
                            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                            // If a hook was provided get the computed value from there
                            if (hooks && 'get' in hooks) {
                                val = hooks.get(elem, true, extra);
                            }

                            // Otherwise, if a way to get the computed value exists, use that
                            if (val === undefined) {
                                val = curCSS(elem, name, styles);
                            }

                            // Convert "normal" to computed value
                            if (val === 'normal' && name in cssNormalTransform) {
                                val = cssNormalTransform[ name ];
                            }

                            // Make numeric if forced or a qualifier was provided and val looks numeric
                            if (extra === '' || extra) {
                                num = parseFloat(val);

                                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
                            }

                            return val;
                        }
                    });

                    jQuery.each(['height', 'width'], function (i, name) {
                        jQuery.cssHooks[ name ] = {
                            get: function (elem, computed, extra) {
                                if (computed) {

                                    // Certain elements can have dimension info if we invisibly show them
                                    // but it must have a current display style that would benefit
                                    return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0 ?
                                        jQuery.swap(elem, cssShow, function () {
                                            return getWidthOrHeight(elem, name, extra);
                                        }) :
                                        getWidthOrHeight(elem, name, extra);
                                }
                            },

                            set: function (elem, value, extra) {
                                var styles = extra && getStyles(elem);

                                return setPositiveNumber(elem, value, extra ?
                                        augmentWidthOrHeight(
                                            elem,
                                            name,
                                            extra,
                                            jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',
                                            styles
                                        ) : 0
                                );
                            }
                        };
                    });

                    // Support: Android 2.3
                    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
                        function (elem, computed) {
                            if (computed) {
                                return jQuery.swap(elem, {
                                    'display': 'inline-block'
                                },
                                    curCSS, [elem, 'marginRight']);
                            }
                        }
                    );

                    // These hooks are used by animate to expand properties
                    jQuery.each({
                        margin: '',
                        padding: '',
                        border: 'Width'
                    }, function (prefix, suffix) {
                        jQuery.cssHooks[ prefix + suffix ] = {
                            expand: function (value) {
                                var i = 0,
                                    expanded = {},

                                // Assumes a single number if not a string
                                    parts = typeof value === 'string' ? value.split(' ') : [value];

                                for (; i < 4; i++) {
                                    expanded[ prefix + cssExpand[ i ] + suffix ] =
                                        parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                                }

                                return expanded;
                            }
                        };

                        if (!rmargin.test(prefix)) {
                            jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
                        }
                    });

                    jQuery.fn.extend({
                        css: function (name, value) {
                            return access(this, function (elem, name, value) {
                                var styles, len,
                                    map = {},
                                    i = 0;

                                if (jQuery.isArray(name)) {
                                    styles = getStyles(elem);
                                    len = name.length;

                                    for (; i < len; i++) {
                                        map[ name[ i ] ] = jQuery.css(elem, name[ i ], false, styles);
                                    }

                                    return map;
                                }

                                return value !== undefined ?
                                    jQuery.style(elem, name, value) :
                                    jQuery.css(elem, name);
                            }, name, value, arguments.length > 1);
                        },
                        show: function () {
                            return showHide(this, true);
                        },
                        hide: function () {
                            return showHide(this);
                        },
                        toggle: function (state) {
                            if (typeof state === 'boolean') {
                                return state ? this.show() : this.hide();
                            }

                            return this.each(function () {
                                if (isHidden(this)) {
                                    jQuery(this).show();
                                } else {
                                    jQuery(this).hide();
                                }
                            });
                        }
                    });

                    function Tween(elem, options, prop, end, easing) {
                        return new Tween.prototype.init(elem, options, prop, end, easing);
                    }
                    jQuery.Tween = Tween;

                    Tween.prototype = {
                        constructor: Tween,
                        init: function (elem, options, prop, end, easing, unit) {
                            this.elem = elem;
                            this.prop = prop;
                            this.easing = easing || 'swing';
                            this.options = options;
                            this.start = this.now = this.cur();
                            this.end = end;
                            this.unit = unit || (jQuery.cssNumber[ prop ] ? '' : 'px');
                        },
                        cur: function () {
                            var hooks = Tween.propHooks[ this.prop ];

                            return hooks && hooks.get ?
                                hooks.get(this) :
                                Tween.propHooks._default.get(this);
                        },
                        run: function (percent) {
                            var eased,
                                hooks = Tween.propHooks[ this.prop ];

                            if (this.options.duration) {
                                this.pos = eased = jQuery.easing[ this.easing ](
                                    percent, this.options.duration * percent, 0, 1, this.options.duration
                                );
                            } else {
                                this.pos = eased = percent;
                            }
                            this.now = (this.end - this.start) * eased + this.start;

                            if (this.options.step) {
                                this.options.step.call(this.elem, this.now, this);
                            }

                            if (hooks && hooks.set) {
                                hooks.set(this);
                            } else {
                                Tween.propHooks._default.set(this);
                            }

                            return this;
                        }
                    };

                    Tween.prototype.init.prototype = Tween.prototype;

                    Tween.propHooks = {
                        _default: {
                            get: function (tween) {
                                var result;

                                if (tween.elem[ tween.prop ] != null &&
                                    (!tween.elem.style || tween.elem.style[ tween.prop ] == null)) {
                                    return tween.elem[ tween.prop ];
                                }

                                // Passing an empty string as a 3rd parameter to .css will automatically
                                // attempt a parseFloat and fallback to a string if the parse fails.
                                // Simple values such as "10px" are parsed to Float;
                                // complex values such as "rotate(1rad)" are returned as-is.
                                result = jQuery.css(tween.elem, tween.prop, '');
                                // Empty strings, null, undefined and "auto" are converted to 0.
                                return !result || result === 'auto' ? 0 : result;
                            },
                            set: function (tween) {
                                // Use step hook for back compat.
                                // Use cssHook if its there.
                                // Use .style if available and use plain properties where available.
                                if (jQuery.fx.step[ tween.prop ]) {
                                    jQuery.fx.step[ tween.prop ](tween);
                                } else if (tween.elem.style && (tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ])) {
                                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                                } else {
                                    tween.elem[ tween.prop ] = tween.now;
                                }
                            }
                        }
                    };

                    // Support: IE9
                    // Panic based approach to setting things on disconnected nodes
                    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                        set: function (tween) {
                            if (tween.elem.nodeType && tween.elem.parentNode) {
                                tween.elem[ tween.prop ] = tween.now;
                            }
                        }
                    };

                    jQuery.easing = {
                        linear: function (p) {
                            return p;
                        },
                        swing: function (p) {
                            return 0.5 - Math.cos(p * Math.PI) / 2;
                        }
                    };

                    jQuery.fx = Tween.prototype.init;

                    // Back Compat <1.8 extension point
                    jQuery.fx.step = {};

                    var
                        fxNow, timerId,
                        rfxtypes = /^(?:toggle|show|hide)$/,
                        rfxnum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i'),
                        rrun = /queueHooks$/,
                        animationPrefilters = [defaultPrefilter],
                        tweeners = {
                            '*': [function (prop, value) {
                                var tween = this.createTween(prop, value),
                                    target = tween.cur(),
                                    parts = rfxnum.exec(value),
                                    unit = parts && parts[ 3 ] || (jQuery.cssNumber[ prop ] ? '' : 'px'),

                                // Starting value computation is required for potential unit mismatches
                                    start = (jQuery.cssNumber[ prop ] || unit !== 'px' && +target) &&
                                        rfxnum.exec(jQuery.css(tween.elem, prop)),
                                    scale = 1,
                                    maxIterations = 20;

                                if (start && start[ 3 ] !== unit) {
                                    // Trust units reported by jQuery.css
                                    unit = unit || start[ 3 ];

                                    // Make sure we update the tween properties later on
                                    parts = parts || [];

                                    // Iteratively approximate from a nonzero starting point
                                    start = +target || 1;

                                    do {
                                        // If previous iteration zeroed out, double until we get *something*.
                                        // Use string for doubling so we don't accidentally see scale as unchanged below
                                        scale = scale || '.5';

                                        // Adjust and apply
                                        start /= scale;
                                        jQuery.style(tween.elem, prop, start + unit);

                                        // Update scale, tolerating zero or NaN from tween.cur(),
                                        // break the loop if scale is unchanged or perfect, or if we've just had enough
                                    } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                                }

                                // Update tween properties
                                if (parts) {
                                    start = tween.start = +start || +target || 0;
                                    tween.unit = unit;
                                    // If a +=/-= token was provided, we're doing a relative animation
                                    tween.end = parts[ 1 ] ?
                                    start + (parts[ 1 ] + 1) * parts[ 2 ] :
                                        +parts[ 2 ];
                                }

                                return tween;
                            }]
                        };

                    // Animations created synchronously will run synchronously
                    function createFxNow() {
                        setTimeout(function () {
                            fxNow = undefined;
                        });

                        return fxNow = jQuery.now();
                    }

                    // Generate parameters to create a standard animation
                    function genFx(type, includeWidth) {
                        var which,
                            i = 0,
                            attrs = {
                            height: type
                        };

                        // If we include width, step value is 1 to do all cssExpand values,
                        // otherwise step value is 2 to skip over Left and Right
                        includeWidth = includeWidth ? 1 : 0;

                        for (; i < 4; i += 2 - includeWidth) {
                            which = cssExpand[ i ];
                            attrs[ 'margin' + which ] = attrs[ 'padding' + which ] = type;
                        }

                        if (includeWidth) {
                            attrs.opacity = attrs.width = type;
                        }

                        return attrs;
                    }

                    function createTween(value, prop, animation) {
                        var tween,
                            collection = (tweeners[ prop ] || []).concat(tweeners[ '*' ]),
                            index = 0,
                            length = collection.length;

                        for (; index < length; index++) {
                            if (tween = collection[ index ].call(animation, prop, value)) {

                                // We're done with this property
                                return tween;
                            }
                        }
                    }

                    function defaultPrefilter(elem, props, opts) {
                        /* jshint validthis: true */
                        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
                            anim = this,
                            orig = {},
                            style = elem.style,
                            hidden = elem.nodeType && isHidden(elem),
                            dataShow = data_priv.get(elem, 'fxshow');

                        // Handle queue: false promises
                        if (!opts.queue) {
                            hooks = jQuery._queueHooks(elem, 'fx');

                            if (hooks.unqueued == null) {
                                hooks.unqueued = 0;
                                oldfire = hooks.empty.fire;
                                hooks.empty.fire = function () {
                                    if (!hooks.unqueued) {
                                        oldfire();
                                    }
                                };
                            }
                            hooks.unqueued++;

                            anim.always(function () {
                                // Ensure the complete handler is called before this completes
                                anim.always(function () {
                                    hooks.unqueued--;

                                    if (!jQuery.queue(elem, 'fx').length) {
                                        hooks.empty.fire();
                                    }
                                });
                            });
                        }

                        // Height/width overflow pass
                        if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
                            // Make sure that nothing sneaks out
                            // Record all 3 overflow attributes because IE9-10 do not
                            // change the overflow attribute when overflowX and
                            // overflowY are set to the same value
                            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

                            // Set display property to inline-block for height/width
                            // animations on inline elements that are having width/height animated
                            display = jQuery.css(elem, 'display');

                            // Test default display if display is currently "none"
                            checkDisplay = display === 'none' ?
                            data_priv.get(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display;

                            if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {
                                style.display = 'inline-block';
                            }
                        }

                        if (opts.overflow) {
                            style.overflow = 'hidden';
                            anim.always(function () {
                                style.overflow = opts.overflow[ 0 ];
                                style.overflowX = opts.overflow[ 1 ];
                                style.overflowY = opts.overflow[ 2 ];
                            });
                        }

                        // show/hide pass
                        for (prop in props) {
                            value = props[ prop ];

                            if (rfxtypes.exec(value)) {
                                delete props[ prop ];
                                toggle = toggle || value === 'toggle';

                                if (value === (hidden ? 'hide' : 'show')) {

                                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                                    if (value === 'show' && dataShow && dataShow[ prop ] !== undefined) {
                                        hidden = true;
                                    } else {
                                        continue;
                                    }
                                }
                                orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style(elem, prop);

                                // Any non-fx value stops us from restoring the original display value
                            } else {
                                display = undefined;
                            }
                        }

                        if (!jQuery.isEmptyObject(orig)) {
                            if (dataShow) {
                                if ('hidden' in dataShow) {
                                    hidden = dataShow.hidden;
                                }
                            } else {
                                dataShow = data_priv.access(elem, 'fxshow', {});
                            }

                            // Store state if its toggle - enables .stop().toggle() to "reverse"
                            if (toggle) {
                                dataShow.hidden = !hidden;
                            }

                            if (hidden) {
                                jQuery(elem).show();
                            } else {
                                anim.done(function () {
                                    jQuery(elem).hide();
                                });
                            }
                            anim.done(function () {
                                var prop;

                                data_priv.remove(elem, 'fxshow');

                                for (prop in orig) {
                                    jQuery.style(elem, prop, orig[ prop ]);
                                }
                            });

                            for (prop in orig) {
                                tween = createTween(hidden ? dataShow[ prop ] : 0, prop, anim);

                                if (!(prop in dataShow)) {
                                    dataShow[ prop ] = tween.start;

                                    if (hidden) {
                                        tween.end = tween.start;
                                        tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                                    }
                                }
                            }

                            // If this is a noop like .hide().hide(), restore an overwritten display value
                        } else if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {
                            style.display = display;
                        }
                    }

                    function propFilter(props, specialEasing) {
                        var index, name, easing, value, hooks;

                        // camelCase, specialEasing and expand cssHook pass
                        for (index in props) {
                            name = jQuery.camelCase(index);
                            easing = specialEasing[ name ];
                            value = props[ index ];

                            if (jQuery.isArray(value)) {
                                easing = value[ 1 ];
                                value = props[ index ] = value[ 0 ];
                            }

                            if (index !== name) {
                                props[ name ] = value;
                                delete props[ index ];
                            }

                            hooks = jQuery.cssHooks[ name ];

                            if (hooks && 'expand' in hooks) {
                                value = hooks.expand(value);
                                delete props[ name ];

                                // Not quite $.extend, this won't overwrite existing keys.
                                // Reusing 'index' because we have the correct "name"
                                for (index in value) {
                                    if (!(index in props)) {
                                        props[ index ] = value[ index ];
                                        specialEasing[ index ] = easing;
                                    }
                                }
                            } else {
                                specialEasing[ name ] = easing;
                            }
                        }
                    }

                    function Animation(elem, properties, options) {
                        var result,
                            stopped,
                            index = 0,
                            length = animationPrefilters.length,
                            deferred = jQuery.Deferred().always(function () {
                                // Don't match elem in the :animated selector
                                delete tick.elem;
                            }),
                            tick = function () {
                                if (stopped) {
                                    return false;
                                }
                                var currentTime = fxNow || createFxNow(),
                                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                                // Support: Android 2.3
                                // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                                    temp = remaining / animation.duration || 0,
                                    percent = 1 - temp,
                                    index = 0,
                                    length = animation.tweens.length;

                                for (; index < length; index++) {
                                    animation.tweens[ index ].run(percent);
                                }

                                deferred.notifyWith(elem, [animation, percent, remaining]);

                                if (percent < 1 && length) {
                                    return remaining;
                                }
                                deferred.resolveWith(elem, [animation]);

                                return false;

                            },
                            animation = deferred.promise({
                                elem: elem,
                                props: jQuery.extend({}, properties),
                                opts: jQuery.extend(true, {
                                    specialEasing: {}
                                }, options),
                                originalProperties: properties,
                                originalOptions: options,
                                startTime: fxNow || createFxNow(),
                                duration: options.duration,
                                tweens: [],
                                createTween: function (prop, end) {
                                    var tween = jQuery.Tween(elem, animation.opts, prop, end,
                                        animation.opts.specialEasing[ prop ] || animation.opts.easing);

                                    animation.tweens.push(tween);

                                    return tween;
                                },
                                stop: function (gotoEnd) {
                                    var index = 0,
                                    // If we are going to the end, we want to run all the tweens
                                    // otherwise we skip this part
                                        length = gotoEnd ? animation.tweens.length : 0;

                                    if (stopped) {
                                        return this;
                                    }
                                    stopped = true;

                                    for (; index < length; index++) {
                                        animation.tweens[ index ].run(1);
                                    }

                                    // Resolve when we played the last frame; otherwise, reject
                                    if (gotoEnd) {
                                        deferred.resolveWith(elem, [animation, gotoEnd]);
                                    } else {
                                        deferred.rejectWith(elem, [animation, gotoEnd]);
                                    }

                                    return this;
                                }
                            }),
                            props = animation.props;

                        propFilter(props, animation.opts.specialEasing);

                        for (; index < length; index++) {
                            result = animationPrefilters[ index ].call(animation, elem, props, animation.opts);

                            if (result) {
                                return result;
                            }
                        }

                        jQuery.map(props, createTween, animation);

                        if (jQuery.isFunction(animation.opts.start)) {
                            animation.opts.start.call(elem, animation);
                        }

                        jQuery.fx.timer(
                            jQuery.extend(tick, {
                                elem: elem,
                                anim: animation,
                                queue: animation.opts.queue
                            })
                        );

                        // attach callbacks from options
                        return animation.progress(animation.opts.progress)
                            .done(animation.opts.done, animation.opts.complete)
                            .fail(animation.opts.fail)
                            .always(animation.opts.always);
                    }

                    jQuery.Animation = jQuery.extend(Animation, {

                        tweener: function (props, callback) {
                            if (jQuery.isFunction(props)) {
                                callback = props;
                                props = ['*'];
                            } else {
                                props = props.split(' ');
                            }

                            var prop,
                                index = 0,
                                length = props.length;

                            for (; index < length; index++) {
                                prop = props[ index ];
                                tweeners[ prop ] = tweeners[ prop ] || [];
                                tweeners[ prop ].unshift(callback);
                            }
                        },

                        prefilter: function (callback, prepend) {
                            if (prepend) {
                                animationPrefilters.unshift(callback);
                            } else {
                                animationPrefilters.push(callback);
                            }
                        }
                    });

                    jQuery.speed = function (speed, easing, fn) {
                        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
                            complete: fn || !fn && easing ||
                            jQuery.isFunction(speed) && speed,
                            duration: speed,
                            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                        };

                        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration :
                            opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

                        // Normalize opt.queue - true/undefined/null -> "fx"
                        if (opt.queue == null || opt.queue === true) {
                            opt.queue = 'fx';
                        }

                        // Queueing
                        opt.old = opt.complete;

                        opt.complete = function () {
                            if (jQuery.isFunction(opt.old)) {
                                opt.old.call(this);
                            }

                            if (opt.queue) {
                                jQuery.dequeue(this, opt.queue);
                            }
                        };

                        return opt;
                    };

                    jQuery.fn.extend({
                        fadeTo: function (speed, to, easing, callback) {

                            // Show any hidden elements after setting opacity to 0
                            return this.filter(isHidden).css('opacity', 0).show()

                                // Animate to the value specified
                                .end().animate({
                                opacity: to
                            }, speed, easing, callback);
                        },
                        animate: function (prop, speed, easing, callback) {
                            var empty = jQuery.isEmptyObject(prop),
                                optall = jQuery.speed(speed, easing, callback),
                                doAnimation = function () {
                                    // Operate on a copy of prop so per-property easing won't be lost
                                    var anim = Animation(this, jQuery.extend({}, prop), optall);

                                    // Empty animations, or finishing resolves immediately
                                    if (empty || data_priv.get(this, 'finish')) {
                                        anim.stop(true);
                                    }
                                };

                            doAnimation.finish = doAnimation;

                            return empty || optall.queue === false ?
                                this.each(doAnimation) :
                                this.queue(optall.queue, doAnimation);
                        },
                        stop: function (type, clearQueue, gotoEnd) {
                            var stopQueue = function (hooks) {
                                var stop = hooks.stop;

                                delete hooks.stop;
                                stop(gotoEnd);
                            };

                            if (typeof type !== 'string') {
                                gotoEnd = clearQueue;
                                clearQueue = type;
                                type = undefined;
                            }

                            if (clearQueue && type !== false) {
                                this.queue(type || 'fx', []);
                            }

                            return this.each(function () {
                                var dequeue = true,
                                    index = type != null && type + 'queueHooks',
                                    timers = jQuery.timers,
                                    data = data_priv.get(this);

                                if (index) {
                                    if (data[ index ] && data[ index ].stop) {
                                        stopQueue(data[ index ]);
                                    }
                                } else {
                                    for (index in data) {
                                        if (data[ index ] && data[ index ].stop && rrun.test(index)) {
                                            stopQueue(data[ index ]);
                                        }
                                    }
                                }

                                for (index = timers.length; index--;) {
                                    if (timers[ index ].elem === this && (type == null || timers[ index ].queue === type)) {
                                        timers[ index ].anim.stop(gotoEnd);
                                        dequeue = false;
                                        timers.splice(index, 1);
                                    }
                                }

                                // Start the next in the queue if the last step wasn't forced.
                                // Timers currently will call their complete callbacks, which
                                // will dequeue but only if they were gotoEnd.
                                if (dequeue || !gotoEnd) {
                                    jQuery.dequeue(this, type);
                                }
                            });
                        },
                        finish: function (type) {
                            if (type !== false) {
                                type = type || 'fx';
                            }

                            return this.each(function () {
                                var index,
                                    data = data_priv.get(this),
                                    queue = data[ type + 'queue' ],
                                    hooks = data[ type + 'queueHooks' ],
                                    timers = jQuery.timers,
                                    length = queue ? queue.length : 0;

                                // Enable finishing flag on private data
                                data.finish = true;

                                // Empty the queue first
                                jQuery.queue(this, type, []);

                                if (hooks && hooks.stop) {
                                    hooks.stop.call(this, true);
                                }

                                // Look for any active animations, and finish them
                                for (index = timers.length; index--;) {
                                    if (timers[ index ].elem === this && timers[ index ].queue === type) {
                                        timers[ index ].anim.stop(true);
                                        timers.splice(index, 1);
                                    }
                                }

                                // Look for any animations in the old queue and finish them
                                for (index = 0; index < length; index++) {
                                    if (queue[ index ] && queue[ index ].finish) {
                                        queue[ index ].finish.call(this);
                                    }
                                }

                                // Turn off finishing flag
                                delete data.finish;
                            });
                        }
                    });

                    jQuery.each(['toggle', 'show', 'hide'], function (i, name) {
                        var cssFn = jQuery.fn[ name ];

                        jQuery.fn[ name ] = function (speed, easing, callback) {
                            return speed == null || typeof speed === 'boolean' ?
                                cssFn.apply(this, arguments) :
                                this.animate(genFx(name, true), speed, easing, callback);
                        };
                    });

                    // Generate shortcuts for custom animations
                    jQuery.each({
                        slideDown: genFx('show'),
                        slideUp: genFx('hide'),
                        slideToggle: genFx('toggle'),
                        fadeIn: {
                            opacity: 'show'
                        },
                        fadeOut: {
                            opacity: 'hide'
                        },
                        fadeToggle: {
                            opacity: 'toggle'
                        }
                    }, function (name, props) {
                        jQuery.fn[ name ] = function (speed, easing, callback) {
                            return this.animate(props, speed, easing, callback);
                        };
                    });

                    jQuery.timers = [];
                    jQuery.fx.tick = function () {
                        var timer,
                            i = 0,
                            timers = jQuery.timers;

                        fxNow = jQuery.now();

                        for (; i < timers.length; i++) {
                            timer = timers[ i ];
                            // Checks the timer has not already been removed
                            if (!timer() && timers[ i ] === timer) {
                                timers.splice(i--, 1);
                            }
                        }

                        if (!timers.length) {
                            jQuery.fx.stop();
                        }
                        fxNow = undefined;
                    };

                    jQuery.fx.timer = function (timer) {
                        jQuery.timers.push(timer);

                        if (timer()) {
                            jQuery.fx.start();
                        } else {
                            jQuery.timers.pop();
                        }
                    };

                    jQuery.fx.interval = 13;

                    jQuery.fx.start = function () {
                        if (!timerId) {
                            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
                        }
                    };

                    jQuery.fx.stop = function () {
                        clearInterval(timerId);
                        timerId = null;
                    };

                    jQuery.fx.speeds = {
                        slow: 600,
                        fast: 200,
                        // Default speed
                        _default: 400
                    };


                    // Based off of the plugin by Clint Helfers, with permission.
                    // http://blindsignals.com/index.php/2009/07/jquery-delay/
                    jQuery.fn.delay = function (time, type) {
                        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
                        type = type || 'fx';

                        return this.queue(type, function (next, hooks) {
                            var timeout = setTimeout(next, time);

                            hooks.stop = function () {
                                clearTimeout(timeout);
                            };
                        });
                    };

                    (function () {
                        var input = document.createElement('input'),
                            select = document.createElement('select'),
                            opt = select.appendChild(document.createElement('option'));

                        input.type = 'checkbox';

                        // Support: iOS<=5.1, Android<=4.2+
                        // Default value for a checkbox should be "on"
                        support.checkOn = input.value !== '';

                        // Support: IE<=11+
                        // Must access selectedIndex to make default options select
                        support.optSelected = opt.selected;

                        // Support: Android<=2.3
                        // Options inside disabled selects are incorrectly marked as disabled
                        select.disabled = true;
                        support.optDisabled = !opt.disabled;

                        // Support: IE<=11+
                        // An input loses its value after becoming a radio
                        input = document.createElement('input');
                        input.value = 't';
                        input.type = 'radio';
                        support.radioValue = input.value === 't';
                    })();

                    var nodeHook, boolHook,
                        attrHandle = jQuery.expr.attrHandle;

                    jQuery.fn.extend({
                        attr: function (name, value) {
                            return access(this, jQuery.attr, name, value, arguments.length > 1);
                        },

                        removeAttr: function (name) {
                            return this.each(function () {
                                jQuery.removeAttr(this, name);
                            });
                        }
                    });

                    jQuery.extend({
                        attr: function (elem, name, value) {
                            var hooks, ret,
                                nType = elem.nodeType;

                            // don't get/set attributes on text, comment and attribute nodes
                            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                                return;
                            }

                            // Fallback to prop when attributes are not supported
                            if (typeof elem.getAttribute === strundefined) {
                                return jQuery.prop(elem, name, value);
                            }

                            // All attributes are lowercase
                            // Grab necessary hook if one is defined
                            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                                name = name.toLowerCase();
                                hooks = jQuery.attrHooks[ name ] ||
                                (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
                            }

                            if (value !== undefined) {

                                if (value === null) {
                                    jQuery.removeAttr(elem, name);

                                } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                                    return ret;

                                } else {
                                    elem.setAttribute(name, value + '');

                                    return value;
                                }

                            } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                                return ret;

                            } else {
                                ret = jQuery.find.attr(elem, name);

                                // Non-existent attributes return null, we normalize to undefined
                                return ret == null ?
                                    undefined :
                                    ret;
                            }
                        },

                        removeAttr: function (elem, value) {
                            var name, propName,
                                i = 0,
                                attrNames = value && value.match(rnotwhite);

                            if (attrNames && elem.nodeType === 1) {
                                while (name = attrNames[i++]) {
                                    propName = jQuery.propFix[ name ] || name;

                                    // Boolean attributes get special treatment (#10870)
                                    if (jQuery.expr.match.bool.test(name)) {
                                        // Set corresponding property to false
                                        elem[ propName ] = false;
                                    }

                                    elem.removeAttribute(name);
                                }
                            }
                        },

                        attrHooks: {
                            type: {
                                set: function (elem, value) {
                                    if (!support.radioValue && value === 'radio' &&
                                        jQuery.nodeName(elem, 'input')) {
                                        var val = elem.value;

                                        elem.setAttribute('type', value);

                                        if (val) {
                                            elem.value = val;
                                        }

                                        return value;
                                    }
                                }
                            }
                        }
                    });

                    // Hooks for boolean attributes
                    boolHook = {
                        set: function (elem, value, name) {
                            if (value === false) {
                                // Remove boolean attributes when set to false
                                jQuery.removeAttr(elem, name);
                            } else {
                                elem.setAttribute(name, name);
                            }

                            return name;
                        }
                    };
                    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
                        var getter = attrHandle[ name ] || jQuery.find.attr;

                        attrHandle[ name ] = function (elem, name, isXML) {
                            var ret, handle;

                            if (!isXML) {
                                // Avoid an infinite loop by temporarily removing this function from the getter
                                handle = attrHandle[ name ];
                                attrHandle[ name ] = ret;
                                ret = getter(elem, name, isXML) != null ?
                                    name.toLowerCase() :
                                    null;
                                attrHandle[ name ] = handle;
                            }

                            return ret;
                        };
                    });

                    var rfocusable = /^(?:input|select|textarea|button)$/i;

                    jQuery.fn.extend({
                        prop: function (name, value) {
                            return access(this, jQuery.prop, name, value, arguments.length > 1);
                        },

                        removeProp: function (name) {
                            return this.each(function () {
                                delete this[ jQuery.propFix[ name ] || name ];
                            });
                        }
                    });

                    jQuery.extend({
                        propFix: {
                            'for': 'htmlFor',
                            'class': 'className'
                        },

                        prop: function (elem, name, value) {
                            var ret, hooks, notxml,
                                nType = elem.nodeType;

                            // Don't get/set properties on text, comment and attribute nodes
                            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                                return;
                            }

                            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

                            if (notxml) {
                                // Fix name and attach hooks
                                name = jQuery.propFix[ name ] || name;
                                hooks = jQuery.propHooks[ name ];
                            }

                            if (value !== undefined) {
                                return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ?
                                    ret :
                                     elem[ name ] = value;

                            }

                            return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ?
                                ret :
                                elem[ name ];

                        },

                        propHooks: {
                            tabIndex: {
                                get: function (elem) {
                                    return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ?
                                        elem.tabIndex :
                                        -1;
                                }
                            }
                        }
                    });

                    if (!support.optSelected) {
                        jQuery.propHooks.selected = {
                            get: function (elem) {
                                var parent = elem.parentNode;

                                if (parent && parent.parentNode) {
                                    parent.parentNode.selectedIndex;
                                }

                                return null;
                            }
                        };
                    }

                    jQuery.each([
                        'tabIndex',
                        'readOnly',
                        'maxLength',
                        'cellSpacing',
                        'cellPadding',
                        'rowSpan',
                        'colSpan',
                        'useMap',
                        'frameBorder',
                        'contentEditable'
                    ], function () {
                        jQuery.propFix[ this.toLowerCase() ] = this;
                    });

                    var rclass = /[\t\r\n\f]/g;

                    jQuery.fn.extend({
                        addClass: function (value) {
                            var classes, elem, cur, clazz, j, finalValue,
                                proceed = typeof value === 'string' && value,
                                i = 0,
                                len = this.length;

                            if (jQuery.isFunction(value)) {
                                return this.each(function (j) {
                                    jQuery(this).addClass(value.call(this, j, this.className));
                                });
                            }

                            if (proceed) {
                                // The disjunction here is for better compressibility (see removeClass)
                                classes = (value || '').match(rnotwhite) || [];

                                for (; i < len; i++) {
                                    elem = this[ i ];
                                    cur = elem.nodeType === 1 && (elem.className ?
                                        (' ' + elem.className + ' ').replace(rclass, ' ') :
                                        ' '
                                    );

                                    if (cur) {
                                        j = 0;

                                        while (clazz = classes[j++]) {
                                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                                cur += clazz + ' ';
                                            }
                                        }

                                        // only assign if different to avoid unneeded rendering.
                                        finalValue = jQuery.trim(cur);

                                        if (elem.className !== finalValue) {
                                            elem.className = finalValue;
                                        }
                                    }
                                }
                            }

                            return this;
                        },

                        removeClass: function (value) {
                            var classes, elem, cur, clazz, j, finalValue,
                                proceed = arguments.length === 0 || typeof value === 'string' && value,
                                i = 0,
                                len = this.length;

                            if (jQuery.isFunction(value)) {
                                return this.each(function (j) {
                                    jQuery(this).removeClass(value.call(this, j, this.className));
                                });
                            }

                            if (proceed) {
                                classes = (value || '').match(rnotwhite) || [];

                                for (; i < len; i++) {
                                    elem = this[ i ];
                                    // This expression is here for better compressibility (see addClass)
                                    cur = elem.nodeType === 1 && (elem.className ?
                                        (' ' + elem.className + ' ').replace(rclass, ' ') :
                                        ''
                                    );

                                    if (cur) {
                                        j = 0;

                                        while (clazz = classes[j++]) {
                                            // Remove *all* instances
                                            while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                                cur = cur.replace(' ' + clazz + ' ', ' ');
                                            }
                                        }

                                        // Only assign if different to avoid unneeded rendering.
                                        finalValue = value ? jQuery.trim(cur) : '';

                                        if (elem.className !== finalValue) {
                                            elem.className = finalValue;
                                        }
                                    }
                                }
                            }

                            return this;
                        },

                        toggleClass: function (value, stateVal) {
                            var type = typeof value;

                            if (typeof stateVal === 'boolean' && type === 'string') {
                                return stateVal ? this.addClass(value) : this.removeClass(value);
                            }

                            if (jQuery.isFunction(value)) {
                                return this.each(function (i) {
                                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                                });
                            }

                            return this.each(function () {
                                if (type === 'string') {
                                    // Toggle individual class names
                                    var className,
                                        i = 0,
                                        self = jQuery(this),
                                        classNames = value.match(rnotwhite) || [];

                                    while (className = classNames[ i++ ]) {
                                        // Check each className given, space separated list
                                        if (self.hasClass(className)) {
                                            self.removeClass(className);
                                        } else {
                                            self.addClass(className);
                                        }
                                    }

                                    // Toggle whole class name
                                } else if (type === strundefined || type === 'boolean') {
                                    if (this.className) {
                                        // store className if set
                                        data_priv.set(this, '__className__', this.className);
                                    }

                                    // If the element has a class name or if we're passed `false`,
                                    // then remove the whole classname (if there was one, the above saved it).
                                    // Otherwise bring back whatever was previously saved (if anything),
                                    // falling back to the empty string if nothing was stored.
                                    this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
                                }
                            });
                        },

                        hasClass: function (selector) {
                            var className = ' ' + selector + ' ',
                                i = 0,
                                l = this.length;

                            for (; i < l; i++) {
                                if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                                    return true;
                                }
                            }

                            return false;
                        }
                    });

                    var rreturn = /\r/g;

                    jQuery.fn.extend({
                        val: function (value) {
                            var hooks, ret, isFunction,
                                elem = this[0];

                            if (!arguments.length) {
                                if (elem) {
                                    hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                                        return ret;
                                    }

                                    ret = elem.value;

                                    return typeof ret === 'string' ?
                                        // Handle most common string cases
                                        ret.replace(rreturn, '') :
                                        // Handle cases where value is null/undef or number
                                        ret == null ? '' : ret;
                                }

                                return;
                            }

                            isFunction = jQuery.isFunction(value);

                            return this.each(function (i) {
                                var val;

                                if (this.nodeType !== 1) {
                                    return;
                                }

                                if (isFunction) {
                                    val = value.call(this, i, jQuery(this).val());
                                } else {
                                    val = value;
                                }

                                // Treat null/undefined as ""; convert numbers to string
                                if (val == null) {
                                    val = '';

                                } else if (typeof val === 'number') {
                                    val += '';

                                } else if (jQuery.isArray(val)) {
                                    val = jQuery.map(val, function (value) {
                                        return value == null ? '' : value + '';
                                    });
                                }

                                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                                // If set returns undefined, fall back to normal setting
                                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                                    this.value = val;
                                }
                            });
                        }
                    });

                    jQuery.extend({
                        valHooks: {
                            option: {
                                get: function (elem) {
                                    var val = jQuery.find.attr(elem, 'value');

                                    return val != null ?
                                        val :
                                        // Support: IE10-11+
                                        // option.text throws exceptions (#14686, #14858)
                                        jQuery.trim(jQuery.text(elem));
                                }
                            },
                            select: {
                                get: function (elem) {
                                    var value, option,
                                        options = elem.options,
                                        index = elem.selectedIndex,
                                        one = elem.type === 'select-one' || index < 0,
                                        values = one ? null : [],
                                        max = one ? index + 1 : options.length,
                                        i = index < 0 ?
                                            max :
                                            one ? index : 0;

                                    // Loop through all the selected options
                                    for (; i < max; i++) {
                                        option = options[ i ];

                                        // IE6-9 doesn't update selected after form reset (#2551)
                                        if ((option.selected || i === index) &&
                                                // Don't return options that are disabled or in a disabled optgroup
                                            (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) &&
                                            (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {

                                            // Get the specific value for the option
                                            value = jQuery(option).val();

                                            // We don't need an array for one selects
                                            if (one) {
                                                return value;
                                            }

                                            // Multi-Selects return an array
                                            values.push(value);
                                        }
                                    }

                                    return values;
                                },

                                set: function (elem, value) {
                                    var optionSet, option,
                                        options = elem.options,
                                        values = jQuery.makeArray(value),
                                        i = options.length;

                                    while (i--) {
                                        option = options[ i ];

                                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                                            optionSet = true;
                                        }
                                    }

                                    // Force browsers to behave consistently when non-matching value is set
                                    if (!optionSet) {
                                        elem.selectedIndex = -1;
                                    }

                                    return values;
                                }
                            }
                        }
                    });

                    // Radios and checkboxes getter/setter
                    jQuery.each(['radio', 'checkbox'], function () {
                        jQuery.valHooks[ this ] = {
                            set: function (elem, value) {
                                if (jQuery.isArray(value)) {
                                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                                }
                            }
                        };

                        if (!support.checkOn) {
                            jQuery.valHooks[ this ].get = function (elem) {
                                return elem.getAttribute('value') === null ? 'on' : elem.value;
                            };
                        }
                    });




                    // Return jQuery for attributes-only inclusion

                    jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' +
                    'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
                    'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {

                        // Handle event binding
                        jQuery.fn[ name ] = function (data, fn) {
                            return arguments.length > 0 ?
                                this.on(name, null, data, fn) :
                                this.trigger(name);
                        };
                    });

                    jQuery.fn.extend({
                        hover: function (fnOver, fnOut) {
                            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
                        },

                        bind: function (types, data, fn) {
                            return this.on(types, null, data, fn);
                        },
                        unbind: function (types, fn) {
                            return this.off(types, null, fn);
                        },

                        delegate: function (selector, types, data, fn) {
                            return this.on(types, selector, data, fn);
                        },
                        undelegate: function (selector, types, fn) {
                            // ( namespace ) or ( selector, types [, fn] )
                            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
                        }
                    });

                    var nonce = jQuery.now();

                    var rquery = (/\?/);



                    // Support: Android 2.3
                    // Workaround failure to string-cast null input
                    jQuery.parseJSON = function (data) {
                        return JSON.parse(data + '');
                    };


                    // Cross-browser xml parsing
                    jQuery.parseXML = function (data) {
                        var xml, tmp;

                        if (!data || typeof data !== 'string') {
                            return null;
                        }

                        // Support: IE9
                        try {
                            tmp = new DOMParser();
                            xml = tmp.parseFromString(data, 'text/xml');
                        } catch (e) {
                            xml = undefined;
                        }

                        if (!xml || xml.getElementsByTagName('parsererror').length) {
                            jQuery.error('Invalid XML: ' + data);
                        }

                        return xml;
                    };

                    var
                        rhash = /#.*$/,
                        rts = /([?&])_=[^&]*/,
                        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
                    // #7653, #8125, #8152: local protocol detection
                        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                        rnoContent = /^(?:GET|HEAD)$/,
                        rprotocol = /^\/\//,
                        rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

                    /* Prefilters
                     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
                     * 2) These are called:
                     *    - BEFORE asking for a transport
                     *    - AFTER param serialization (s.data is a string if s.processData is true)
                     * 3) key is the dataType
                     * 4) the catchall symbol "*" can be used
                     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
                     */
                        prefilters = {},

                    /* Transports bindings
                     * 1) key is the dataType
                     * 2) the catchall symbol "*" can be used
                     * 3) selection will start with transport dataType and THEN go to "*" if needed
                     */
                        transports = {},

                    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                        allTypes = '*/'.concat('*'),

                    // Document location
                        ajaxLocation = window.location.href,

                    // Segment location into parts
                        ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

                    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
                    function addToPrefiltersOrTransports(structure) {

                        // dataTypeExpression is optional and defaults to "*"
                        return function (dataTypeExpression, func) {

                            if (typeof dataTypeExpression !== 'string') {
                                func = dataTypeExpression;
                                dataTypeExpression = '*';
                            }

                            var dataType,
                                i = 0,
                                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

                            if (jQuery.isFunction(func)) {
                                // For each dataType in the dataTypeExpression
                                while (dataType = dataTypes[i++]) {
                                    // Prepend if requested
                                    if (dataType[0] === '+') {
                                        dataType = dataType.slice(1) || '*';
                                        (structure[ dataType ] = structure[ dataType ] || []).unshift(func);

                                        // Otherwise append
                                    } else {
                                        (structure[ dataType ] = structure[ dataType ] || []).push(func);
                                    }
                                }
                            }
                        };
                    }

                    // Base inspection function for prefilters and transports
                    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

                        var inspected = {},
                            seekingTransport =  structure === transports;

                        function inspect(dataType) {
                            var selected;

                            inspected[ dataType ] = true;
                            jQuery.each(structure[ dataType ] || [], function (_, prefilterOrFactory) {
                                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

                                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[ dataTypeOrTransport ]) {
                                    options.dataTypes.unshift(dataTypeOrTransport);
                                    inspect(dataTypeOrTransport);

                                    return false;
                                } else if (seekingTransport) {
                                    return !(selected = dataTypeOrTransport);
                                }
                            });

                            return selected;
                        }

                        return inspect(options.dataTypes[ 0 ]) || !inspected[ '*' ] && inspect('*');
                    }

                    // A special extend for ajax options
                    // that takes "flat" options (not to be deep extended)
                    // Fixes #9887
                    function ajaxExtend(target, src) {
                        var key, deep,
                            flatOptions = jQuery.ajaxSettings.flatOptions || {};

                        for (key in src) {
                            if (src[ key ] !== undefined) {
                                (flatOptions[ key ] ? target :  deep || (deep = {}))[ key ] = src[ key ];
                            }
                        }

                        if (deep) {
                            jQuery.extend(true, target, deep);
                        }

                        return target;
                    }

                    /* Handles responses to an ajax request:
                     * - finds the right dataType (mediates between content-type and expected dataType)
                     * - returns the corresponding response
                     */
                    function ajaxHandleResponses(s, jqXHR, responses) {

                        var ct, type, finalDataType, firstDataType,
                            contents = s.contents,
                            dataTypes = s.dataTypes;

                        // Remove auto dataType and get content-type in the process
                        while (dataTypes[ 0 ] === '*') {
                            dataTypes.shift();

                            if (ct === undefined) {
                                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
                            }
                        }

                        // Check if we're dealing with a known content-type
                        if (ct) {
                            for (type in contents) {
                                if (contents[ type ] && contents[ type ].test(ct)) {
                                    dataTypes.unshift(type);
                                    break;
                                }
                            }
                        }

                        // Check to see if we have a response for the expected dataType
                        if (dataTypes[ 0 ] in responses) {
                            finalDataType = dataTypes[ 0 ];
                        } else {
                            // Try convertible dataTypes
                            for (type in responses) {
                                if (!dataTypes[ 0 ] || s.converters[ type + ' ' + dataTypes[0] ]) {
                                    finalDataType = type;
                                    break;
                                }

                                if (!firstDataType) {
                                    firstDataType = type;
                                }
                            }
                            // Or just use first one
                            finalDataType = finalDataType || firstDataType;
                        }

                        // If we found a dataType
                        // We add the dataType to the list if needed
                        // and return the corresponding response
                        if (finalDataType) {
                            if (finalDataType !== dataTypes[ 0 ]) {
                                dataTypes.unshift(finalDataType);
                            }

                            return responses[ finalDataType ];
                        }
                    }

                    /* Chain conversions given the request and the original response
                     * Also sets the responseXXX fields on the jqXHR instance
                     */
                    function ajaxConvert(s, response, jqXHR, isSuccess) {
                        var conv2, current, conv, tmp, prev,
                            converters = {},
                        // Work with a copy of dataTypes in case we need to modify it for conversion
                            dataTypes = s.dataTypes.slice();

                        // Create converters map with lowercased keys
                        if (dataTypes[ 1 ]) {
                            for (conv in s.converters) {
                                converters[ conv.toLowerCase() ] = s.converters[ conv ];
                            }
                        }

                        current = dataTypes.shift();

                        // Convert to each sequential dataType
                        while (current) {

                            if (s.responseFields[ current ]) {
                                jqXHR[ s.responseFields[ current ] ] = response;
                            }

                            // Apply the dataFilter if provided
                            if (!prev && isSuccess && s.dataFilter) {
                                response = s.dataFilter(response, s.dataType);
                            }

                            prev = current;
                            current = dataTypes.shift();

                            if (current) {

                                // There's only work to do if current dataType is non-auto
                                if (current === '*') {

                                    current = prev;

                                    // Convert response if prev dataType is non-auto and differs from current
                                } else if (prev !== '*' && prev !== current) {

                                    // Seek a direct converter
                                    conv = converters[ prev + ' ' + current ] || converters[ '* ' + current ];

                                    // If none found, seek a pair
                                    if (!conv) {
                                        for (conv2 in converters) {

                                            // If conv2 outputs current
                                            tmp = conv2.split(' ');

                                            if (tmp[ 1 ] === current) {

                                                // If prev can be converted to accepted input
                                                conv = converters[ prev + ' ' + tmp[ 0 ] ] ||
                                                converters[ '* ' + tmp[ 0 ] ];

                                                if (conv) {
                                                    // Condense equivalence converters
                                                    if (conv === true) {
                                                        conv = converters[ conv2 ];

                                                        // Otherwise, insert the intermediate dataType
                                                    } else if (converters[ conv2 ] !== true) {
                                                        current = tmp[ 0 ];
                                                        dataTypes.unshift(tmp[ 1 ]);
                                                    }
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    // Apply converter (if not an equivalence)
                                    if (conv !== true) {

                                        // Unless errors are allowed to bubble, catch and return them
                                        if (conv && s[ 'throws' ]) {
                                            response = conv(response);
                                        } else {
                                            try {
                                                response = conv(response);
                                            } catch (e) {
                                                return {
                                                    state: 'parsererror', error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                                };
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        return {
                            state: 'success', data: response
                        };
                    }

                    jQuery.extend({

                        // Counter for holding the number of active queries
                        active: 0,

                        // Last-Modified header cache for next request
                        lastModified: {},
                        etag: {},

                        ajaxSettings: {
                            url: ajaxLocation,
                            type: 'GET',
                            isLocal: rlocalProtocol.test(ajaxLocParts[ 1 ]),
                            global: true,
                            processData: true,
                            async: true,
                            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',

                            /*
                             timeout: 0,
                             data: null,
                             dataType: null,
                             username: null,
                             password: null,
                             cache: null,
                             throws: false,
                             traditional: false,
                             headers: {},
                             */

                            accepts: {
                                '*': allTypes,
                                text: 'text/plain',
                                html: 'text/html',
                                xml: 'application/xml, text/xml',
                                json: 'application/json, text/javascript'
                            },

                            contents: {
                                xml: /xml/,
                                html: /html/,
                                json: /json/
                            },

                            responseFields: {
                                xml: 'responseXML',
                                text: 'responseText',
                                json: 'responseJSON'
                            },

                            // Data converters
                            // Keys separate source (or catchall "*") and destination types with a single space
                            converters: {

                                // Convert anything to text
                                '* text': String,

                                // Text to html (true = no transformation)
                                'text html': true,

                                // Evaluate text as a json expression
                                'text json': jQuery.parseJSON,

                                // Parse text as xml
                                'text xml': jQuery.parseXML
                            },

                            // For options that shouldn't be deep extended:
                            // you can add your own custom options here if
                            // and when you create one that shouldn't be
                            // deep extended (see ajaxExtend)
                            flatOptions: {
                                url: true,
                                context: true
                            }
                        },

                        // Creates a full fledged settings object into target
                        // with both ajaxSettings and settings fields.
                        // If target is omitted, writes into ajaxSettings.
                        ajaxSetup: function (target, settings) {
                            return settings ?

                                // Building a settings object
                                ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                                // Extending ajaxSettings
                                ajaxExtend(jQuery.ajaxSettings, target);
                        },

                        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                        ajaxTransport: addToPrefiltersOrTransports(transports),

                        // Main method
                        ajax: function (url, options) {

                            // If url is an object, simulate pre-1.5 signature
                            if (typeof url === 'object') {
                                options = url;
                                url = undefined;
                            }

                            // Force options to be an object
                            options = options || {};

                            var transport,
                            // URL without anti-cache param
                                cacheURL,
                            // Response headers
                                responseHeadersString,
                                responseHeaders,
                            // timeout handle
                                timeoutTimer,
                            // Cross-domain detection vars
                                parts,
                            // To know if global events are to be dispatched
                                fireGlobals,
                            // Loop variable
                                i,
                            // Create the final options object
                                s = jQuery.ajaxSetup({}, options),
                            // Callbacks context
                                callbackContext = s.context || s,
                            // Context for global events is callbackContext if it is a DOM node or jQuery collection
                                globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ?
                                    jQuery(callbackContext) :
                                    jQuery.event,
                            // Deferreds
                                deferred = jQuery.Deferred(),
                                completeDeferred = jQuery.Callbacks('once memory'),
                            // Status-dependent callbacks
                                statusCode = s.statusCode || {},
                            // Headers (they are sent all at once)
                                requestHeaders = {},
                                requestHeadersNames = {},
                            // The jqXHR state
                                state = 0,
                            // Default abort message
                                strAbort = 'canceled',
                            // Fake xhr
                                jqXHR = {
                                    readyState: 0,

                                    // Builds headers hashtable if needed
                                    getResponseHeader: function (key) {
                                        var match;

                                        if (state === 2) {
                                            if (!responseHeaders) {
                                                responseHeaders = {};

                                                while (match = rheaders.exec(responseHeadersString)) {
                                                    responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                                }
                                            }
                                            match = responseHeaders[ key.toLowerCase() ];
                                        }

                                        return match == null ? null : match;
                                    },

                                    // Raw string
                                    getAllResponseHeaders: function () {
                                        return state === 2 ? responseHeadersString : null;
                                    },

                                    // Caches the header
                                    setRequestHeader: function (name, value) {
                                        var lname = name.toLowerCase();

                                        if (!state) {
                                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                                            requestHeaders[ name ] = value;
                                        }

                                        return this;
                                    },

                                    // Overrides response content-type header
                                    overrideMimeType: function (type) {
                                        if (!state) {
                                            s.mimeType = type;
                                        }

                                        return this;
                                    },

                                    // Status-dependent callbacks
                                    statusCode: function (map) {
                                        var code;

                                        if (map) {
                                            if (state < 2) {
                                                for (code in map) {
                                                    // Lazy-add the new callback in a way that preserves old ones
                                                    statusCode[ code ] = [statusCode[ code ], map[ code ]];
                                                }
                                            } else {
                                                // Execute the appropriate callbacks
                                                jqXHR.always(map[ jqXHR.status ]);
                                            }
                                        }

                                        return this;
                                    },

                                    // Cancel the request
                                    abort: function (statusText) {
                                        var finalText = statusText || strAbort;

                                        if (transport) {
                                            transport.abort(finalText);
                                        }
                                        done(0, finalText);

                                        return this;
                                    }
                                };

                            // Attach deferreds
                            deferred.promise(jqXHR).complete = completeDeferred.add;
                            jqXHR.success = jqXHR.done;
                            jqXHR.error = jqXHR.fail;

                            // Remove hash character (#7531: and string promotion)
                            // Add protocol if not provided (prefilters might expect it)
                            // Handle falsy url in the settings object (#10093: consistency with old signature)
                            // We also use the url parameter if available
                            s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '')
                                .replace(rprotocol, ajaxLocParts[ 1 ] + '//');

                            // Alias method option to type as per ticket #12004
                            s.type = options.method || options.type || s.method || s.type;

                            // Extract dataTypes list
                            s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];

                            // A cross-domain request is in order when we have a protocol:host:port mismatch
                            if (s.crossDomain == null) {
                                parts = rurl.exec(s.url.toLowerCase());
                                s.crossDomain = !!(parts &&
                                (parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                                (parts[ 3 ] || (parts[ 1 ] === 'http:' ? '80' : '443')) !==
                                (ajaxLocParts[ 3 ] || (ajaxLocParts[ 1 ] === 'http:' ? '80' : '443')))
                                );
                            }

                            // Convert data if not already a string
                            if (s.data && s.processData && typeof s.data !== 'string') {
                                s.data = jQuery.param(s.data, s.traditional);
                            }

                            // Apply prefilters
                            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

                            // If request was aborted inside a prefilter, stop there
                            if (state === 2) {
                                return jqXHR;
                            }

                            // We can fire global events as of now if asked to
                            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                            fireGlobals = jQuery.event && s.global;

                            // Watch for a new set of requests
                            if (fireGlobals && jQuery.active++ === 0) {
                                jQuery.event.trigger('ajaxStart');
                            }

                            // Uppercase the type
                            s.type = s.type.toUpperCase();

                            // Determine if request has content
                            s.hasContent = !rnoContent.test(s.type);

                            // Save the URL in case we're toying with the If-Modified-Since
                            // and/or If-None-Match header later on
                            cacheURL = s.url;

                            // More options handling for requests with no content
                            if (!s.hasContent) {

                                // If data is available, append data to url
                                if (s.data) {
                                    cacheURL =  s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                                    // #9682: remove data so that it's not used in an eventual retry
                                    delete s.data;
                                }

                                // Add anti-cache in url if needed
                                if (s.cache === false) {
                                    s.url = rts.test(cacheURL) ?

                                        // If there is already a '_' parameter, set its value
                                        cacheURL.replace(rts, '$1_=' + nonce++) :

                                        // Otherwise add one to the end
                                    cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                                }
                            }

                            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            if (s.ifModified) {
                                if (jQuery.lastModified[ cacheURL ]) {
                                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[ cacheURL ]);
                                }

                                if (jQuery.etag[ cacheURL ]) {
                                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[ cacheURL ]);
                                }
                            }

                            // Set the correct header, if data is being sent
                            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                                jqXHR.setRequestHeader('Content-Type', s.contentType);
                            }

                            // Set the Accepts header for the server, depending on the dataType
                            jqXHR.setRequestHeader(
                                'Accept',
                                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                                s.accepts[ s.dataTypes[0] ] + (s.dataTypes[ 0 ] !== '*' ? ', ' + allTypes + '; q=0.01' : '') :
                                    s.accepts[ '*' ]
                            );

                            // Check for headers option
                            for (i in s.headers) {
                                jqXHR.setRequestHeader(i, s.headers[ i ]);
                            }

                            // Allow custom headers/mimetypes and early abort
                            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                                // Abort if not done already and return
                                return jqXHR.abort();
                            }

                            // Aborting is no longer a cancellation
                            strAbort = 'abort';

                            // Install callbacks on deferreds
                            for (i in {
                                success: 1, error: 1, complete: 1
                            }) {
                                jqXHR[ i ](s[ i ]);
                            }

                            // Get transport
                            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

                            // If no transport, we auto-abort
                            if (!transport) {
                                done(-1, 'No Transport');
                            } else {
                                jqXHR.readyState = 1;

                                // Send global event
                                if (fireGlobals) {
                                    globalEventContext.trigger('ajaxSend', [jqXHR, s]);
                                }
                                // Timeout
                                if (s.async && s.timeout > 0) {
                                    timeoutTimer = setTimeout(function () {
                                        jqXHR.abort('timeout');
                                    }, s.timeout);
                                }

                                try {
                                    state = 1;
                                    transport.send(requestHeaders, done);
                                } catch (e) {
                                    // Propagate exception as error if not done
                                    if (state < 2) {
                                        done(-1, e);
                                        // Simply rethrow otherwise
                                    } else {
                                        throw e;
                                    }
                                }
                            }

                            // Callback for when everything is done
                            function done(status, nativeStatusText, responses, headers) {
                                var isSuccess, success, error, response, modified,
                                    statusText = nativeStatusText;

                                // Called once
                                if (state === 2) {
                                    return;
                                }

                                // State is "done" now
                                state = 2;

                                // Clear timeout if it exists
                                if (timeoutTimer) {
                                    clearTimeout(timeoutTimer);
                                }

                                // Dereference transport for early garbage collection
                                // (no matter how long the jqXHR object will be used)
                                transport = undefined;

                                // Cache response headers
                                responseHeadersString = headers || '';

                                // Set readyState
                                jqXHR.readyState = status > 0 ? 4 : 0;

                                // Determine if successful
                                isSuccess = status >= 200 && status < 300 || status === 304;

                                // Get response data
                                if (responses) {
                                    response = ajaxHandleResponses(s, jqXHR, responses);
                                }

                                // Convert no matter what (that way responseXXX fields are always set)
                                response = ajaxConvert(s, response, jqXHR, isSuccess);

                                // If successful, handle type chaining
                                if (isSuccess) {

                                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                                    if (s.ifModified) {
                                        modified = jqXHR.getResponseHeader('Last-Modified');

                                        if (modified) {
                                            jQuery.lastModified[ cacheURL ] = modified;
                                        }
                                        modified = jqXHR.getResponseHeader('etag');

                                        if (modified) {
                                            jQuery.etag[ cacheURL ] = modified;
                                        }
                                    }

                                    // if no content
                                    if (status === 204 || s.type === 'HEAD') {
                                        statusText = 'nocontent';

                                        // if not modified
                                    } else if (status === 304) {
                                        statusText = 'notmodified';

                                        // If we have data, let's convert it
                                    } else {
                                        statusText = response.state;
                                        success = response.data;
                                        error = response.error;
                                        isSuccess = !error;
                                    }
                                } else {
                                    // Extract error from statusText and normalize for non-aborts
                                    error = statusText;

                                    if (status || !statusText) {
                                        statusText = 'error';

                                        if (status < 0) {
                                            status = 0;
                                        }
                                    }
                                }

                                // Set data for the fake xhr object
                                jqXHR.status = status;
                                jqXHR.statusText = (nativeStatusText || statusText) + '';

                                // Success/Error
                                if (isSuccess) {
                                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                                } else {
                                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                                }

                                // Status-dependent callbacks
                                jqXHR.statusCode(statusCode);
                                statusCode = undefined;

                                if (fireGlobals) {
                                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError',
                                        [jqXHR, s, isSuccess ? success : error]);
                                }

                                // Complete
                                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                                if (fireGlobals) {
                                    globalEventContext.trigger('ajaxComplete', [jqXHR, s]);
                                    // Handle the global AJAX counter
                                    if (!--jQuery.active) {
                                        jQuery.event.trigger('ajaxStop');
                                    }
                                }
                            }

                            return jqXHR;
                        },

                        getJSON: function (url, data, callback) {
                            return jQuery.get(url, data, callback, 'json');
                        },

                        getScript: function (url, callback) {
                            return jQuery.get(url, undefined, callback, 'script');
                        }
                    });

                    jQuery.each(['get', 'post'], function (i, method) {
                        jQuery[ method ] = function (url, data, callback, type) {
                            // Shift arguments if data argument was omitted
                            if (jQuery.isFunction(data)) {
                                type = type || callback;
                                callback = data;
                                data = undefined;
                            }

                            return jQuery.ajax({
                                url: url,
                                type: method,
                                dataType: type,
                                data: data,
                                success: callback
                            });
                        };
                    });

                    jQuery._evalUrl = function (url) {
                        return jQuery.ajax({
                            url: url,
                            type: 'GET',
                            dataType: 'script',
                            async: false,
                            global: false,
                            'throws': true
                        });
                    };

                    jQuery.fn.extend({
                        wrapAll: function (html) {
                            var wrap;

                            if (jQuery.isFunction(html)) {
                                return this.each(function (i) {
                                    jQuery(this).wrapAll(html.call(this, i));
                                });
                            }

                            if (this[ 0 ]) {

                                // The elements to wrap the target around
                                wrap = jQuery(html, this[ 0 ].ownerDocument).eq(0).clone(true);

                                if (this[ 0 ].parentNode) {
                                    wrap.insertBefore(this[ 0 ]);
                                }

                                wrap.map(function () {
                                    var elem = this;

                                    while (elem.firstElementChild) {
                                        elem = elem.firstElementChild;
                                    }

                                    return elem;
                                }).append(this);
                            }

                            return this;
                        },

                        wrapInner: function (html) {
                            if (jQuery.isFunction(html)) {
                                return this.each(function (i) {
                                    jQuery(this).wrapInner(html.call(this, i));
                                });
                            }

                            return this.each(function () {
                                var self = jQuery(this),
                                    contents = self.contents();

                                if (contents.length) {
                                    contents.wrapAll(html);

                                } else {
                                    self.append(html);
                                }
                            });
                        },

                        wrap: function (html) {
                            var isFunction = jQuery.isFunction(html);

                            return this.each(function (i) {
                                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                            });
                        },

                        unwrap: function () {
                            return this.parent().each(function () {
                                if (!jQuery.nodeName(this, 'body')) {
                                    jQuery(this).replaceWith(this.childNodes);
                                }
                            }).end();
                        }
                    });

                    jQuery.expr.filters.hidden = function (elem) {
                        // Support: Opera <= 12.12
                        // Opera reports offsetWidths and offsetHeights less than zero on some elements
                        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
                    };
                    jQuery.expr.filters.visible = function (elem) {
                        return !jQuery.expr.filters.hidden(elem);
                    };

                    var r20 = /%20/g,
                        rbracket = /\[\]$/,
                        rCRLF = /\r?\n/g,
                        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                        rsubmittable = /^(?:input|select|textarea|keygen)/i;

                    function buildParams(prefix, obj, traditional, add) {
                        var name;

                        if (jQuery.isArray(obj)) {
                            // Serialize array item.
                            jQuery.each(obj, function (i, v) {
                                if (traditional || rbracket.test(prefix)) {
                                    // Treat each array item as a scalar.
                                    add(prefix, v);

                                } else {
                                    // Item is non-scalar (array or object), encode its numeric index.
                                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                                }
                            });

                        } else if (!traditional && jQuery.type(obj) === 'object') {
                            // Serialize object item.
                            for (name in obj) {
                                buildParams(prefix + '[' + name + ']', obj[ name ], traditional, add);
                            }

                        } else {
                            // Serialize scalar item.
                            add(prefix, obj);
                        }
                    }

                    // Serialize an array of form elements or a set of
                    // key/values into a query string
                    jQuery.param = function (a, traditional) {
                        var prefix,
                            s = [],
                            add = function (key, value) {
                                // If value is a function, invoke it and return its value
                                value = jQuery.isFunction(value) ? value() :  value == null ? '' : value;
                                s[ s.length ] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
                            };

                        // Set traditional to true for jQuery <= 1.3.2 behavior.
                        if (traditional === undefined) {
                            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                        }

                        // If an array was passed in, assume that it is an array of form elements.
                        if (jQuery.isArray(a) ||  a.jquery && !jQuery.isPlainObject(a)) {
                            // Serialize the form elements
                            jQuery.each(a, function () {
                                add(this.name, this.value);
                            });

                        } else {
                            // If traditional, encode the "old" way (the way 1.3.2 or older
                            // did it), otherwise encode params recursively.
                            for (prefix in a) {
                                buildParams(prefix, a[ prefix ], traditional, add);
                            }
                        }

                        // Return the resulting serialization
                        return s.join('&').replace(r20, '+');
                    };

                    jQuery.fn.extend({
                        serialize: function () {
                            return jQuery.param(this.serializeArray());
                        },
                        serializeArray: function () {
                            return this.map(function () {
                                // Can add propHook for "elements" to filter or add form elements
                                var elements = jQuery.prop(this, 'elements');

                                return elements ? jQuery.makeArray(elements) : this;
                            })
                                .filter(function () {
                                    var type = this.type;

                                    // Use .is( ":disabled" ) so that fieldset[disabled] works
                                    return this.name && !jQuery(this).is(':disabled') &&
                                        rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                                        (this.checked || !rcheckableType.test(type));
                                })
                                .map(function (i, elem) {
                                    var val = jQuery(this).val();

                                    return val == null ?
                                        null :
                                        jQuery.isArray(val) ?
                                            jQuery.map(val, function (val) {
                                                return {
                                                    name: elem.name, value: val.replace(rCRLF, '\r\n')
                                                };
                                            }) :
                                        {
                                        name: elem.name, value: val.replace(rCRLF, '\r\n')
                                    };
                                }).get();
                        }
                    });

                    jQuery.ajaxSettings.xhr = function () {
                        try {
                            return new XMLHttpRequest();
                        } catch (e) {}
                    };

                    var xhrId = 0,
                        xhrCallbacks = {},
                        xhrSuccessStatus = {
                            // file protocol always yields status code 0, assume 200
                            0: 200,
                            // Support: IE9
                            // #1450: sometimes IE returns 1223 when it should be 204
                            1223: 204
                        },
                        xhrSupported = jQuery.ajaxSettings.xhr();

                    // Support: IE9
                    // Open requests must be manually aborted on unload (#5280)
                    // See https://support.microsoft.com/kb/2856746 for more info
                    if (window.attachEvent) {
                        window.attachEvent('onunload', function () {
                            for (var key in xhrCallbacks) {
                                xhrCallbacks[ key ]();
                            }
                        });
                    }

                    support.cors = !!xhrSupported &&  'withCredentials' in xhrSupported;
                    support.ajax = xhrSupported = !!xhrSupported;

                    jQuery.ajaxTransport(function (options) {
                        var callback;

                        // Cross domain only allowed if supported through XMLHttpRequest
                        if (support.cors || xhrSupported && !options.crossDomain) {
                            return {
                                send: function (headers, complete) {
                                    var i,
                                        xhr = options.xhr(),
                                        id = ++xhrId;

                                    xhr.open(options.type, options.url, options.async, options.username, options.password);

                                    // Apply custom fields if provided
                                    if (options.xhrFields) {
                                        for (i in options.xhrFields) {
                                            xhr[ i ] = options.xhrFields[ i ];
                                        }
                                    }

                                    // Override mime type if needed
                                    if (options.mimeType && xhr.overrideMimeType) {
                                        xhr.overrideMimeType(options.mimeType);
                                    }

                                    // X-Requested-With header
                                    // For cross-domain requests, seeing as conditions for a preflight are
                                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                                    // (it can always be set on a per-request basis or even using ajaxSetup)
                                    // For same-domain requests, won't change header if already provided.
                                    if (!options.crossDomain && !headers['X-Requested-With']) {
                                        headers['X-Requested-With'] = 'XMLHttpRequest';
                                    }

                                    // Set headers
                                    for (i in headers) {
                                        xhr.setRequestHeader(i, headers[ i ]);
                                    }

                                    // Callback
                                    callback = function (type) {
                                        return function () {
                                            if (callback) {
                                                delete xhrCallbacks[ id ];
                                                callback = xhr.onload = xhr.onerror = null;

                                                if (type === 'abort') {
                                                    xhr.abort();
                                                } else if (type === 'error') {
                                                    complete(
                                                        // file: protocol always yields status 0; see #8605, #14207
                                                        xhr.status,
                                                        xhr.statusText
                                                    );
                                                } else {
                                                    complete(
                                                        xhrSuccessStatus[ xhr.status ] || xhr.status,
                                                        xhr.statusText,
                                                        // Support: IE9
                                                        // Accessing binary-data responseText throws an exception
                                                        // (#11426)
                                                        typeof xhr.responseText === 'string' ? {
                                                            text: xhr.responseText
                                                        } : undefined,
                                                        xhr.getAllResponseHeaders()
                                                    );
                                                }
                                            }
                                        };
                                    };

                                    // Listen to events
                                    xhr.onload = callback();
                                    xhr.onerror = callback('error');

                                    // Create the abort callback
                                    callback = xhrCallbacks[ id ] = callback('abort');

                                    try {
                                        // Do send the request (this may raise an exception)
                                        xhr.send(options.hasContent && options.data || null);
                                    } catch (e) {
                                        // #14683: Only rethrow if this hasn't been notified as an error yet
                                        if (callback) {
                                            throw e;
                                        }
                                    }
                                },

                                abort: function () {
                                    if (callback) {
                                        callback();
                                    }
                                }
                            };
                        }
                    });




                    // Install script dataType
                    jQuery.ajaxSetup({
                        accepts: {
                            script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript'
                        },
                        contents: {
                            script: /(?:java|ecma)script/
                        },
                        converters: {
                            'text script': function (text) {
                                jQuery.globalEval(text);

                                return text;
                            }
                        }
                    });

                    // Handle cache's special case and crossDomain
                    jQuery.ajaxPrefilter('script', function (s) {
                        if (s.cache === undefined) {
                            s.cache = false;
                        }

                        if (s.crossDomain) {
                            s.type = 'GET';
                        }
                    });

                    // Bind script tag hack transport
                    jQuery.ajaxTransport('script', function (s) {
                        // This transport only deals with cross domain requests
                        if (s.crossDomain) {
                            var script, callback;

                            return {
                                send: function (_, complete) {
                                    script = jQuery('<script>').prop({
                                        async: true,
                                        charset: s.scriptCharset,
                                        src: s.url
                                    }).on(
                                        'load error',
                                        callback = function (evt) {
                                            script.remove();
                                            callback = null;

                                            if (evt) {
                                                complete(evt.type === 'error' ? 404 : 200, evt.type);
                                            }
                                        }
                                    );
                                    document.head.appendChild(script[ 0 ]);
                                },
                                abort: function () {
                                    if (callback) {
                                        callback();
                                    }
                                }
                            };
                        }
                    });

                    var oldCallbacks = [],
                        rjsonp = /(=)\?(?=&|$)|\?\?/;

                    // Default jsonp settings
                    jQuery.ajaxSetup({
                        jsonp: 'callback',
                        jsonpCallback: function () {
                            var callback = oldCallbacks.pop() ||  jQuery.expando + '_' +  nonce++;

                            this[ callback ] = true;

                            return callback;
                        }
                    });

                    // Detect, normalize options and install callbacks for jsonp requests
                    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {

                        var callbackName, overwritten, responseContainer,
                            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
                                    'url' :
                                typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data'
                                );

                        // Handle iff the expected data type is "jsonp" or we have a parameter to set
                        if (jsonProp || s.dataTypes[ 0 ] === 'jsonp') {

                            // Get callback name, remembering preexisting value associated with it
                            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
                                s.jsonpCallback() :
                                s.jsonpCallback;

                            // Insert callback into url or form data
                            if (jsonProp) {
                                s[ jsonProp ] = s[ jsonProp ].replace(rjsonp, '$1' + callbackName);
                            } else if (s.jsonp !== false) {
                                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
                            }

                            // Use data converter to retrieve json after script execution
                            s.converters['script json'] = function () {
                                if (!responseContainer) {
                                    jQuery.error(callbackName + ' was not called');
                                }

                                return responseContainer[ 0 ];
                            };

                            // force json dataType
                            s.dataTypes[ 0 ] = 'json';

                            // Install callback
                            overwritten = window[ callbackName ];
                            window[ callbackName ] = function () {
                                responseContainer = arguments;
                            };

                            // Clean-up function (fires after converters)
                            jqXHR.always(function () {
                                // Restore preexisting value
                                window[ callbackName ] = overwritten;

                                // Save back as free
                                if (s[ callbackName ]) {
                                    // make sure that re-using the options doesn't screw things around
                                    s.jsonpCallback = originalSettings.jsonpCallback;

                                    // save the callback name for future use
                                    oldCallbacks.push(callbackName);
                                }

                                // Call if it was a function and we have a response
                                if (responseContainer && jQuery.isFunction(overwritten)) {
                                    overwritten(responseContainer[ 0 ]);
                                }

                                responseContainer = overwritten = undefined;
                            });

                            // Delegate to script
                            return 'script';
                        }
                    });




                    // data: string of html
                    // context (optional): If specified, the fragment will be created in this context, defaults to document
                    // keepScripts (optional): If true, will include scripts passed in the html string
                    jQuery.parseHTML = function (data, context, keepScripts) {
                        if (!data || typeof data !== 'string') {
                            return null;
                        }

                        if (typeof context === 'boolean') {
                            keepScripts = context;
                            context = false;
                        }
                        context = context || document;

                        var parsed = rsingleTag.exec(data),
                            scripts = !keepScripts && [];

                        // Single tag
                        if (parsed) {
                            return [context.createElement(parsed[1])];
                        }

                        parsed = jQuery.buildFragment([data], context, scripts);

                        if (scripts && scripts.length) {
                            jQuery(scripts).remove();
                        }

                        return jQuery.merge([], parsed.childNodes);
                    };


                    // Keep a copy of the old load method
                    var _load = jQuery.fn.load;

                    /**
                     * Load a url into a page
                     */
                    jQuery.fn.load = function (url, params, callback) {
                        if (typeof url !== 'string' && _load) {
                            return _load.apply(this, arguments);
                        }

                        var selector, type, response,
                            self = this,
                            off = url.indexOf(' ');

                        if (off >= 0) {
                            selector = jQuery.trim(url.slice(off));
                            url = url.slice(0, off);
                        }

                        // If it's a function
                        if (jQuery.isFunction(params)) {

                            // We assume that it's the callback
                            callback = params;
                            params = undefined;

                            // Otherwise, build a param string
                        } else if (params && typeof params === 'object') {
                            type = 'POST';
                        }

                        // If we have elements to modify, make the request
                        if (self.length > 0) {
                            jQuery.ajax({
                                url: url,

                                // if "type" variable is undefined, then "GET" method will be used
                                type: type,
                                dataType: 'html',
                                data: params
                            }).done(function (responseText) {

                                // Save response for use in complete callback
                                response = arguments;

                                self.html(selector ?

                                    // If a selector was specified, locate the right elements in a dummy div
                                    // Exclude scripts to avoid IE 'Permission Denied' errors
                                    jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) :

                                    // Otherwise use the full result
                                    responseText);

                            }).complete(callback && function (jqXHR, status) {
                                self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
                            });
                        }

                        return this;
                    };




                    // Attach a bunch of functions for handling common AJAX events
                    jQuery.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function (i, type) {
                        jQuery.fn[ type ] = function (fn) {
                            return this.on(type, fn);
                        };
                    });

                    jQuery.expr.filters.animated = function (elem) {
                        return jQuery.grep(jQuery.timers, function (fn) {
                            return elem === fn.elem;
                        }).length;
                    };

                    var docElem = window.document.documentElement;

                    /**
                     * Gets a window from an element
                     */
                    function getWindow(elem) {
                        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
                    }

                    jQuery.offset = {
                        setOffset: function (elem, options, i) {
                            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                                position = jQuery.css(elem, 'position'),
                                curElem = jQuery(elem),
                                props = {};

                            // Set position first, in-case top/left are set even on static elem
                            if (position === 'static') {
                                elem.style.position = 'relative';
                            }

                            curOffset = curElem.offset();
                            curCSSTop = jQuery.css(elem, 'top');
                            curCSSLeft = jQuery.css(elem, 'left');
                            calculatePosition = (position === 'absolute' || position === 'fixed') &&
                            (curCSSTop + curCSSLeft).indexOf('auto') > -1;

                            // Need to be able to calculate position if either
                            // top or left is auto and position is either absolute or fixed
                            if (calculatePosition) {
                                curPosition = curElem.position();
                                curTop = curPosition.top;
                                curLeft = curPosition.left;

                            } else {
                                curTop = parseFloat(curCSSTop) || 0;
                                curLeft = parseFloat(curCSSLeft) || 0;
                            }

                            if (jQuery.isFunction(options)) {
                                options = options.call(elem, i, curOffset);
                            }

                            if (options.top != null) {
                                props.top =  options.top - curOffset.top  + curTop;
                            }

                            if (options.left != null) {
                                props.left =  options.left - curOffset.left  + curLeft;
                            }

                            if ('using' in options) {
                                options.using.call(elem, props);

                            } else {
                                curElem.css(props);
                            }
                        }
                    };

                    jQuery.fn.extend({
                        offset: function (options) {
                            if (arguments.length) {
                                return options === undefined ?
                                    this :
                                    this.each(function (i) {
                                        jQuery.offset.setOffset(this, options, i);
                                    });
                            }

                            var docElem, win,
                                elem = this[ 0 ],
                                box = {
                                top: 0, left: 0
                            },
                                doc = elem && elem.ownerDocument;

                            if (!doc) {
                                return;
                            }

                            docElem = doc.documentElement;

                            // Make sure it's not a disconnected DOM node
                            if (!jQuery.contains(docElem, elem)) {
                                return box;
                            }

                            // Support: BlackBerry 5, iOS 3 (original iPhone)
                            // If we don't have gBCR, just use 0,0 rather than error
                            if (typeof elem.getBoundingClientRect !== strundefined) {
                                box = elem.getBoundingClientRect();
                            }
                            win = getWindow(doc);

                            return {
                                top: box.top + win.pageYOffset - docElem.clientTop,
                                left: box.left + win.pageXOffset - docElem.clientLeft
                            };
                        },

                        position: function () {
                            if (!this[ 0 ]) {
                                return;
                            }

                            var offsetParent, offset,
                                elem = this[ 0 ],
                                parentOffset = {
                                top: 0, left: 0
                            };

                            // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
                            if (jQuery.css(elem, 'position') === 'fixed') {
                                // Assume getBoundingClientRect is there when computed position is fixed
                                offset = elem.getBoundingClientRect();

                            } else {
                                // Get *real* offsetParent
                                offsetParent = this.offsetParent();

                                // Get correct offsets
                                offset = this.offset();

                                if (!jQuery.nodeName(offsetParent[ 0 ], 'html')) {
                                    parentOffset = offsetParent.offset();
                                }

                                // Add offsetParent borders
                                parentOffset.top += jQuery.css(offsetParent[ 0 ], 'borderTopWidth', true);
                                parentOffset.left += jQuery.css(offsetParent[ 0 ], 'borderLeftWidth', true);
                            }

                            // Subtract parent offsets and element margins
                            return {
                                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
                            };
                        },

                        offsetParent: function () {
                            return this.map(function () {
                                var offsetParent = this.offsetParent || docElem;

                                while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
                                    offsetParent = offsetParent.offsetParent;
                                }

                                return offsetParent || docElem;
                            });
                        }
                    });

                    // Create scrollLeft and scrollTop methods
                    jQuery.each({
                        scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset'
                    }, function (method, prop) {
                        var top = 'pageYOffset' === prop;

                        jQuery.fn[ method ] = function (val) {
                            return access(this, function (elem, method, val) {
                                var win = getWindow(elem);

                                if (val === undefined) {
                                    return win ? win[ prop ] : elem[ method ];
                                }

                                if (win) {
                                    win.scrollTo(
                                        !top ? val : window.pageXOffset,
                                        top ? val : window.pageYOffset
                                    );

                                } else {
                                    elem[ method ] = val;
                                }
                            }, method, val, arguments.length, null);
                        };
                    });

                    // Support: Safari<7+, Chrome<37+
                    // Add the top/left cssHooks using jQuery.fn.position
                    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
                    // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
                    // getComputedStyle returns percent when specified for top/left/bottom/right;
                    // rather than make the css module depend on the offset module, just check for it here
                    jQuery.each(['top', 'left'], function (i, prop) {
                        jQuery.cssHooks[ prop ] = addGetHookIf(support.pixelPosition,
                            function (elem, computed) {
                                if (computed) {
                                    computed = curCSS(elem, prop);
                                    // If curCSS returns percentage, fallback to offset
                                    return rnumnonpx.test(computed) ?
                                    jQuery(elem).position()[ prop ] + 'px' :
                                        computed;
                                }
                            }
                        );
                    });


                    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
                    jQuery.each({
                        Height: 'height', Width: 'width'
                    }, function (name, type) {
                        jQuery.each({
                            padding: 'inner' + name, content: type, '': 'outer' + name
                        }, function (defaultExtra, funcName) {
                            // Margin is only for outerHeight, outerWidth
                            jQuery.fn[ funcName ] = function (margin, value) {
                                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'),
                                    extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');

                                return access(this, function (elem, type, value) {
                                    var doc;

                                    if (jQuery.isWindow(elem)) {
                                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                                        // https://github.com/jquery/jquery/pull/764
                                        return elem.document.documentElement[ 'client' + name ];
                                    }

                                    // Get document width or height
                                    if (elem.nodeType === 9) {
                                        doc = elem.documentElement;

                                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                        // whichever is greatest
                                        return Math.max(
                                            elem.body[ 'scroll' + name ], doc[ 'scroll' + name ],
                                            elem.body[ 'offset' + name ], doc[ 'offset' + name ],
                                            doc[ 'client' + name ]
                                        );
                                    }

                                    return value === undefined ?
                                        // Get width or height on the element, requesting but not forcing parseFloat
                                        jQuery.css(elem, type, extra) :

                                        // Set width or height on the element
                                        jQuery.style(elem, type, value, extra);
                                }, type, chainable ? margin : undefined, chainable, null);
                            };
                        });
                    });


                    // The number of elements contained in the matched element set
                    jQuery.fn.size = function () {
                        return this.length;
                    };

                    jQuery.fn.andSelf = jQuery.fn.addBack;




                    // Register as a named AMD module, since jQuery can be concatenated with other
                    // files that may use define, but not via a proper concatenation script that
                    // understands anonymous AMD modules. A named AMD is safest and most robust
                    // way to register. Lowercase jquery is used because AMD module names are
                    // derived from file names, and jQuery is normally delivered in a lowercase
                    // file name. Do this after creating the global so that if an AMD module wants
                    // to call noConflict to hide this version of jQuery, it will work.

                    // Note that for maximum portability, libraries that are not jQuery should
                    // declare themselves as anonymous modules, and avoid setting a global if an
                    // AMD loader is present. jQuery is a special case. For more information, see
                    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

                    if (typeof define === 'function' && define.amd) {
                        define('jquery', [], function () {
                            return jQuery;
                        });
                    }

                    var
                    // Map over jQuery in case of overwrite
                        _jQuery = window.jQuery,

                    // Map over the $ in case of overwrite
                        _$ = window.$;

                    jQuery.noConflict = function (deep) {
                        if (window.$ === jQuery) {
                            window.$ = _$;
                        }

                        if (deep && window.jQuery === jQuery) {
                            window.jQuery = _jQuery;
                        }

                        return jQuery;
                    };

                    // Expose jQuery and $ identifiers, even in AMD
                    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
                    // and CommonJS for browser emulators (#13566)
                    if (typeof noGlobal === strundefined) {
                        window.jQuery = window.$ = jQuery;
                    }

                    return jQuery;

                }));

            },{}],21: [function (require, module, exports) {
                'use strict';

                var yaml = require('./lib/js-yaml.js');

                module.exports = yaml;

            },{
                './lib/js-yaml.js': 22
            }],22: [function (require, module, exports) {
                'use strict';

                var loader = require('./js-yaml/loader');
                var dumper = require('./js-yaml/dumper');

                function deprecated(name) {
                    return function () {
                        throw new Error('Function ' + name + ' is deprecated and cannot be used.');
                    };
                }

                module.exports.Type                = require('./js-yaml/type');
                module.exports.Schema              = require('./js-yaml/schema');
                module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
                module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
                module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
                module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
                module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
                module.exports.load                = loader.load;
                module.exports.loadAll             = loader.loadAll;
                module.exports.safeLoad            = loader.safeLoad;
                module.exports.safeLoadAll         = loader.safeLoadAll;
                module.exports.dump                = dumper.dump;
                module.exports.safeDump            = dumper.safeDump;
                module.exports.YAMLException       = require('./js-yaml/exception');

                // Deprecared schema names from JS-YAML 2.0.x
                module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
                module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
                module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

                // Deprecated functions from JS-YAML 1.x.x
                module.exports.scan           = deprecated('scan');
                module.exports.parse          = deprecated('parse');
                module.exports.compose        = deprecated('compose');
                module.exports.addConstructor = deprecated('addConstructor');

            },{
                './js-yaml/dumper': 24,'./js-yaml/exception': 25,'./js-yaml/loader': 26,'./js-yaml/schema': 28,'./js-yaml/schema/core': 29,'./js-yaml/schema/default_full': 30,'./js-yaml/schema/default_safe': 31,'./js-yaml/schema/failsafe': 32,'./js-yaml/schema/json': 33,'./js-yaml/type': 34
            }],23: [function (require, module, exports) {
                'use strict';

                function isNothing(subject) {
                    return typeof subject === 'undefined' || null === subject;
                }

                function isObject(subject) {
                    return typeof subject === 'object' && null !== subject;
                }

                function toArray(sequence) {
                    if (Array.isArray(sequence)) {
                        return sequence;
                    } else if (isNothing(sequence)) {
                        return [];
                    }

                    return [sequence];
                }

                function extend(target, source) {
                    var index, length, key, sourceKeys;

                    if (source) {
                        sourceKeys = Object.keys(source);

                        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
                            key = sourceKeys[index];
                            target[key] = source[key];
                        }
                    }

                    return target;
                }

                function repeat(string, count) {
                    var result = '',
 cycle;

                    for (cycle = 0; cycle < count; cycle += 1) {
                        result += string;
                    }

                    return result;
                }

                function isNegativeZero(number) {
                    return 0 === number && Number.NEGATIVE_INFINITY === 1 / number;
                }

                module.exports.isNothing      = isNothing;
                module.exports.isObject       = isObject;
                module.exports.toArray        = toArray;
                module.exports.repeat         = repeat;
                module.exports.isNegativeZero = isNegativeZero;
                module.exports.extend         = extend;

            },{}],24: [function (require, module, exports) {
                'use strict';

                /*eslint-disable no-use-before-define*/

                var common              = require('./common');
                var YAMLException       = require('./exception');
                var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
                var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');

                var _toString       = Object.prototype.toString;
                var _hasOwnProperty = Object.prototype.hasOwnProperty;

                var CHAR_TAB                  = 0x09; /* Tab */
                var CHAR_LINE_FEED            = 0x0A; /* LF */
                var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
                var CHAR_SPACE                = 0x20; /* Space */
                var CHAR_EXCLAMATION          = 0x21; /* ! */
                var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
                var CHAR_SHARP                = 0x23; /* # */
                var CHAR_PERCENT              = 0x25; /* % */
                var CHAR_AMPERSAND            = 0x26; /* & */
                var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
                var CHAR_ASTERISK             = 0x2A; /* * */
                var CHAR_COMMA                = 0x2C; /* , */
                var CHAR_MINUS                = 0x2D; /* - */
                var CHAR_COLON                = 0x3A; /* : */
                var CHAR_GREATER_THAN         = 0x3E; /* > */
                var CHAR_QUESTION             = 0x3F; /* ? */
                var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
                var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
                var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
                var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
                var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
                var CHAR_VERTICAL_LINE        = 0x7C; /* | */
                var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

                var ESCAPE_SEQUENCES = {};

                ESCAPE_SEQUENCES[0x00]   = '\\0';
                ESCAPE_SEQUENCES[0x07]   = '\\a';
                ESCAPE_SEQUENCES[0x08]   = '\\b';
                ESCAPE_SEQUENCES[0x09]   = '\\t';
                ESCAPE_SEQUENCES[0x0A]   = '\\n';
                ESCAPE_SEQUENCES[0x0B]   = '\\v';
                ESCAPE_SEQUENCES[0x0C]   = '\\f';
                ESCAPE_SEQUENCES[0x0D]   = '\\r';
                ESCAPE_SEQUENCES[0x1B]   = '\\e';
                ESCAPE_SEQUENCES[0x22]   = '\\"';
                ESCAPE_SEQUENCES[0x5C]   = '\\\\';
                ESCAPE_SEQUENCES[0x85]   = '\\N';
                ESCAPE_SEQUENCES[0xA0]   = '\\_';
                ESCAPE_SEQUENCES[0x2028] = '\\L';
                ESCAPE_SEQUENCES[0x2029] = '\\P';

                var DEPRECATED_BOOLEANS_SYNTAX = [
                    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
                    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
                ];

                function compileStyleMap(schema, map) {
                    var result, keys, index, length, tag, style, type;

                    if (null === map) {
                        return {};
                    }

                    result = {};
                    keys = Object.keys(map);

                    for (index = 0, length = keys.length; index < length; index += 1) {
                        tag = keys[index];
                        style = String(map[tag]);

                        if ('!!' === tag.slice(0, 2)) {
                            tag = 'tag:yaml.org,2002:' + tag.slice(2);
                        }

                        type = schema.compiledTypeMap[tag];

                        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
                            style = type.styleAliases[style];
                        }

                        result[tag] = style;
                    }

                    return result;
                }

                function encodeHex(character) {
                    var string, handle, length;

                    string = character.toString(16).toUpperCase();

                    if (character <= 0xFF) {
                        handle = 'x';
                        length = 2;
                    } else if (character <= 0xFFFF) {
                        handle = 'u';
                        length = 4;
                    } else if (character <= 0xFFFFFFFF) {
                        handle = 'U';
                        length = 8;
                    } else {
                        throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
                    }

                    return '\\' + handle + common.repeat('0', length - string.length) + string;
                }

                function State(options) {
                    this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
                    this.indent      = Math.max(1, options['indent'] || 2);
                    this.skipInvalid = options['skipInvalid'] || false;
                    this.flowLevel   = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
                    this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);
                    this.sortKeys    = options['sortKeys'] || false;

                    this.implicitTypes = this.schema.compiledImplicit;
                    this.explicitTypes = this.schema.compiledExplicit;

                    this.tag = null;
                    this.result = '';

                    this.duplicates = [];
                    this.usedDuplicates = null;
                }

                function indentString(string, spaces) {
                    var ind = common.repeat(' ', spaces),
                        position = 0,
                        next = -1,
                        result = '',
                        line,
                        length = string.length;

                    while (position < length) {
                        next = string.indexOf('\n', position);

                        if (next === -1) {
                            line = string.slice(position);
                            position = length;
                        } else {
                            line = string.slice(position, next + 1);
                            position = next + 1;
                        }

                        if (line.length && line !== '\n') {
                            result += ind;
                        }
                        result += line;
                    }

                    return result;
                }

                function generateNextLine(state, level) {
                    return '\n' + common.repeat(' ', state.indent * level);
                }

                function testImplicitResolving(state, str) {
                    var index, length, type;

                    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
                        type = state.implicitTypes[index];

                        if (type.resolve(str)) {
                            return true;
                        }
                    }

                    return false;
                }

                function StringBuilder(source) {
                    this.source = source;
                    this.result = '';
                    this.checkpoint = 0;
                }

                StringBuilder.prototype.takeUpTo = function (position) {
                    var er;

                    if (position < this.checkpoint) {
                        er = new Error('position should be > checkpoint');
                        er.position = position;
                        er.checkpoint = this.checkpoint;
                        throw er;
                    }

                    this.result += this.source.slice(this.checkpoint, position);
                    this.checkpoint = position;

                    return this;
                };

                StringBuilder.prototype.escapeChar = function () {
                    var character, esc;

                    character = this.source.charCodeAt(this.checkpoint);
                    esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
                    this.result += esc;
                    this.checkpoint += 1;

                    return this;
                };

                StringBuilder.prototype.finish = function () {
                    if (this.source.length > this.checkpoint) {
                        this.takeUpTo(this.source.length);
                    }
                };

                function writeScalar(state, object, level) {
                    var simple, first, spaceWrap, folded, literal, single, double,
                        sawLineFeed, linePosition, longestLine, indent, max, character,
                        position, escapeSeq, hexEsc, previous, lineLength, modifier,
                        trailingLineBreaks, result;

                    if (0 === object.length) {
                        state.dump = '\'\'';

                        return;
                    }

                    if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
                        state.dump = '\'' + object + '\'';

                        return;
                    }

                    simple = true;
                    first = object.length ? object.charCodeAt(0) : 0;
                    spaceWrap = CHAR_SPACE === first ||
                    CHAR_SPACE === object.charCodeAt(object.length - 1);

                    // Simplified check for restricted first characters
                    // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
                    if (CHAR_MINUS         === first ||
                        CHAR_QUESTION      === first ||
                        CHAR_COMMERCIAL_AT === first ||
                        CHAR_GRAVE_ACCENT  === first) {
                        simple = false;
                    }

                    // can only use > and | if not wrapped in spaces.
                    if (spaceWrap) {
                        simple = false;
                        folded = false;
                        literal = false;
                    } else {
                        folded = true;
                        literal = true;
                    }

                    single = true;
                    double = new StringBuilder(object);

                    sawLineFeed = false;
                    linePosition = 0;
                    longestLine = 0;

                    indent = state.indent * level;
                    max = 80;

                    if (indent < 40) {
                        max -= indent;
                    } else {
                        max = 40;
                    }

                    for (position = 0; position < object.length; position++) {
                        character = object.charCodeAt(position);

                        if (simple) {
                            // Characters that can never appear in the simple scalar
                            if (!simpleChar(character)) {
                                simple = false;
                            } else {
                                // Still simple.  If we make it all the way through like
                                // this, then we can just dump the string as-is.
                                continue;
                            }
                        }

                        if (single && character === CHAR_SINGLE_QUOTE) {
                            single = false;
                        }

                        escapeSeq = ESCAPE_SEQUENCES[character];
                        hexEsc = needsHexEscape(character);

                        if (!escapeSeq && !hexEsc) {
                            continue;
                        }

                        if (character !== CHAR_LINE_FEED &&
                            character !== CHAR_DOUBLE_QUOTE &&
                            character !== CHAR_SINGLE_QUOTE) {
                            folded = false;
                            literal = false;
                        } else if (character === CHAR_LINE_FEED) {
                            sawLineFeed = true;
                            single = false;

                            if (position > 0) {
                                previous = object.charCodeAt(position - 1);

                                if (previous === CHAR_SPACE) {
                                    literal = false;
                                    folded = false;
                                }
                            }

                            if (folded) {
                                lineLength = position - linePosition;
                                linePosition = position;

                                if (lineLength > longestLine) {
                                    longestLine = lineLength;
                                }
                            }
                        }

                        if (character !== CHAR_DOUBLE_QUOTE) {
                            single = false;
                        }

                        double.takeUpTo(position);
                        double.escapeChar();
                    }

                    if (simple && testImplicitResolving(state, object)) {
                        simple = false;
                    }

                    modifier = '';

                    if (folded || literal) {
                        trailingLineBreaks = 0;

                        if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
                            trailingLineBreaks += 1;

                            if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
                                trailingLineBreaks += 1;
                            }
                        }

                        if (trailingLineBreaks === 0) {
                            modifier = '-';
                        } else if (trailingLineBreaks === 2) {
                            modifier = '+';
                        }
                    }

                    if (literal && longestLine < max) {
                        folded = false;
                    }

                    // If it's literally one line, then don't bother with the literal.
                    // We may still want to do a fold, though, if it's a super long line.
                    if (!sawLineFeed) {
                        literal = false;
                    }

                    if (simple) {
                        state.dump = object;
                    } else if (single) {
                        state.dump = '\'' + object + '\'';
                    } else if (folded) {
                        result = fold(object, max);
                        state.dump = '>' + modifier + '\n' + indentString(result, indent);
                    } else if (literal) {
                        if (!modifier) {
                            object = object.replace(/\n$/, '');
                        }
                        state.dump = '|' + modifier + '\n' + indentString(object, indent);
                    } else if (double) {
                        double.finish();
                        state.dump = '"' + double.result + '"';
                    } else {
                        throw new Error('Failed to dump scalar value');
                    }

                    return;
                }

                // The `trailing` var is a regexp match of any trailing `\n` characters.
                //
                // There are three cases we care about:
                //
                // 1. One trailing `\n` on the string.  Just use `|` or `>`.
                //    This is the assumed default. (trailing = null)
                // 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
                // 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
                //
                // In the case of `>+`, these line breaks are *not* doubled (like the line
                // breaks within the string), so it's important to only end with the exact
                // same number as we started.
                function fold(object, max) {
                    var result = '',
                        position = 0,
                        length = object.length,
                        trailing = /\n+$/.exec(object),
                        newLine;

                    if (trailing) {
                        length = trailing.index + 1;
                    }

                    while (position < length) {
                        newLine = object.indexOf('\n', position);

                        if (newLine > length || newLine === -1) {
                            if (result) {
                                result += '\n\n';
                            }
                            result += foldLine(object.slice(position, length), max);
                            position = length;
                        } else {
                            if (result) {
                                result += '\n\n';
                            }
                            result += foldLine(object.slice(position, newLine), max);
                            position = newLine + 1;
                        }
                    }

                    if (trailing && trailing[0] !== '\n') {
                        result += trailing[0];
                    }

                    return result;
                }

                function foldLine(line, max) {
                    if (line === '') {
                        return line;
                    }

                    var foldRe = /[^\s] [^\s]/g,
                        result = '',
                        prevMatch = 0,
                        foldStart = 0,
                        match = foldRe.exec(line),
                        index,
                        foldEnd,
                        folded;

                    while (match) {
                        index = match.index;

                        // when we cross the max len, if the previous match would've
                        // been ok, use that one, and carry on.  If there was no previous
                        // match on this fold section, then just have a long line.
                        if (index - foldStart > max) {
                            if (prevMatch !== foldStart) {
                                foldEnd = prevMatch;
                            } else {
                                foldEnd = index;
                            }

                            if (result) {
                                result += '\n';
                            }
                            folded = line.slice(foldStart, foldEnd);
                            result += folded;
                            foldStart = foldEnd + 1;
                        }
                        prevMatch = index + 1;
                        match = foldRe.exec(line);
                    }

                    if (result) {
                        result += '\n';
                    }

                    // if we end up with one last word at the end, then the last bit might
                    // be slightly bigger than we wanted, because we exited out of the loop.
                    if (foldStart !== prevMatch && line.length - foldStart > max) {
                        result += line.slice(foldStart, prevMatch) + '\n' +
                        line.slice(prevMatch + 1);
                    } else {
                        result += line.slice(foldStart);
                    }

                    return result;
                }

                // Returns true if character can be found in a simple scalar
                function simpleChar(character) {
                    return CHAR_TAB                  !== character &&
                        CHAR_LINE_FEED            !== character &&
                        CHAR_CARRIAGE_RETURN      !== character &&
                        CHAR_COMMA                !== character &&
                        CHAR_LEFT_SQUARE_BRACKET  !== character &&
                        CHAR_RIGHT_SQUARE_BRACKET !== character &&
                        CHAR_LEFT_CURLY_BRACKET   !== character &&
                        CHAR_RIGHT_CURLY_BRACKET  !== character &&
                        CHAR_SHARP                !== character &&
                        CHAR_AMPERSAND            !== character &&
                        CHAR_ASTERISK             !== character &&
                        CHAR_EXCLAMATION          !== character &&
                        CHAR_VERTICAL_LINE        !== character &&
                        CHAR_GREATER_THAN         !== character &&
                        CHAR_SINGLE_QUOTE         !== character &&
                        CHAR_DOUBLE_QUOTE         !== character &&
                        CHAR_PERCENT              !== character &&
                        CHAR_COLON                !== character &&
                        !ESCAPE_SEQUENCES[character]            &&
                        !needsHexEscape(character);
                }

                // Returns true if the character code needs to be escaped.
                function needsHexEscape(character) {
                    return !(0x00020 <= character && character <= 0x00007E ||
                    0x00085 === character                         ||
                    0x000A0 <= character && character <= 0x00D7FF ||
                    0x0E000 <= character && character <= 0x00FFFD ||
                    0x10000 <= character && character <= 0x10FFFF);
                }

                function writeFlowSequence(state, level, object) {
                    var _result = '',
                        _tag    = state.tag,
                        index,
                        length;

                    for (index = 0, length = object.length; index < length; index += 1) {
                        // Write only valid elements.
                        if (writeNode(state, level, object[index], false, false)) {
                            if (0 !== index) {
                                _result += ', ';
                            }
                            _result += state.dump;
                        }
                    }

                    state.tag = _tag;
                    state.dump = '[' + _result + ']';
                }

                function writeBlockSequence(state, level, object, compact) {
                    var _result = '',
                        _tag    = state.tag,
                        index,
                        length;

                    for (index = 0, length = object.length; index < length; index += 1) {
                        // Write only valid elements.
                        if (writeNode(state, level + 1, object[index], true, true)) {
                            if (!compact || 0 !== index) {
                                _result += generateNextLine(state, level);
                            }
                            _result += '- ' + state.dump;
                        }
                    }

                    state.tag = _tag;
                    state.dump = _result || '[]'; // Empty sequence if no valid values.
                }

                function writeFlowMapping(state, level, object) {
                    var _result       = '',
                        _tag          = state.tag,
                        objectKeyList = Object.keys(object),
                        index,
                        length,
                        objectKey,
                        objectValue,
                        pairBuffer;

                    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                        pairBuffer = '';

                        if (0 !== index) {
                            pairBuffer += ', ';
                        }

                        objectKey = objectKeyList[index];
                        objectValue = object[objectKey];

                        if (!writeNode(state, level, objectKey, false, false)) {
                            continue; // Skip this pair because of invalid key;
                        }

                        if (state.dump.length > 1024) {
                            pairBuffer += '? ';
                        }

                        pairBuffer += state.dump + ': ';

                        if (!writeNode(state, level, objectValue, false, false)) {
                            continue; // Skip this pair because of invalid value.
                        }

                        pairBuffer += state.dump;

                        // Both key and value are valid.
                        _result += pairBuffer;
                    }

                    state.tag = _tag;
                    state.dump = '{' + _result + '}';
                }

                function writeBlockMapping(state, level, object, compact) {
                    var _result       = '',
                        _tag          = state.tag,
                        objectKeyList = Object.keys(object),
                        index,
                        length,
                        objectKey,
                        objectValue,
                        explicitPair,
                        pairBuffer;

                    // Allow sorting keys so that the output file is deterministic
                    if (state.sortKeys === true) {
                        // Default sorting
                        objectKeyList.sort();
                    } else if (typeof state.sortKeys === 'function') {
                        // Custom sort function
                        objectKeyList.sort(state.sortKeys);
                    } else if (state.sortKeys) {
                        // Something is wrong
                        throw new YAMLException('sortKeys must be a boolean or a function');
                    }

                    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                        pairBuffer = '';

                        if (!compact || 0 !== index) {
                            pairBuffer += generateNextLine(state, level);
                        }

                        objectKey = objectKeyList[index];
                        objectValue = object[objectKey];

                        if (!writeNode(state, level + 1, objectKey, true, true)) {
                            continue; // Skip this pair because of invalid key.
                        }

                        explicitPair = null !== state.tag && '?' !== state.tag ||
                        state.dump && state.dump.length > 1024;

                        if (explicitPair) {
                            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                                pairBuffer += '?';
                            } else {
                                pairBuffer += '? ';
                            }
                        }

                        pairBuffer += state.dump;

                        if (explicitPair) {
                            pairBuffer += generateNextLine(state, level);
                        }

                        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
                            continue; // Skip this pair because of invalid value.
                        }

                        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                            pairBuffer += ':';
                        } else {
                            pairBuffer += ': ';
                        }

                        pairBuffer += state.dump;

                        // Both key and value are valid.
                        _result += pairBuffer;
                    }

                    state.tag = _tag;
                    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
                }

                function detectType(state, object, explicit) {
                    var _result, typeList, index, length, type, style;

                    typeList = explicit ? state.explicitTypes : state.implicitTypes;

                    for (index = 0, length = typeList.length; index < length; index += 1) {
                        type = typeList[index];

                        if ((type.instanceOf  || type.predicate) &&
                            (!type.instanceOf || 'object' === typeof object && object instanceof type.instanceOf) &&
                            (!type.predicate  || type.predicate(object))) {

                            state.tag = explicit ? type.tag : '?';

                            if (type.represent) {
                                style = state.styleMap[type.tag] || type.defaultStyle;

                                if ('[object Function]' === _toString.call(type.represent)) {
                                    _result = type.represent(object, style);
                                } else if (_hasOwnProperty.call(type.represent, style)) {
                                    _result = type.represent[style](object, style);
                                } else {
                                    throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
                                }

                                state.dump = _result;
                            }

                            return true;
                        }
                    }

                    return false;
                }

                // Serializes `object` and writes it to global `result`.
                // Returns true on success, or false on invalid object.
                //
                function writeNode(state, level, object, block, compact) {
                    state.tag = null;
                    state.dump = object;

                    if (!detectType(state, object, false)) {
                        detectType(state, object, true);
                    }

                    var type = _toString.call(state.dump);

                    if (block) {
                        block = 0 > state.flowLevel || state.flowLevel > level;
                    }

                    if (null !== state.tag && '?' !== state.tag || 2 !== state.indent && level > 0) {
                        compact = false;
                    }

                    var objectOrArray = '[object Object]' === type || '[object Array]' === type,
                        duplicateIndex,
                        duplicate;

                    if (objectOrArray) {
                        duplicateIndex = state.duplicates.indexOf(object);
                        duplicate = duplicateIndex !== -1;
                    }

                    if (duplicate && state.usedDuplicates[duplicateIndex]) {
                        state.dump = '*ref_' + duplicateIndex;
                    } else {
                        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
                            state.usedDuplicates[duplicateIndex] = true;
                        }

                        if ('[object Object]' === type) {
                            if (block && 0 !== Object.keys(state.dump).length) {
                                writeBlockMapping(state, level, state.dump, compact);

                                if (duplicate) {
                                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
                                }
                            } else {
                                writeFlowMapping(state, level, state.dump);

                                if (duplicate) {
                                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                                }
                            }
                        } else if ('[object Array]' === type) {
                            if (block && 0 !== state.dump.length) {
                                writeBlockSequence(state, level, state.dump, compact);

                                if (duplicate) {
                                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
                                }
                            } else {
                                writeFlowSequence(state, level, state.dump);

                                if (duplicate) {
                                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                                }
                            }
                        } else if ('[object String]' === type) {
                            if ('?' !== state.tag) {
                                writeScalar(state, state.dump, level);
                            }
                        } else {
                            if (state.skipInvalid) {
                                return false;
                            }
                            throw new YAMLException('unacceptable kind of an object to dump ' + type);
                        }

                        if (null !== state.tag && '?' !== state.tag) {
                            state.dump = '!<' + state.tag + '> ' + state.dump;
                        }
                    }

                    return true;
                }

                function getDuplicateReferences(object, state) {
                    var objects = [],
                        duplicatesIndexes = [],
                        index,
                        length;

                    inspectNode(object, objects, duplicatesIndexes);

                    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
                        state.duplicates.push(objects[duplicatesIndexes[index]]);
                    }
                    state.usedDuplicates = new Array(length);
                }

                function inspectNode(object, objects, duplicatesIndexes) {
                    var type = _toString.call(object),
                        objectKeyList,
                        index,
                        length;

                    if (null !== object && 'object' === typeof object) {
                        index = objects.indexOf(object);

                        if (-1 !== index) {
                            if (-1 === duplicatesIndexes.indexOf(index)) {
                                duplicatesIndexes.push(index);
                            }
                        } else {
                            objects.push(object);

                            if (Array.isArray(object)) {
                                for (index = 0, length = object.length; index < length; index += 1) {
                                    inspectNode(object[index], objects, duplicatesIndexes);
                                }
                            } else {
                                objectKeyList = Object.keys(object);

                                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                                }
                            }
                        }
                    }
                }

                function dump(input, options) {
                    options = options || {};

                    var state = new State(options);

                    getDuplicateReferences(input, state);

                    if (writeNode(state, 0, input, true, true)) {
                        return state.dump + '\n';
                    }

                    return '';
                }

                function safeDump(input, options) {
                    return dump(input, common.extend({
                        schema: DEFAULT_SAFE_SCHEMA
                    }, options));
                }

                module.exports.dump     = dump;
                module.exports.safeDump = safeDump;

            },{
                './common': 23,'./exception': 25,'./schema/default_full': 30,'./schema/default_safe': 31
            }],25: [function (require, module, exports) {
                'use strict';

                function YAMLException(reason, mark) {
                    this.name    = 'YAMLException';
                    this.reason  = reason;
                    this.mark    = mark;
                    this.message = this.toString(false);
                }

                YAMLException.prototype.toString = function toString(compact) {
                    var result;

                    result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

                    if (!compact && this.mark) {
                        result += ' ' + this.mark.toString();
                    }

                    return result;
                };

                module.exports = YAMLException;

            },{}],26: [function (require, module, exports) {
                'use strict';

                /*eslint-disable max-len,no-use-before-define*/

                var common              = require('./common');
                var YAMLException       = require('./exception');
                var Mark                = require('./mark');
                var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
                var DEFAULT_FULL_SCHEMA = require('./schema/default_full');

                var _hasOwnProperty = Object.prototype.hasOwnProperty;

                var CONTEXT_FLOW_IN   = 1;
                var CONTEXT_FLOW_OUT  = 2;
                var CONTEXT_BLOCK_IN  = 3;
                var CONTEXT_BLOCK_OUT = 4;

                var CHOMPING_CLIP  = 1;
                var CHOMPING_STRIP = 2;
                var CHOMPING_KEEP  = 3;

                var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
                var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
                var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
                var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

                function is_EOL(c) {
                    return c === 0x0A/* LF */ || c === 0x0D/* CR */;
                }

                function is_WHITE_SPACE(c) {
                    return c === 0x09/* Tab */ || c === 0x20/* Space */;
                }

                function is_WS_OR_EOL(c) {
                    return c === 0x09/* Tab */ ||
                        c === 0x20/* Space */ ||
                        c === 0x0A/* LF */ ||
                        c === 0x0D/* CR */;
                }

                function is_FLOW_INDICATOR(c) {
                    return 0x2C/* , */ === c ||
                        0x5B/* [ */ === c ||
                        0x5D/* ] */ === c ||
                        0x7B/* { */ === c ||
                        0x7D/* } */ === c;
                }

                function fromHexCode(c) {
                    var lc;

                    if (0x30/* 0 */ <= c && c <= 0x39/* 9 */) {
                        return c - 0x30;
                    }

                    /*eslint-disable no-bitwise*/
                    lc = c | 0x20;

                    if (0x61/* a */ <= lc && lc <= 0x66/* f */) {
                        return lc - 0x61 + 10;
                    }

                    return -1;
                }

                function escapedHexLen(c) {
                    if (c === 0x78/* x */) {
                        return 2;
                    }

                    if (c === 0x75/* u */) {
                        return 4;
                    }

                    if (c === 0x55/* U */) {
                        return 8;
                    }

                    return 0;
                }

                function fromDecimalCode(c) {
                    if (0x30/* 0 */ <= c && c <= 0x39/* 9 */) {
                        return c - 0x30;
                    }

                    return -1;
                }

                function simpleEscapeSequence(c) {
                    return c === 0x30/* 0 */ ? '\x00' :
                        c === 0x61/* a */ ? '\x07' :
                            c === 0x62/* b */ ? '\x08' :
                                c === 0x74/* t */ ? '\x09' :
                                    c === 0x09/* Tab */ ? '\x09' :
                                        c === 0x6E/* n */ ? '\x0A' :
                                            c === 0x76/* v */ ? '\x0B' :
                                                c === 0x66/* f */ ? '\x0C' :
                                                    c === 0x72/* r */ ? '\x0D' :
                                                        c === 0x65/* e */ ? '\x1B' :
                                                            c === 0x20/* Space */ ? ' ' :
                                                                c === 0x22/* " */ ? '\x22' :
                                                                    c === 0x2F/* / */ ? '/' :
                                                                        c === 0x5C/* \ */ ? '\x5C' :
                                                                            c === 0x4E/* N */ ? '\x85' :
                                                                                c === 0x5F/* _ */ ? '\xA0' :
                                                                                    c === 0x4C/* L */ ? '\u2028' :
                                                                                        c === 0x50/* P */ ? '\u2029' : '';
                }

                function charFromCodepoint(c) {
                    if (c <= 0xFFFF) {
                        return String.fromCharCode(c);
                    }
                    // Encode UTF-16 surrogate pair
                    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
                    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800,
                        (c - 0x010000 & 0x03FF) + 0xDC00);
                }

                var simpleEscapeCheck = new Array(256); // integer, for fast access
                var simpleEscapeMap = new Array(256);

                for (var i = 0; i < 256; i++) {
                    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
                    simpleEscapeMap[i] = simpleEscapeSequence(i);
                }

                function State(input, options) {
                    this.input = input;

                    this.filename  = options['filename']  || null;
                    this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
                    this.onWarning = options['onWarning'] || null;
                    this.legacy    = options['legacy']    || false;

                    this.implicitTypes = this.schema.compiledImplicit;
                    this.typeMap       = this.schema.compiledTypeMap;

                    this.length     = input.length;
                    this.position   = 0;
                    this.line       = 0;
                    this.lineStart  = 0;
                    this.lineIndent = 0;

                    this.documents = [];

                    /*
                     this.version;
                     this.checkLineBreaks;
                     this.tagMap;
                     this.anchorMap;
                     this.tag;
                     this.anchor;
                     this.kind;
                     this.result;*/

                }

                function generateError(state, message) {
                    return new YAMLException(
                        message,
                        new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
                }

                function throwError(state, message) {
                    throw generateError(state, message);
                }

                function throwWarning(state, message) {
                    var error = generateError(state, message);

                    if (state.onWarning) {
                        state.onWarning.call(null, error);
                    } else {
                        throw error;
                    }
                }

                var directiveHandlers = {

                    YAML: function handleYamlDirective(state, name, args) {

                        var match, major, minor;

                        if (null !== state.version) {
                            throwError(state, 'duplication of %YAML directive');
                        }

                        if (1 !== args.length) {
                            throwError(state, 'YAML directive accepts exactly one argument');
                        }

                        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

                        if (null === match) {
                            throwError(state, 'ill-formed argument of the YAML directive');
                        }

                        major = parseInt(match[1], 10);
                        minor = parseInt(match[2], 10);

                        if (1 !== major) {
                            throwError(state, 'unacceptable YAML version of the document');
                        }

                        state.version = args[0];
                        state.checkLineBreaks = minor < 2;

                        if (1 !== minor && 2 !== minor) {
                            throwWarning(state, 'unsupported YAML version of the document');
                        }
                    },

                    TAG: function handleTagDirective(state, name, args) {

                        var handle, prefix;

                        if (2 !== args.length) {
                            throwError(state, 'TAG directive accepts exactly two arguments');
                        }

                        handle = args[0];
                        prefix = args[1];

                        if (!PATTERN_TAG_HANDLE.test(handle)) {
                            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
                        }

                        if (_hasOwnProperty.call(state.tagMap, handle)) {
                            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
                        }

                        if (!PATTERN_TAG_URI.test(prefix)) {
                            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
                        }

                        state.tagMap[handle] = prefix;
                    }
                };

                function captureSegment(state, start, end, checkJson) {
                    var _position, _length, _character, _result;

                    if (start < end) {
                        _result = state.input.slice(start, end);

                        if (checkJson) {
                            for (_position = 0, _length = _result.length;
                                 _position < _length;
                                 _position += 1) {
                                _character = _result.charCodeAt(_position);

                                if (!(0x09 === _character ||
                                    0x20 <= _character && _character <= 0x10FFFF)) {
                                    throwError(state, 'expected valid JSON character');
                                }
                            }
                        }

                        state.result += _result;
                    }
                }

                function mergeMappings(state, destination, source) {
                    var sourceKeys, key, index, quantity;

                    if (!common.isObject(source)) {
                        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
                    }

                    sourceKeys = Object.keys(source);

                    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
                        key = sourceKeys[index];

                        if (!_hasOwnProperty.call(destination, key)) {
                            destination[key] = source[key];
                        }
                    }
                }

                function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
                    var index, quantity;

                    keyNode = String(keyNode);

                    if (null === _result) {
                        _result = {};
                    }

                    if ('tag:yaml.org,2002:merge' === keyTag) {
                        if (Array.isArray(valueNode)) {
                            for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                                mergeMappings(state, _result, valueNode[index]);
                            }
                        } else {
                            mergeMappings(state, _result, valueNode);
                        }
                    } else {
                        _result[keyNode] = valueNode;
                    }

                    return _result;
                }

                function readLineBreak(state) {
                    var ch;

                    ch = state.input.charCodeAt(state.position);

                    if (0x0A/* LF */ === ch) {
                        state.position++;
                    } else if (0x0D/* CR */ === ch) {
                        state.position++;

                        if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
                            state.position++;
                        }
                    } else {
                        throwError(state, 'a line break is expected');
                    }

                    state.line += 1;
                    state.lineStart = state.position;
                }

                function skipSeparationSpace(state, allowComments, checkIndent) {
                    var lineBreaks = 0,
                        ch = state.input.charCodeAt(state.position);

                    while (0 !== ch) {
                        while (is_WHITE_SPACE(ch)) {
                            ch = state.input.charCodeAt(++state.position);
                        }

                        if (allowComments && 0x23/* # */ === ch) {
                            do {
                                ch = state.input.charCodeAt(++state.position);
                            } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
                        }

                        if (is_EOL(ch)) {
                            readLineBreak(state);

                            ch = state.input.charCodeAt(state.position);
                            lineBreaks++;
                            state.lineIndent = 0;

                            while (0x20/* Space */ === ch) {
                                state.lineIndent++;
                                ch = state.input.charCodeAt(++state.position);
                            }
                        } else {
                            break;
                        }
                    }

                    if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
                        throwWarning(state, 'deficient indentation');
                    }

                    return lineBreaks;
                }

                function testDocumentSeparator(state) {
                    var _position = state.position,
                        ch;

                    ch = state.input.charCodeAt(_position);

                    // Condition state.position === state.lineStart is tested
                    // in parent on each call, for efficiency. No needs to test here again.
                    if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
                        state.input.charCodeAt(_position + 1) === ch &&
                        state.input.charCodeAt(_position + 2) === ch) {

                        _position += 3;

                        ch = state.input.charCodeAt(_position);

                        if (ch === 0 || is_WS_OR_EOL(ch)) {
                            return true;
                        }
                    }

                    return false;
                }

                function writeFoldedLines(state, count) {
                    if (1 === count) {
                        state.result += ' ';
                    } else if (count > 1) {
                        state.result += common.repeat('\n', count - 1);
                    }
                }

                function readPlainScalar(state, nodeIndent, withinFlowCollection) {
                    var preceding,
                        following,
                        captureStart,
                        captureEnd,
                        hasPendingContent,
                        _line,
                        _lineStart,
                        _lineIndent,
                        _kind = state.kind,
                        _result = state.result,
                        ch;

                    ch = state.input.charCodeAt(state.position);

                    if (is_WS_OR_EOL(ch)             ||
                        is_FLOW_INDICATOR(ch)        ||
                        0x23/* # */           === ch ||
                        0x26/* & */           === ch ||
                        0x2A/* * */           === ch ||
                        0x21/* ! */           === ch ||
                        0x7C/* | */           === ch ||
                        0x3E/* > */           === ch ||
                        0x27/* ' */           === ch ||
                        0x22/* " */           === ch ||
                        0x25/* % */           === ch ||
                        0x40/* @ */           === ch ||
                        0x60/* ` */           === ch) {
                        return false;
                    }

                    if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
                        following = state.input.charCodeAt(state.position + 1);

                        if (is_WS_OR_EOL(following) ||
                            withinFlowCollection && is_FLOW_INDICATOR(following)) {
                            return false;
                        }
                    }

                    state.kind = 'scalar';
                    state.result = '';
                    captureStart = captureEnd = state.position;
                    hasPendingContent = false;

                    while (0 !== ch) {
                        if (0x3A/* : */ === ch) {
                            following = state.input.charCodeAt(state.position + 1);

                            if (is_WS_OR_EOL(following) ||
                                withinFlowCollection && is_FLOW_INDICATOR(following)) {
                                break;
                            }

                        } else if (0x23/* # */ === ch) {
                            preceding = state.input.charCodeAt(state.position - 1);

                            if (is_WS_OR_EOL(preceding)) {
                                break;
                            }

                        } else if (state.position === state.lineStart && testDocumentSeparator(state) ||
                            withinFlowCollection && is_FLOW_INDICATOR(ch)) {
                            break;

                        } else if (is_EOL(ch)) {
                            _line = state.line;
                            _lineStart = state.lineStart;
                            _lineIndent = state.lineIndent;
                            skipSeparationSpace(state, false, -1);

                            if (state.lineIndent >= nodeIndent) {
                                hasPendingContent = true;
                                ch = state.input.charCodeAt(state.position);
                                continue;
                            } else {
                                state.position = captureEnd;
                                state.line = _line;
                                state.lineStart = _lineStart;
                                state.lineIndent = _lineIndent;
                                break;
                            }
                        }

                        if (hasPendingContent) {
                            captureSegment(state, captureStart, captureEnd, false);
                            writeFoldedLines(state, state.line - _line);
                            captureStart = captureEnd = state.position;
                            hasPendingContent = false;
                        }

                        if (!is_WHITE_SPACE(ch)) {
                            captureEnd = state.position + 1;
                        }

                        ch = state.input.charCodeAt(++state.position);
                    }

                    captureSegment(state, captureStart, captureEnd, false);

                    if (state.result) {
                        return true;
                    }

                    state.kind = _kind;
                    state.result = _result;

                    return false;
                }

                function readSingleQuotedScalar(state, nodeIndent) {
                    var ch,
                        captureStart, captureEnd;

                    ch = state.input.charCodeAt(state.position);

                    if (0x27/* ' */ !== ch) {
                        return false;
                    }

                    state.kind = 'scalar';
                    state.result = '';
                    state.position++;
                    captureStart = captureEnd = state.position;

                    while (0 !== (ch = state.input.charCodeAt(state.position))) {
                        if (0x27/* ' */ === ch) {
                            captureSegment(state, captureStart, state.position, true);
                            ch = state.input.charCodeAt(++state.position);

                            if (0x27/* ' */ === ch) {
                                captureStart = captureEnd = state.position;
                                state.position++;
                            } else {
                                return true;
                            }

                        } else if (is_EOL(ch)) {
                            captureSegment(state, captureStart, captureEnd, true);
                            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                            captureStart = captureEnd = state.position;

                        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
                            throwError(state, 'unexpected end of the document within a single quoted scalar');

                        } else {
                            state.position++;
                            captureEnd = state.position;
                        }
                    }

                    throwError(state, 'unexpected end of the stream within a single quoted scalar');
                }

                function readDoubleQuotedScalar(state, nodeIndent) {
                    var captureStart,
                        captureEnd,
                        hexLength,
                        hexResult,
                        tmp, tmpEsc,
                        ch;

                    ch = state.input.charCodeAt(state.position);

                    if (0x22/* " */ !== ch) {
                        return false;
                    }

                    state.kind = 'scalar';
                    state.result = '';
                    state.position++;
                    captureStart = captureEnd = state.position;

                    while (0 !== (ch = state.input.charCodeAt(state.position))) {
                        if (0x22/* " */ === ch) {
                            captureSegment(state, captureStart, state.position, true);
                            state.position++;

                            return true;

                        } else if (0x5C/* \ */ === ch) {
                            captureSegment(state, captureStart, state.position, true);
                            ch = state.input.charCodeAt(++state.position);

                            if (is_EOL(ch)) {
                                skipSeparationSpace(state, false, nodeIndent);

                                // TODO: rework to inline fn with no type cast?
                            } else if (ch < 256 && simpleEscapeCheck[ch]) {
                                state.result += simpleEscapeMap[ch];
                                state.position++;

                            } else if ((tmp = escapedHexLen(ch)) > 0) {
                                hexLength = tmp;
                                hexResult = 0;

                                for (; hexLength > 0; hexLength--) {
                                    ch = state.input.charCodeAt(++state.position);

                                    if ((tmp = fromHexCode(ch)) >= 0) {
                                        hexResult = (hexResult << 4) + tmp;

                                    } else {
                                        throwError(state, 'expected hexadecimal character');
                                    }
                                }

                                state.result += charFromCodepoint(hexResult);

                                state.position++;

                            } else {
                                throwError(state, 'unknown escape sequence');
                            }

                            captureStart = captureEnd = state.position;

                        } else if (is_EOL(ch)) {
                            captureSegment(state, captureStart, captureEnd, true);
                            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                            captureStart = captureEnd = state.position;

                        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
                            throwError(state, 'unexpected end of the document within a double quoted scalar');

                        } else {
                            state.position++;
                            captureEnd = state.position;
                        }
                    }

                    throwError(state, 'unexpected end of the stream within a double quoted scalar');
                }

                function readFlowCollection(state, nodeIndent) {
                    var readNext = true,
                        _line,
                        _tag     = state.tag,
                        _result,
                        _anchor  = state.anchor,
                        following,
                        terminator,
                        isPair,
                        isExplicitPair,
                        isMapping,
                        keyNode,
                        keyTag,
                        valueNode,
                        ch;

                    ch = state.input.charCodeAt(state.position);

                    if (ch === 0x5B/* [ */) {
                        terminator = 0x5D;/* ] */
                        isMapping = false;
                        _result = [];
                    } else if (ch === 0x7B/* { */) {
                        terminator = 0x7D;/* } */
                        isMapping = true;
                        _result = {};
                    } else {
                        return false;
                    }

                    if (null !== state.anchor) {
                        state.anchorMap[state.anchor] = _result;
                    }

                    ch = state.input.charCodeAt(++state.position);

                    while (0 !== ch) {
                        skipSeparationSpace(state, true, nodeIndent);

                        ch = state.input.charCodeAt(state.position);

                        if (ch === terminator) {
                            state.position++;
                            state.tag = _tag;
                            state.anchor = _anchor;
                            state.kind = isMapping ? 'mapping' : 'sequence';
                            state.result = _result;

                            return true;
                        } else if (!readNext) {
                            throwError(state, 'missed comma between flow collection entries');
                        }

                        keyTag = keyNode = valueNode = null;
                        isPair = isExplicitPair = false;

                        if (0x3F/* ? */ === ch) {
                            following = state.input.charCodeAt(state.position + 1);

                            if (is_WS_OR_EOL(following)) {
                                isPair = isExplicitPair = true;
                                state.position++;
                                skipSeparationSpace(state, true, nodeIndent);
                            }
                        }

                        _line = state.line;
                        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                        keyTag = state.tag;
                        keyNode = state.result;
                        skipSeparationSpace(state, true, nodeIndent);

                        ch = state.input.charCodeAt(state.position);

                        if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
                            isPair = true;
                            ch = state.input.charCodeAt(++state.position);
                            skipSeparationSpace(state, true, nodeIndent);
                            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                            valueNode = state.result;
                        }

                        if (isMapping) {
                            storeMappingPair(state, _result, keyTag, keyNode, valueNode);
                        } else if (isPair) {
                            _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
                        } else {
                            _result.push(keyNode);
                        }

                        skipSeparationSpace(state, true, nodeIndent);

                        ch = state.input.charCodeAt(state.position);

                        if (0x2C/* , */ === ch) {
                            readNext = true;
                            ch = state.input.charCodeAt(++state.position);
                        } else {
                            readNext = false;
                        }
                    }

                    throwError(state, 'unexpected end of the stream within a flow collection');
                }

                function readBlockScalar(state, nodeIndent) {
                    var captureStart,
                        folding,
                        chomping       = CHOMPING_CLIP,
                        detectedIndent = false,
                        textIndent     = nodeIndent,
                        emptyLines     = 0,
                        atMoreIndented = false,
                        tmp,
                        ch;

                    ch = state.input.charCodeAt(state.position);

                    if (ch === 0x7C/* | */) {
                        folding = false;
                    } else if (ch === 0x3E/* > */) {
                        folding = true;
                    } else {
                        return false;
                    }

                    state.kind = 'scalar';
                    state.result = '';

                    while (0 !== ch) {
                        ch = state.input.charCodeAt(++state.position);

                        if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
                            if (CHOMPING_CLIP === chomping) {
                                chomping = 0x2B/* + */ === ch ? CHOMPING_KEEP : CHOMPING_STRIP;
                            } else {
                                throwError(state, 'repeat of a chomping mode identifier');
                            }

                        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
                            if (tmp === 0) {
                                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
                            } else if (!detectedIndent) {
                                textIndent = nodeIndent + tmp - 1;
                                detectedIndent = true;
                            } else {
                                throwError(state, 'repeat of an indentation width identifier');
                            }

                        } else {
                            break;
                        }
                    }

                    if (is_WHITE_SPACE(ch)) {
                        do {
                            ch = state.input.charCodeAt(++state.position);
                        }
                        while (is_WHITE_SPACE(ch));

                        if (0x23/* # */ === ch) {
                            do {
                                ch = state.input.charCodeAt(++state.position);
                            }
                            while (!is_EOL(ch) && 0 !== ch);
                        }
                    }

                    while (0 !== ch) {
                        readLineBreak(state);
                        state.lineIndent = 0;

                        ch = state.input.charCodeAt(state.position);

                        while ((!detectedIndent || state.lineIndent < textIndent) &&
                        0x20/* Space */ === ch) {
                            state.lineIndent++;
                            ch = state.input.charCodeAt(++state.position);
                        }

                        if (!detectedIndent && state.lineIndent > textIndent) {
                            textIndent = state.lineIndent;
                        }

                        if (is_EOL(ch)) {
                            emptyLines++;
                            continue;
                        }

                        // End of the scalar.
                        if (state.lineIndent < textIndent) {

                            // Perform the chomping.
                            if (chomping === CHOMPING_KEEP) {
                                state.result += common.repeat('\n', emptyLines);
                            } else if (chomping === CHOMPING_CLIP) {
                                if (detectedIndent) { // i.e. only if the scalar is not empty.
                                    state.result += '\n';
                                }
                            }

                            // Break this `while` cycle and go to the funciton's epilogue.
                            break;
                        }

                        // Folded style: use fancy rules to handle line breaks.
                        if (folding) {

                            // Lines starting with white space characters (more-indented lines) are not folded.
                            if (is_WHITE_SPACE(ch)) {
                                atMoreIndented = true;
                                state.result += common.repeat('\n', emptyLines + 1);

                                // End of more-indented block.
                            } else if (atMoreIndented) {
                                atMoreIndented = false;
                                state.result += common.repeat('\n', emptyLines + 1);

                                // Just one line break - perceive as the same line.
                            } else if (0 === emptyLines) {
                                if (detectedIndent) { // i.e. only if we have already read some scalar content.
                                    state.result += ' ';
                                }

                                // Several line breaks - perceive as different lines.
                            } else {
                                state.result += common.repeat('\n', emptyLines);
                            }

                            // Literal style: just add exact number of line breaks between content lines.
                        } else if (detectedIndent) {
                            // If current line isn't the first one - count line break from the last content line.
                            state.result += common.repeat('\n', emptyLines + 1);
                        } else {
                            // In case of the first content line - count only empty lines.
                        }

                        detectedIndent = true;
                        emptyLines = 0;
                        captureStart = state.position;

                        while (!is_EOL(ch) && 0 !== ch) {
                            ch = state.input.charCodeAt(++state.position);
                        }

                        captureSegment(state, captureStart, state.position, false);
                    }

                    return true;
                }

                function readBlockSequence(state, nodeIndent) {
                    var _line,
                        _tag      = state.tag,
                        _anchor   = state.anchor,
                        _result   = [],
                        following,
                        detected  = false,
                        ch;

                    if (null !== state.anchor) {
                        state.anchorMap[state.anchor] = _result;
                    }

                    ch = state.input.charCodeAt(state.position);

                    while (0 !== ch) {

                        if (0x2D/* - */ !== ch) {
                            break;
                        }

                        following = state.input.charCodeAt(state.position + 1);

                        if (!is_WS_OR_EOL(following)) {
                            break;
                        }

                        detected = true;
                        state.position++;

                        if (skipSeparationSpace(state, true, -1)) {
                            if (state.lineIndent <= nodeIndent) {
                                _result.push(null);
                                ch = state.input.charCodeAt(state.position);
                                continue;
                            }
                        }

                        _line = state.line;
                        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
                        _result.push(state.result);
                        skipSeparationSpace(state, true, -1);

                        ch = state.input.charCodeAt(state.position);

                        if ((state.line === _line || state.lineIndent > nodeIndent) && 0 !== ch) {
                            throwError(state, 'bad indentation of a sequence entry');
                        } else if (state.lineIndent < nodeIndent) {
                            break;
                        }
                    }

                    if (detected) {
                        state.tag = _tag;
                        state.anchor = _anchor;
                        state.kind = 'sequence';
                        state.result = _result;

                        return true;
                    }

                    return false;
                }

                function readBlockMapping(state, nodeIndent, flowIndent) {
                    var following,
                        allowCompact,
                        _line,
                        _tag          = state.tag,
                        _anchor       = state.anchor,
                        _result       = {},
                        keyTag        = null,
                        keyNode       = null,
                        valueNode     = null,
                        atExplicitKey = false,
                        detected      = false,
                        ch;

                    if (null !== state.anchor) {
                        state.anchorMap[state.anchor] = _result;
                    }

                    ch = state.input.charCodeAt(state.position);

                    while (0 !== ch) {
                        following = state.input.charCodeAt(state.position + 1);
                        _line = state.line; // Save the current line.

                        //
                        // Explicit notation case. There are two separate blocks:
                        // first for the key (denoted by "?") and second for the value (denoted by ":")
                        //
                        if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

                            if (0x3F/* ? */ === ch) {
                                if (atExplicitKey) {
                                    storeMappingPair(state, _result, keyTag, keyNode, null);
                                    keyTag = keyNode = valueNode = null;
                                }

                                detected = true;
                                atExplicitKey = true;
                                allowCompact = true;

                            } else if (atExplicitKey) {
                                // i.e. 0x3A/* : */ === character after the explicit key.
                                atExplicitKey = false;
                                allowCompact = true;

                            } else {
                                throwError(state, 'incomplete explicit mapping pair; a key node is missed');
                            }

                            state.position += 1;
                            ch = following;

                            //
                            // Implicit notation case. Flow-style node as the key first, then ":", and the value.
                            //
                        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

                            if (state.line === _line) {
                                ch = state.input.charCodeAt(state.position);

                                while (is_WHITE_SPACE(ch)) {
                                    ch = state.input.charCodeAt(++state.position);
                                }

                                if (0x3A/* : */ === ch) {
                                    ch = state.input.charCodeAt(++state.position);

                                    if (!is_WS_OR_EOL(ch)) {
                                        throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
                                    }

                                    if (atExplicitKey) {
                                        storeMappingPair(state, _result, keyTag, keyNode, null);
                                        keyTag = keyNode = valueNode = null;
                                    }

                                    detected = true;
                                    atExplicitKey = false;
                                    allowCompact = false;
                                    keyTag = state.tag;
                                    keyNode = state.result;

                                } else if (detected) {
                                    throwError(state, 'can not read an implicit mapping pair; a colon is missed');

                                } else {
                                    state.tag = _tag;
                                    state.anchor = _anchor;

                                    return true; // Keep the result of `composeNode`.
                                }

                            } else if (detected) {
                                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

                            } else {
                                state.tag = _tag;
                                state.anchor = _anchor;

                                return true; // Keep the result of `composeNode`.
                            }

                        } else {
                            break; // Reading is done. Go to the epilogue.
                        }

                        //
                        // Common reading code for both explicit and implicit notations.
                        //
                        if (state.line === _line || state.lineIndent > nodeIndent) {
                            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                                if (atExplicitKey) {
                                    keyNode = state.result;
                                } else {
                                    valueNode = state.result;
                                }
                            }

                            if (!atExplicitKey) {
                                storeMappingPair(state, _result, keyTag, keyNode, valueNode);
                                keyTag = keyNode = valueNode = null;
                            }

                            skipSeparationSpace(state, true, -1);
                            ch = state.input.charCodeAt(state.position);
                        }

                        if (state.lineIndent > nodeIndent && 0 !== ch) {
                            throwError(state, 'bad indentation of a mapping entry');
                        } else if (state.lineIndent < nodeIndent) {
                            break;
                        }
                    }

                    //
                    // Epilogue.
                    //

                    // Special case: last mapping's node contains only the key in explicit notation.
                    if (atExplicitKey) {
                        storeMappingPair(state, _result, keyTag, keyNode, null);
                    }

                    // Expose the resulting mapping.
                    if (detected) {
                        state.tag = _tag;
                        state.anchor = _anchor;
                        state.kind = 'mapping';
                        state.result = _result;
                    }

                    return detected;
                }

                function readTagProperty(state) {
                    var _position,
                        isVerbatim = false,
                        isNamed    = false,
                        tagHandle,
                        tagName,
                        ch;

                    ch = state.input.charCodeAt(state.position);

                    if (0x21/* ! */ !== ch) {
                        return false;
                    }

                    if (null !== state.tag) {
                        throwError(state, 'duplication of a tag property');
                    }

                    ch = state.input.charCodeAt(++state.position);

                    if (0x3C/* < */ === ch) {
                        isVerbatim = true;
                        ch = state.input.charCodeAt(++state.position);

                    } else if (0x21/* ! */ === ch) {
                        isNamed = true;
                        tagHandle = '!!';
                        ch = state.input.charCodeAt(++state.position);

                    } else {
                        tagHandle = '!';
                    }

                    _position = state.position;

                    if (isVerbatim) {
                        do {
                            ch = state.input.charCodeAt(++state.position);
                        }
                        while (0 !== ch && 0x3E/* > */ !== ch);

                        if (state.position < state.length) {
                            tagName = state.input.slice(_position, state.position);
                            ch = state.input.charCodeAt(++state.position);
                        } else {
                            throwError(state, 'unexpected end of the stream within a verbatim tag');
                        }
                    } else {
                        while (0 !== ch && !is_WS_OR_EOL(ch)) {

                            if (0x21/* ! */ === ch) {
                                if (!isNamed) {
                                    tagHandle = state.input.slice(_position - 1, state.position + 1);

                                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                                        throwError(state, 'named tag handle cannot contain such characters');
                                    }

                                    isNamed = true;
                                    _position = state.position + 1;
                                } else {
                                    throwError(state, 'tag suffix cannot contain exclamation marks');
                                }
                            }

                            ch = state.input.charCodeAt(++state.position);
                        }

                        tagName = state.input.slice(_position, state.position);

                        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
                            throwError(state, 'tag suffix cannot contain flow indicator characters');
                        }
                    }

                    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
                        throwError(state, 'tag name cannot contain such characters: ' + tagName);
                    }

                    if (isVerbatim) {
                        state.tag = tagName;

                    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
                        state.tag = state.tagMap[tagHandle] + tagName;

                    } else if ('!' === tagHandle) {
                        state.tag = '!' + tagName;

                    } else if ('!!' === tagHandle) {
                        state.tag = 'tag:yaml.org,2002:' + tagName;

                    } else {
                        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
                    }

                    return true;
                }

                function readAnchorProperty(state) {
                    var _position,
                        ch;

                    ch = state.input.charCodeAt(state.position);

                    if (0x26/* & */ !== ch) {
                        return false;
                    }

                    if (null !== state.anchor) {
                        throwError(state, 'duplication of an anchor property');
                    }

                    ch = state.input.charCodeAt(++state.position);
                    _position = state.position;

                    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
                        ch = state.input.charCodeAt(++state.position);
                    }

                    if (state.position === _position) {
                        throwError(state, 'name of an anchor node must contain at least one character');
                    }

                    state.anchor = state.input.slice(_position, state.position);

                    return true;
                }

                function readAlias(state) {
                    var _position, alias,
                        len = state.length,
                        input = state.input,
                        ch;

                    ch = state.input.charCodeAt(state.position);

                    if (0x2A/* * */ !== ch) {
                        return false;
                    }

                    ch = state.input.charCodeAt(++state.position);
                    _position = state.position;

                    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
                        ch = state.input.charCodeAt(++state.position);
                    }

                    if (state.position === _position) {
                        throwError(state, 'name of an alias node must contain at least one character');
                    }

                    alias = state.input.slice(_position, state.position);

                    if (!state.anchorMap.hasOwnProperty(alias)) {
                        throwError(state, 'unidentified alias "' + alias + '"');
                    }

                    state.result = state.anchorMap[alias];
                    skipSeparationSpace(state, true, -1);

                    return true;
                }

                function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
                    var allowBlockStyles,
                        allowBlockScalars,
                        allowBlockCollections,
                        indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
                        atNewLine  = false,
                        hasContent = false,
                        typeIndex,
                        typeQuantity,
                        type,
                        flowIndent,
                        blockIndent,
                        _result;

                    state.tag    = null;
                    state.anchor = null;
                    state.kind   = null;
                    state.result = null;

                    allowBlockStyles = allowBlockScalars = allowBlockCollections =
                        CONTEXT_BLOCK_OUT === nodeContext ||
                        CONTEXT_BLOCK_IN  === nodeContext;

                    if (allowToSeek) {
                        if (skipSeparationSpace(state, true, -1)) {
                            atNewLine = true;

                            if (state.lineIndent > parentIndent) {
                                indentStatus = 1;
                            } else if (state.lineIndent === parentIndent) {
                                indentStatus = 0;
                            } else if (state.lineIndent < parentIndent) {
                                indentStatus = -1;
                            }
                        }
                    }

                    if (1 === indentStatus) {
                        while (readTagProperty(state) || readAnchorProperty(state)) {
                            if (skipSeparationSpace(state, true, -1)) {
                                atNewLine = true;
                                allowBlockCollections = allowBlockStyles;

                                if (state.lineIndent > parentIndent) {
                                    indentStatus = 1;
                                } else if (state.lineIndent === parentIndent) {
                                    indentStatus = 0;
                                } else if (state.lineIndent < parentIndent) {
                                    indentStatus = -1;
                                }
                            } else {
                                allowBlockCollections = false;
                            }
                        }
                    }

                    if (allowBlockCollections) {
                        allowBlockCollections = atNewLine || allowCompact;
                    }

                    if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
                        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
                            flowIndent = parentIndent;
                        } else {
                            flowIndent = parentIndent + 1;
                        }

                        blockIndent = state.position - state.lineStart;

                        if (1 === indentStatus) {
                            if (allowBlockCollections &&
                                (readBlockSequence(state, blockIndent) ||
                                readBlockMapping(state, blockIndent, flowIndent)) ||
                                readFlowCollection(state, flowIndent)) {
                                hasContent = true;
                            } else {
                                if (allowBlockScalars && readBlockScalar(state, flowIndent) ||
                                    readSingleQuotedScalar(state, flowIndent) ||
                                    readDoubleQuotedScalar(state, flowIndent)) {
                                    hasContent = true;

                                } else if (readAlias(state)) {
                                    hasContent = true;

                                    if (null !== state.tag || null !== state.anchor) {
                                        throwError(state, 'alias node should not have any properties');
                                    }

                                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                                    hasContent = true;

                                    if (null === state.tag) {
                                        state.tag = '?';
                                    }
                                }

                                if (null !== state.anchor) {
                                    state.anchorMap[state.anchor] = state.result;
                                }
                            }
                        } else if (0 === indentStatus) {
                            // Special case: block sequences are allowed to have same indentation level as the parent.
                            // http://www.yaml.org/spec/1.2/spec.html#id2799784
                            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
                        }
                    }

                    if (null !== state.tag && '!' !== state.tag) {
                        if ('?' === state.tag) {
                            for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
                                 typeIndex < typeQuantity;
                                 typeIndex += 1) {
                                type = state.implicitTypes[typeIndex];

                                // Implicit resolving is not allowed for non-scalar types, and '?'
                                // non-specific tag is only assigned to plain scalars. So, it isn't
                                // needed to check for 'kind' conformity.

                                if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
                                    state.result = type.construct(state.result);
                                    state.tag = type.tag;

                                    if (null !== state.anchor) {
                                        state.anchorMap[state.anchor] = state.result;
                                    }
                                    break;
                                }
                            }
                        } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
                            type = state.typeMap[state.tag];

                            if (null !== state.result && type.kind !== state.kind) {
                                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
                            }

                            if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
                                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
                            } else {
                                state.result = type.construct(state.result);

                                if (null !== state.anchor) {
                                    state.anchorMap[state.anchor] = state.result;
                                }
                            }
                        } else {
                            throwWarning(state, 'unknown tag !<' + state.tag + '>');
                        }
                    }

                    return null !== state.tag || null !== state.anchor || hasContent;
                }

                function readDocument(state) {
                    var documentStart = state.position,
                        _position,
                        directiveName,
                        directiveArgs,
                        hasDirectives = false,
                        ch;

                    state.version = null;
                    state.checkLineBreaks = state.legacy;
                    state.tagMap = {};
                    state.anchorMap = {};

                    while (0 !== (ch = state.input.charCodeAt(state.position))) {
                        skipSeparationSpace(state, true, -1);

                        ch = state.input.charCodeAt(state.position);

                        if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
                            break;
                        }

                        hasDirectives = true;
                        ch = state.input.charCodeAt(++state.position);
                        _position = state.position;

                        while (0 !== ch && !is_WS_OR_EOL(ch)) {
                            ch = state.input.charCodeAt(++state.position);
                        }

                        directiveName = state.input.slice(_position, state.position);
                        directiveArgs = [];

                        if (directiveName.length < 1) {
                            throwError(state, 'directive name must not be less than one character in length');
                        }

                        while (0 !== ch) {
                            while (is_WHITE_SPACE(ch)) {
                                ch = state.input.charCodeAt(++state.position);
                            }

                            if (0x23/* # */ === ch) {
                                do {
                                    ch = state.input.charCodeAt(++state.position);
                                }
                                while (0 !== ch && !is_EOL(ch));
                                break;
                            }

                            if (is_EOL(ch)) {
                                break;
                            }

                            _position = state.position;

                            while (0 !== ch && !is_WS_OR_EOL(ch)) {
                                ch = state.input.charCodeAt(++state.position);
                            }

                            directiveArgs.push(state.input.slice(_position, state.position));
                        }

                        if (0 !== ch) {
                            readLineBreak(state);
                        }

                        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
                            directiveHandlers[directiveName](state, directiveName, directiveArgs);
                        } else {
                            throwWarning(state, 'unknown document directive "' + directiveName + '"');
                        }
                    }

                    skipSeparationSpace(state, true, -1);

                    if (0 === state.lineIndent &&
                        0x2D/* - */ === state.input.charCodeAt(state.position) &&
                        0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
                        0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
                        state.position += 3;
                        skipSeparationSpace(state, true, -1);

                    } else if (hasDirectives) {
                        throwError(state, 'directives end mark is expected');
                    }

                    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
                    skipSeparationSpace(state, true, -1);

                    if (state.checkLineBreaks &&
                        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
                        throwWarning(state, 'non-ASCII line breaks are interpreted as content');
                    }

                    state.documents.push(state.result);

                    if (state.position === state.lineStart && testDocumentSeparator(state)) {

                        if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
                            state.position += 3;
                            skipSeparationSpace(state, true, -1);
                        }

                        return;
                    }

                    if (state.position < state.length - 1) {
                        throwError(state, 'end of the stream or a document separator is expected');
                    } else {
                        return;
                    }
                }

                function loadDocuments(input, options) {
                    input = String(input);
                    options = options || {};

                    if (input.length !== 0) {

                        // Add tailing `\n` if not exists
                        if (0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
                            0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
                            input += '\n';
                        }

                        // Strip BOM
                        if (input.charCodeAt(0) === 0xFEFF) {
                            input = input.slice(1);
                        }
                    }

                    var state = new State(input, options);

                    if (PATTERN_NON_PRINTABLE.test(state.input)) {
                        throwError(state, 'the stream contains non-printable characters');
                    }

                    // Use 0 as string terminator. That significantly simplifies bounds check.
                    state.input += '\0';

                    while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
                        state.lineIndent += 1;
                        state.position += 1;
                    }

                    while (state.position < state.length - 1) {
                        readDocument(state);
                    }

                    return state.documents;
                }

                function loadAll(input, iterator, options) {
                    var documents = loadDocuments(input, options),
 index, length;

                    for (index = 0, length = documents.length; index < length; index += 1) {
                        iterator(documents[index]);
                    }
                }

                function load(input, options) {
                    var documents = loadDocuments(input, options),
 index, length;

                    if (0 === documents.length) {
                        /*eslint-disable no-undefined*/
                        return undefined;
                    } else if (1 === documents.length) {
                        return documents[0];
                    }
                    throw new YAMLException('expected a single document in the stream, but found more');
                }

                function safeLoadAll(input, output, options) {
                    loadAll(input, output, common.extend({
                        schema: DEFAULT_SAFE_SCHEMA
                    }, options));
                }

                function safeLoad(input, options) {
                    return load(input, common.extend({
                        schema: DEFAULT_SAFE_SCHEMA
                    }, options));
                }

                module.exports.loadAll     = loadAll;
                module.exports.load        = load;
                module.exports.safeLoadAll = safeLoadAll;
                module.exports.safeLoad    = safeLoad;

            },{
                './common': 23,'./exception': 25,'./mark': 27,'./schema/default_full': 30,'./schema/default_safe': 31
            }],27: [function (require, module, exports) {
                'use strict';

                var common = require('./common');

                function Mark(name, buffer, position, line, column) {
                    this.name     = name;
                    this.buffer   = buffer;
                    this.position = position;
                    this.line     = line;
                    this.column   = column;
                }

                Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
                    var head, start, tail, end, snippet;

                    if (!this.buffer) {
                        return null;
                    }

                    indent = indent || 4;
                    maxLength = maxLength || 75;

                    head = '';
                    start = this.position;

                    while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
                        start -= 1;

                        if (this.position - start > maxLength / 2 - 1) {
                            head = ' ... ';
                            start += 5;
                            break;
                        }
                    }

                    tail = '';
                    end = this.position;

                    while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
                        end += 1;

                        if (end - this.position > maxLength / 2 - 1) {
                            tail = ' ... ';
                            end -= 5;
                            break;
                        }
                    }

                    snippet = this.buffer.slice(start, end);

                    return common.repeat(' ', indent) + head + snippet + tail + '\n' +
                        common.repeat(' ', indent + this.position - start + head.length) + '^';
                };

                Mark.prototype.toString = function toString(compact) {
                    var snippet, where = '';

                    if (this.name) {
                        where += 'in "' + this.name + '" ';
                    }

                    where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

                    if (!compact) {
                        snippet = this.getSnippet();

                        if (snippet) {
                            where += ':\n' + snippet;
                        }
                    }

                    return where;
                };

                module.exports = Mark;

            },{
                './common': 23
            }],28: [function (require, module, exports) {
                'use strict';

                /*eslint-disable max-len*/

                var common        = require('./common');
                var YAMLException = require('./exception');
                var Type          = require('./type');

                function compileList(schema, name, result) {
                    var exclude = [];

                    schema.include.forEach(function (includedSchema) {
                        result = compileList(includedSchema, name, result);
                    });

                    schema[name].forEach(function (currentType) {
                        result.forEach(function (previousType, previousIndex) {
                            if (previousType.tag === currentType.tag) {
                                exclude.push(previousIndex);
                            }
                        });

                        result.push(currentType);
                    });

                    return result.filter(function (type, index) {
                        return -1 === exclude.indexOf(index);
                    });
                }

                function compileMap(/* lists... */) {
                    var result = {},
 index, length;

                    function collectType(type) {
                        result[type.tag] = type;
                    }

                    for (index = 0, length = arguments.length; index < length; index += 1) {
                        arguments[index].forEach(collectType);
                    }

                    return result;
                }

                function Schema(definition) {
                    this.include  = definition.include  || [];
                    this.implicit = definition.implicit || [];
                    this.explicit = definition.explicit || [];

                    this.implicit.forEach(function (type) {
                        if (type.loadKind && 'scalar' !== type.loadKind) {
                            throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
                        }
                    });

                    this.compiledImplicit = compileList(this, 'implicit', []);
                    this.compiledExplicit = compileList(this, 'explicit', []);
                    this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
                }

                Schema.DEFAULT = null;

                Schema.create = function createSchema() {
                    var schemas, types;

                    switch (arguments.length) {
                        case 1:
                            schemas = Schema.DEFAULT;
                            types = arguments[0];
                            break;

                        case 2:
                            schemas = arguments[0];
                            types = arguments[1];
                            break;

                        default:
                            throw new YAMLException('Wrong number of arguments for Schema.create function');
                    }

                    schemas = common.toArray(schemas);
                    types = common.toArray(types);

                    if (!schemas.every(function (schema) {
                        return schema instanceof Schema;
                    })) {
                        throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
                    }

                    if (!types.every(function (type) {
                        return type instanceof Type;
                    })) {
                        throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
                    }

                    return new Schema({
                        include: schemas,
                        explicit: types
                    });
                };

                module.exports = Schema;

            },{
                './common': 23,'./exception': 25,'./type': 34
            }],29: [function (require, module, exports) {
                // Standard YAML's Core schema.
                // http://www.yaml.org/spec/1.2/spec.html#id2804923
                //
                // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
                // So, Core schema has no distinctions from JSON schema is JS-YAML.

                'use strict';

                var Schema = require('../schema');

                module.exports = new Schema({
                    include: [
                        require('./json')
                    ]
                });

            },{
                '../schema': 28,'./json': 33
            }],30: [function (require, module, exports) {
                // JS-YAML's default schema for `load` function.
                // It is not described in the YAML specification.
                //
                // This schema is based on JS-YAML's default safe schema and includes
                // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
                //
                // Also this schema is used as default base schema at `Schema.create` function.

                'use strict';

                var Schema = require('../schema');

                module.exports = Schema.DEFAULT = new Schema({
                    include: [
                        require('./default_safe')
                    ],
                    explicit: [
                        require('../type/js/undefined'),
                        require('../type/js/regexp'),
                        require('../type/js/function')
                    ]
                });

            },{
                '../schema': 28,'../type/js/function': 39,'../type/js/regexp': 40,'../type/js/undefined': 41,'./default_safe': 31
            }],31: [function (require, module, exports) {
                // JS-YAML's default schema for `safeLoad` function.
                // It is not described in the YAML specification.
                //
                // This schema is based on standard YAML's Core schema and includes most of
                // extra types described at YAML tag repository. (http://yaml.org/type/)

                'use strict';

                var Schema = require('../schema');

                module.exports = new Schema({
                    include: [
                        require('./core')
                    ],
                    implicit: [
                        require('../type/timestamp'),
                        require('../type/merge')
                    ],
                    explicit: [
                        require('../type/binary'),
                        require('../type/omap'),
                        require('../type/pairs'),
                        require('../type/set')
                    ]
                });

            },{
                '../schema': 28,'../type/binary': 35,'../type/merge': 43,'../type/omap': 45,'../type/pairs': 46,'../type/set': 48,'../type/timestamp': 50,'./core': 29
            }],32: [function (require, module, exports) {
                // Standard YAML's Failsafe schema.
                // http://www.yaml.org/spec/1.2/spec.html#id2802346

                'use strict';

                var Schema = require('../schema');

                module.exports = new Schema({
                    explicit: [
                        require('../type/str'),
                        require('../type/seq'),
                        require('../type/map')
                    ]
                });

            },{
                '../schema': 28,'../type/map': 42,'../type/seq': 47,'../type/str': 49
            }],33: [function (require, module, exports) {
                // Standard YAML's JSON schema.
                // http://www.yaml.org/spec/1.2/spec.html#id2803231
                //
                // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
                // So, this schema is not such strict as defined in the YAML specification.
                // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.

                'use strict';

                var Schema = require('../schema');

                module.exports = new Schema({
                    include: [
                        require('./failsafe')
                    ],
                    implicit: [
                        require('../type/null'),
                        require('../type/bool'),
                        require('../type/int'),
                        require('../type/float')
                    ]
                });

            },{
                '../schema': 28,'../type/bool': 36,'../type/float': 37,'../type/int': 38,'../type/null': 44,'./failsafe': 32
            }],34: [function (require, module, exports) {
                'use strict';

                var YAMLException = require('./exception');

                var TYPE_CONSTRUCTOR_OPTIONS = [
                    'kind',
                    'resolve',
                    'construct',
                    'instanceOf',
                    'predicate',
                    'represent',
                    'defaultStyle',
                    'styleAliases'
                ];

                var YAML_NODE_KINDS = [
                    'scalar',
                    'sequence',
                    'mapping'
                ];

                function compileStyleAliases(map) {
                    var result = {};

                    if (null !== map) {
                        Object.keys(map).forEach(function (style) {
                            map[style].forEach(function (alias) {
                                result[String(alias)] = style;
                            });
                        });
                    }

                    return result;
                }

                function Type(tag, options) {
                    options = options || {};

                    Object.keys(options).forEach(function (name) {
                        if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
                            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
                        }
                    });

                    // TODO: Add tag format check.
                    this.tag          = tag;
                    this.kind         = options['kind']         || null;
                    this.resolve      = options['resolve']      || function () {
                        return true;
                    };
                    this.construct    = options['construct']    || function (data) {
                        return data;
                    };
                    this.instanceOf   = options['instanceOf']   || null;
                    this.predicate    = options['predicate']    || null;
                    this.represent    = options['represent']    || null;
                    this.defaultStyle = options['defaultStyle'] || null;
                    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

                    if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
                        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
                    }
                }

                module.exports = Type;

            },{
                './exception': 25
            }],35: [function (require, module, exports) {
                'use strict';

                /*eslint-disable no-bitwise*/

                // A trick for browserified version.
                // Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
                var NodeBuffer = require('buffer').Buffer;
                var Type       = require('../type');


                // [ 64, 65, 66 ] -> [ padding, CR, LF ]
                var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

                function resolveYamlBinary(data) {
                    if (null === data) {
                        return false;
                    }

                    var code, idx, bitlen = 0,
 len = 0,
 max = data.length,
 map = BASE64_MAP;

                    // Convert one by one.
                    for (idx = 0; idx < max; idx++) {
                        code = map.indexOf(data.charAt(idx));

                        // Skip CR/LF
                        if (code > 64) {
                            continue;
                        }

                        // Fail on illegal characters
                        if (code < 0) {
                            return false;
                        }

                        bitlen += 6;
                    }

                    // If there are any bits left, source was corrupted
                    return bitlen % 8 === 0;
                }

                function constructYamlBinary(data) {
                    var code, idx, tailbits,
                        input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
                        max = input.length,
                        map = BASE64_MAP,
                        bits = 0,
                        result = [];

                    // Collect by 6*4 bits (3 bytes)

                    for (idx = 0; idx < max; idx++) {
                        if (idx % 4 === 0 && idx) {
                            result.push(bits >> 16 & 0xFF);
                            result.push(bits >> 8 & 0xFF);
                            result.push(bits & 0xFF);
                        }

                        bits = bits << 6 | map.indexOf(input.charAt(idx));
                    }

                    // Dump tail

                    tailbits = max % 4 * 6;

                    if (tailbits === 0) {
                        result.push(bits >> 16 & 0xFF);
                        result.push(bits >> 8 & 0xFF);
                        result.push(bits & 0xFF);
                    } else if (tailbits === 18) {
                        result.push(bits >> 10 & 0xFF);
                        result.push(bits >> 2 & 0xFF);
                    } else if (tailbits === 12) {
                        result.push(bits >> 4 & 0xFF);
                    }

                    // Wrap into Buffer for NodeJS and leave Array for browser
                    if (NodeBuffer) {
                        return new NodeBuffer(result);
                    }

                    return result;
                }

                function representYamlBinary(object /*, style*/) {
                    var result = '',
 bits = 0,
 idx, tail,
                        max = object.length,
                        map = BASE64_MAP;

                    // Convert every three bytes to 4 ASCII characters.

                    for (idx = 0; idx < max; idx++) {
                        if (idx % 3 === 0 && idx) {
                            result += map[bits >> 18 & 0x3F];
                            result += map[bits >> 12 & 0x3F];
                            result += map[bits >> 6 & 0x3F];
                            result += map[bits & 0x3F];
                        }

                        bits = (bits << 8) + object[idx];
                    }

                    // Dump tail

                    tail = max % 3;

                    if (tail === 0) {
                        result += map[bits >> 18 & 0x3F];
                        result += map[bits >> 12 & 0x3F];
                        result += map[bits >> 6 & 0x3F];
                        result += map[bits & 0x3F];
                    } else if (tail === 2) {
                        result += map[bits >> 10 & 0x3F];
                        result += map[bits >> 4 & 0x3F];
                        result += map[bits << 2 & 0x3F];
                        result += map[64];
                    } else if (tail === 1) {
                        result += map[bits >> 2 & 0x3F];
                        result += map[bits << 4 & 0x3F];
                        result += map[64];
                        result += map[64];
                    }

                    return result;
                }

                function isBinary(object) {
                    return NodeBuffer && NodeBuffer.isBuffer(object);
                }

                module.exports = new Type('tag:yaml.org,2002:binary', {
                    kind: 'scalar',
                    resolve: resolveYamlBinary,
                    construct: constructYamlBinary,
                    predicate: isBinary,
                    represent: representYamlBinary
                });

            },{
                '../type': 34,'buffer': 12
            }],36: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                function resolveYamlBoolean(data) {
                    if (null === data) {
                        return false;
                    }

                    var max = data.length;

                    return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') ||
                        max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
                }

                function constructYamlBoolean(data) {
                    return data === 'true' ||
                        data === 'True' ||
                        data === 'TRUE';
                }

                function isBoolean(object) {
                    return '[object Boolean]' === Object.prototype.toString.call(object);
                }

                module.exports = new Type('tag:yaml.org,2002:bool', {
                    kind: 'scalar',
                    resolve: resolveYamlBoolean,
                    construct: constructYamlBoolean,
                    predicate: isBoolean,
                    represent: {
                        lowercase: function (object) {
                            return object ? 'true' : 'false';
                        },
                        uppercase: function (object) {
                            return object ? 'TRUE' : 'FALSE';
                        },
                        camelcase: function (object) {
                            return object ? 'True' : 'False';
                        }
                    },
                    defaultStyle: 'lowercase'
                });

            },{
                '../type': 34
            }],37: [function (require, module, exports) {
                'use strict';

                var common = require('../common');
                var Type   = require('../type');

                var YAML_FLOAT_PATTERN = new RegExp(
                    '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
                    '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
                    '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
                    '|[-+]?\\.(?:inf|Inf|INF)' +
                    '|\\.(?:nan|NaN|NAN))$');

                function resolveYamlFloat(data) {
                    if (null === data) {
                        return false;
                    }

                    var value, sign, base, digits;

                    if (!YAML_FLOAT_PATTERN.test(data)) {
                        return false;
                    }

                    return true;
                }

                function constructYamlFloat(data) {
                    var value, sign, base, digits;

                    value  = data.replace(/_/g, '').toLowerCase();
                    sign   = '-' === value[0] ? -1 : 1;
                    digits = [];

                    if (0 <= '+-'.indexOf(value[0])) {
                        value = value.slice(1);
                    }

                    if ('.inf' === value) {
                        return 1 === sign ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

                    } else if ('.nan' === value) {
                        return NaN;

                    } else if (0 <= value.indexOf(':')) {
                        value.split(':').forEach(function (v) {
                            digits.unshift(parseFloat(v, 10));
                        });

                        value = 0.0;
                        base = 1;

                        digits.forEach(function (d) {
                            value += d * base;
                            base *= 60;
                        });

                        return sign * value;

                    }

                    return sign * parseFloat(value, 10);
                }

                function representYamlFloat(object, style) {
                    if (isNaN(object)) {
                        switch (style) {
                            case 'lowercase':
                                return '.nan';

                            case 'uppercase':
                                return '.NAN';

                            case 'camelcase':
                                return '.NaN';
                        }
                    } else if (Number.POSITIVE_INFINITY === object) {
                        switch (style) {
                            case 'lowercase':
                                return '.inf';

                            case 'uppercase':
                                return '.INF';

                            case 'camelcase':
                                return '.Inf';
                        }
                    } else if (Number.NEGATIVE_INFINITY === object) {
                        switch (style) {
                            case 'lowercase':
                                return '-.inf';

                            case 'uppercase':
                                return '-.INF';

                            case 'camelcase':
                                return '-.Inf';
                        }
                    } else if (common.isNegativeZero(object)) {
                        return '-0.0';
                    }

                    return object.toString(10);
                }

                function isFloat(object) {
                    return '[object Number]' === Object.prototype.toString.call(object) &&
                        (0 !== object % 1 || common.isNegativeZero(object));
                }

                module.exports = new Type('tag:yaml.org,2002:float', {
                    kind: 'scalar',
                    resolve: resolveYamlFloat,
                    construct: constructYamlFloat,
                    predicate: isFloat,
                    represent: representYamlFloat,
                    defaultStyle: 'lowercase'
                });

            },{
                '../common': 23,'../type': 34
            }],38: [function (require, module, exports) {
                'use strict';

                var common = require('../common');
                var Type   = require('../type');

                function isHexCode(c) {
                    return 0x30/* 0 */ <= c && c <= 0x39/* 9 */ ||
                        0x41/* A */ <= c && c <= 0x46/* F */ ||
                        0x61/* a */ <= c && c <= 0x66/* f */;
                }

                function isOctCode(c) {
                    return 0x30/* 0 */ <= c && c <= 0x37/* 7 */;
                }

                function isDecCode(c) {
                    return 0x30/* 0 */ <= c && c <= 0x39/* 9 */;
                }

                function resolveYamlInteger(data) {
                    if (null === data) {
                        return false;
                    }

                    var max = data.length,
                        index = 0,
                        hasDigits = false,
                        ch;

                    if (!max) {
                        return false;
                    }

                    ch = data[index];

                    // sign
                    if (ch === '-' || ch === '+') {
                        ch = data[++index];
                    }

                    if (ch === '0') {
                        // 0
                        if (index + 1 === max) {
                            return true;
                        }
                        ch = data[++index];

                        // base 2, base 8, base 16

                        if (ch === 'b') {
                            // base 2
                            index++;

                            for (; index < max; index++) {
                                ch = data[index];

                                if (ch === '_') {
                                    continue;
                                }

                                if (ch !== '0' && ch !== '1') {
                                    return false;
                                }
                                hasDigits = true;
                            }

                            return hasDigits;
                        }

                        if (ch === 'x') {
                            // base 16
                            index++;

                            for (; index < max; index++) {
                                ch = data[index];

                                if (ch === '_') {
                                    continue;
                                }

                                if (!isHexCode(data.charCodeAt(index))) {
                                    return false;
                                }
                                hasDigits = true;
                            }

                            return hasDigits;
                        }

                        // base 8
                        for (; index < max; index++) {
                            ch = data[index];

                            if (ch === '_') {
                                continue;
                            }

                            if (!isOctCode(data.charCodeAt(index))) {
                                return false;
                            }
                            hasDigits = true;
                        }

                        return hasDigits;
                    }

                    // base 10 (except 0) or base 60

                    for (; index < max; index++) {
                        ch = data[index];

                        if (ch === '_') {
                            continue;
                        }

                        if (ch === ':') {
                            break;
                        }

                        if (!isDecCode(data.charCodeAt(index))) {
                            return false;
                        }
                        hasDigits = true;
                    }

                    if (!hasDigits) {
                        return false;
                    }

                    // if !base60 - done;
                    if (ch !== ':') {
                        return true;
                    }

                    // base60 almost not used, no needs to optimize
                    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
                }

                function constructYamlInteger(data) {
                    var value = data,
 sign = 1,
 ch, base, digits = [];

                    if (value.indexOf('_') !== -1) {
                        value = value.replace(/_/g, '');
                    }

                    ch = value[0];

                    if (ch === '-' || ch === '+') {
                        if (ch === '-') {
                            sign = -1;
                        }
                        value = value.slice(1);
                        ch = value[0];
                    }

                    if ('0' === value) {
                        return 0;
                    }

                    if (ch === '0') {
                        if (value[1] === 'b') {
                            return sign * parseInt(value.slice(2), 2);
                        }

                        if (value[1] === 'x') {
                            return sign * parseInt(value, 16);
                        }

                        return sign * parseInt(value, 8);

                    }

                    if (value.indexOf(':') !== -1) {
                        value.split(':').forEach(function (v) {
                            digits.unshift(parseInt(v, 10));
                        });

                        value = 0;
                        base = 1;

                        digits.forEach(function (d) {
                            value += d * base;
                            base *= 60;
                        });

                        return sign * value;

                    }

                    return sign * parseInt(value, 10);
                }

                function isInteger(object) {
                    return '[object Number]' === Object.prototype.toString.call(object) &&
                        (0 === object % 1 && !common.isNegativeZero(object));
                }

                module.exports = new Type('tag:yaml.org,2002:int', {
                    kind: 'scalar',
                    resolve: resolveYamlInteger,
                    construct: constructYamlInteger,
                    predicate: isInteger,
                    represent: {
                        binary:      function (object) {
                            return '0b' + object.toString(2);
                        },
                        octal:       function (object) {
                            return '0'  + object.toString(8);
                        },
                        decimal:     function (object) {
                            return object.toString(10);
                        },
                        hexadecimal: function (object) {
                            return '0x' + object.toString(16).toUpperCase();
                        }
                    },
                    defaultStyle: 'decimal',
                    styleAliases: {
                        binary:      [2,  'bin'],
                        octal:       [8,  'oct'],
                        decimal:     [10, 'dec'],
                        hexadecimal: [16, 'hex']
                    }
                });

            },{
                '../common': 23,'../type': 34
            }],39: [function (require, module, exports) {
                'use strict';

                var esprima;

                // Browserified version does not have esprima
                //
                // 1. For node.js just require module as deps
                // 2. For browser try to require mudule via external AMD system.
                //    If not found - try to fallback to window.esprima. If not
                //    found too - then fail to parse.
                //
                try {
                    esprima = require('esprima');
                } catch (_) {
                    /*global window */
                    if (typeof window !== 'undefined') {
                        esprima = window.esprima;
                    }
                }

                var Type = require('../../type');

                function resolveJavascriptFunction(data) {
                    if (null === data) {
                        return false;
                    }

                    try {
                        var source = '(' + data + ')',
                            ast    = esprima.parse(source, {
                            range: true
                        }),
                            params = [],
                            body;

                        if ('Program'             !== ast.type         ||
                            1                     !== ast.body.length  ||
                            'ExpressionStatement' !== ast.body[0].type ||
                            'FunctionExpression'  !== ast.body[0].expression.type) {
                            return false;
                        }

                        return true;
                    } catch (err) {
                        return false;
                    }
                }

                function constructJavascriptFunction(data) {
                    /*jslint evil:true*/

                    var source = '(' + data + ')',
                        ast    = esprima.parse(source, {
                        range: true
                    }),
                        params = [],
                        body;

                    if ('Program'             !== ast.type         ||
                        1                     !== ast.body.length  ||
                        'ExpressionStatement' !== ast.body[0].type ||
                        'FunctionExpression'  !== ast.body[0].expression.type) {
                        throw new Error('Failed to resolve function');
                    }

                    ast.body[0].expression.params.forEach(function (param) {
                        params.push(param.name);
                    });

                    body = ast.body[0].expression.body.range;

                    // Esprima's ranges include the first '{' and the last '}' characters on
                    // function expressions. So cut them out.
                    /*eslint-disable no-new-func*/
                    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
                }

                function representJavascriptFunction(object /*, style*/) {
                    return object.toString();
                }

                function isFunction(object) {
                    return '[object Function]' === Object.prototype.toString.call(object);
                }

                module.exports = new Type('tag:yaml.org,2002:js/function', {
                    kind: 'scalar',
                    resolve: resolveJavascriptFunction,
                    construct: constructJavascriptFunction,
                    predicate: isFunction,
                    represent: representJavascriptFunction
                });

            },{
                '../../type': 34,'esprima': 51
            }],40: [function (require, module, exports) {
                'use strict';

                var Type = require('../../type');

                function resolveJavascriptRegExp(data) {
                    if (null === data) {
                        return false;
                    }

                    if (0 === data.length) {
                        return false;
                    }

                    var regexp = data,
                        tail   = /\/([gim]*)$/.exec(data),
                        modifiers = '';

                    // if regexp starts with '/' it can have modifiers and must be properly closed
                    // `/foo/gim` - modifiers tail can be maximum 3 chars
                    if ('/' === regexp[0]) {
                        if (tail) {
                            modifiers = tail[1];
                        }

                        if (modifiers.length > 3) {
                            return false;
                        }
                        // if expression starts with /, is should be properly terminated
                        if (regexp[regexp.length - modifiers.length - 1] !== '/') {
                            return false;
                        }

                        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
                    }

                    try {
                        var dummy = new RegExp(regexp, modifiers);

                        return true;
                    } catch (error) {
                        return false;
                    }
                }

                function constructJavascriptRegExp(data) {
                    var regexp = data,
                        tail   = /\/([gim]*)$/.exec(data),
                        modifiers = '';

                    // `/foo/gim` - tail can be maximum 4 chars
                    if ('/' === regexp[0]) {
                        if (tail) {
                            modifiers = tail[1];
                        }
                        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
                    }

                    return new RegExp(regexp, modifiers);
                }

                function representJavascriptRegExp(object /*, style*/) {
                    var result = '/' + object.source + '/';

                    if (object.global) {
                        result += 'g';
                    }

                    if (object.multiline) {
                        result += 'm';
                    }

                    if (object.ignoreCase) {
                        result += 'i';
                    }

                    return result;
                }

                function isRegExp(object) {
                    return '[object RegExp]' === Object.prototype.toString.call(object);
                }

                module.exports = new Type('tag:yaml.org,2002:js/regexp', {
                    kind: 'scalar',
                    resolve: resolveJavascriptRegExp,
                    construct: constructJavascriptRegExp,
                    predicate: isRegExp,
                    represent: representJavascriptRegExp
                });

            },{
                '../../type': 34
            }],41: [function (require, module, exports) {
                'use strict';

                var Type = require('../../type');

                function resolveJavascriptUndefined() {
                    return true;
                }

                function constructJavascriptUndefined() {
                    /*eslint-disable no-undefined*/
                    return undefined;
                }

                function representJavascriptUndefined() {
                    return '';
                }

                function isUndefined(object) {
                    return 'undefined' === typeof object;
                }

                module.exports = new Type('tag:yaml.org,2002:js/undefined', {
                    kind: 'scalar',
                    resolve: resolveJavascriptUndefined,
                    construct: constructJavascriptUndefined,
                    predicate: isUndefined,
                    represent: representJavascriptUndefined
                });

            },{
                '../../type': 34
            }],42: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                module.exports = new Type('tag:yaml.org,2002:map', {
                    kind: 'mapping',
                    construct: function (data) {
                        return null !== data ? data : {};
                    }
                });

            },{
                '../type': 34
            }],43: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                function resolveYamlMerge(data) {
                    return '<<' === data || null === data;
                }

                module.exports = new Type('tag:yaml.org,2002:merge', {
                    kind: 'scalar',
                    resolve: resolveYamlMerge
                });

            },{
                '../type': 34
            }],44: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                function resolveYamlNull(data) {
                    if (null === data) {
                        return true;
                    }

                    var max = data.length;

                    return max === 1 && data === '~' ||
                        max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
                }

                function constructYamlNull() {
                    return null;
                }

                function isNull(object) {
                    return null === object;
                }

                module.exports = new Type('tag:yaml.org,2002:null', {
                    kind: 'scalar',
                    resolve: resolveYamlNull,
                    construct: constructYamlNull,
                    predicate: isNull,
                    represent: {
                        canonical: function () {
                            return '~';
                        },
                        lowercase: function () {
                            return 'null';
                        },
                        uppercase: function () {
                            return 'NULL';
                        },
                        camelcase: function () {
                            return 'Null';
                        }
                    },
                    defaultStyle: 'lowercase'
                });

            },{
                '../type': 34
            }],45: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                var _hasOwnProperty = Object.prototype.hasOwnProperty;
                var _toString       = Object.prototype.toString;

                function resolveYamlOmap(data) {
                    if (null === data) {
                        return true;
                    }

                    var objectKeys = [],
 index, length, pair, pairKey, pairHasKey,
                        object = data;

                    for (index = 0, length = object.length; index < length; index += 1) {
                        pair = object[index];
                        pairHasKey = false;

                        if ('[object Object]' !== _toString.call(pair)) {
                            return false;
                        }

                        for (pairKey in pair) {
                            if (_hasOwnProperty.call(pair, pairKey)) {
                                if (!pairHasKey) {
                                    pairHasKey = true;
                                } else {
                                    return false;
                                }
                            }
                        }

                        if (!pairHasKey) {
                            return false;
                        }

                        if (-1 === objectKeys.indexOf(pairKey)) {
                            objectKeys.push(pairKey);
                        } else {
                            return false;
                        }
                    }

                    return true;
                }

                function constructYamlOmap(data) {
                    return null !== data ? data : [];
                }

                module.exports = new Type('tag:yaml.org,2002:omap', {
                    kind: 'sequence',
                    resolve: resolveYamlOmap,
                    construct: constructYamlOmap
                });

            },{
                '../type': 34
            }],46: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                var _toString = Object.prototype.toString;

                function resolveYamlPairs(data) {
                    if (null === data) {
                        return true;
                    }

                    var index, length, pair, keys, result,
                        object = data;

                    result = new Array(object.length);

                    for (index = 0, length = object.length; index < length; index += 1) {
                        pair = object[index];

                        if ('[object Object]' !== _toString.call(pair)) {
                            return false;
                        }

                        keys = Object.keys(pair);

                        if (1 !== keys.length) {
                            return false;
                        }

                        result[index] = [keys[0], pair[keys[0]]];
                    }

                    return true;
                }

                function constructYamlPairs(data) {
                    if (null === data) {
                        return [];
                    }

                    var index, length, pair, keys, result,
                        object = data;

                    result = new Array(object.length);

                    for (index = 0, length = object.length; index < length; index += 1) {
                        pair = object[index];

                        keys = Object.keys(pair);

                        result[index] = [keys[0], pair[keys[0]]];
                    }

                    return result;
                }

                module.exports = new Type('tag:yaml.org,2002:pairs', {
                    kind: 'sequence',
                    resolve: resolveYamlPairs,
                    construct: constructYamlPairs
                });

            },{
                '../type': 34
            }],47: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                module.exports = new Type('tag:yaml.org,2002:seq', {
                    kind: 'sequence',
                    construct: function (data) {
                        return null !== data ? data : [];
                    }
                });

            },{
                '../type': 34
            }],48: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                var _hasOwnProperty = Object.prototype.hasOwnProperty;

                function resolveYamlSet(data) {
                    if (null === data) {
                        return true;
                    }

                    var key, object = data;

                    for (key in object) {
                        if (_hasOwnProperty.call(object, key)) {
                            if (null !== object[key]) {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                function constructYamlSet(data) {
                    return null !== data ? data : {};
                }

                module.exports = new Type('tag:yaml.org,2002:set', {
                    kind: 'mapping',
                    resolve: resolveYamlSet,
                    construct: constructYamlSet
                });

            },{
                '../type': 34
            }],49: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                module.exports = new Type('tag:yaml.org,2002:str', {
                    kind: 'scalar',
                    construct: function (data) {
                        return null !== data ? data : '';
                    }
                });

            },{
                '../type': 34
            }],50: [function (require, module, exports) {
                'use strict';

                var Type = require('../type');

                var YAML_TIMESTAMP_REGEXP = new RegExp(
                    '^([0-9][0-9][0-9][0-9])'          + // [1] year
                    '-([0-9][0-9]?)'                   + // [2] month
                    '-([0-9][0-9]?)'                   + // [3] day
                    '(?:(?:[Tt]|[ \\t]+)'              + // ...
                    '([0-9][0-9]?)'                    + // [4] hour
                    ':([0-9][0-9])'                    + // [5] minute
                    ':([0-9][0-9])'                    + // [6] second
                    '(?:\\.([0-9]*))?'                 + // [7] fraction
                    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
                    '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

                function resolveYamlTimestamp(data) {
                    if (null === data) {
                        return false;
                    }

                    var match, year, month, day, hour, minute, second, fraction = 0,
                        delta = null,
 tz_hour, tz_minute, date;

                    match = YAML_TIMESTAMP_REGEXP.exec(data);

                    if (null === match) {
                        return false;
                    }

                    return true;
                }

                function constructYamlTimestamp(data) {
                    var match, year, month, day, hour, minute, second, fraction = 0,
                        delta = null,
 tz_hour, tz_minute, date;

                    match = YAML_TIMESTAMP_REGEXP.exec(data);

                    if (null === match) {
                        throw new Error('Date resolve error');
                    }

                    // match: [1] year [2] month [3] day

                    year = +match[1];
                    month = +match[2] - 1; // JS month starts with 0
                    day = +match[3];

                    if (!match[4]) { // no hour
                        return new Date(Date.UTC(year, month, day));
                    }

                    // match: [4] hour [5] minute [6] second [7] fraction

                    hour = +match[4];
                    minute = +match[5];
                    second = +match[6];

                    if (match[7]) {
                        fraction = match[7].slice(0, 3);

                        while (fraction.length < 3) { // milli-seconds
                            fraction += '0';
                        }
                        fraction = +fraction;
                    }

                    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

                    if (match[9]) {
                        tz_hour = +match[10];
                        tz_minute = +(match[11] || 0);
                        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
                        if ('-' === match[9]) {
                            delta = -delta;
                        }
                    }

                    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

                    if (delta) {
                        date.setTime(date.getTime() - delta);
                    }

                    return date;
                }

                function representYamlTimestamp(object /*, style*/) {
                    return object.toISOString();
                }

                module.exports = new Type('tag:yaml.org,2002:timestamp', {
                    kind: 'scalar',
                    resolve: resolveYamlTimestamp,
                    construct: constructYamlTimestamp,
                    instanceOf: Date,
                    represent: representYamlTimestamp
                });

            },{
                '../type': 34
            }],51: [function (require, module, exports) {
                /*
                 Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
                 Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
                 Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
                 Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
                 Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
                 Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
                 Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
                 Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
                 Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
                 Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

                 Redistribution and use in source and binary forms, with or without
                 modification, are permitted provided that the following conditions are met:

                 * Redistributions of source code must retain the above copyright
                 notice, this list of conditions and the following disclaimer.
                 * Redistributions in binary form must reproduce the above copyright
                 notice, this list of conditions and the following disclaimer in the
                 documentation and/or other materials provided with the distribution.

                 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                 ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                 */

                (function (root, factory) {
                    'use strict';

                    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
                    // Rhino, and plain browser loading.

                    /* istanbul ignore next */
                    if (typeof define === 'function' && define.amd) {
                        define(['exports'], factory);
                    } else if (typeof exports !== 'undefined') {
                        factory(exports);
                    } else {
                        factory(root.esprima = {});
                    }
                }(this, function (exports) {
                    'use strict';

                    var Token,
                        TokenName,
                        FnExprTokens,
                        Syntax,
                        PlaceHolders,
                        Messages,
                        Regex,
                        source,
                        strict,
                        sourceType,
                        index,
                        lineNumber,
                        lineStart,
                        hasLineTerminator,
                        lastIndex,
                        lastLineNumber,
                        lastLineStart,
                        startIndex,
                        startLineNumber,
                        startLineStart,
                        scanning,
                        length,
                        lookahead,
                        state,
                        extra,
                        isBindingElement,
                        isAssignmentTarget,
                        firstCoverInitializedNameError;

                    Token = {
                        BooleanLiteral: 1,
                        EOF: 2,
                        Identifier: 3,
                        Keyword: 4,
                        NullLiteral: 5,
                        NumericLiteral: 6,
                        Punctuator: 7,
                        StringLiteral: 8,
                        RegularExpression: 9,
                        Template: 10
                    };

                    TokenName = {};
                    TokenName[Token.BooleanLiteral] = 'Boolean';
                    TokenName[Token.EOF] = '<end>';
                    TokenName[Token.Identifier] = 'Identifier';
                    TokenName[Token.Keyword] = 'Keyword';
                    TokenName[Token.NullLiteral] = 'Null';
                    TokenName[Token.NumericLiteral] = 'Numeric';
                    TokenName[Token.Punctuator] = 'Punctuator';
                    TokenName[Token.StringLiteral] = 'String';
                    TokenName[Token.RegularExpression] = 'RegularExpression';
                    TokenName[Token.Template] = 'Template';

                    // A function following one of those tokens is an expression.
                    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                        'return', 'case', 'delete', 'throw', 'void',
                        // assignment operators
                        '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                        '&=', '|=', '^=', ',',
                        // binary/unary operators
                        '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                        '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                        '<=', '<', '>', '!=', '!=='];

                    Syntax = {
                        AssignmentExpression: 'AssignmentExpression',
                        AssignmentPattern: 'AssignmentPattern',
                        ArrayExpression: 'ArrayExpression',
                        ArrayPattern: 'ArrayPattern',
                        ArrowFunctionExpression: 'ArrowFunctionExpression',
                        BlockStatement: 'BlockStatement',
                        BinaryExpression: 'BinaryExpression',
                        BreakStatement: 'BreakStatement',
                        CallExpression: 'CallExpression',
                        CatchClause: 'CatchClause',
                        ClassBody: 'ClassBody',
                        ClassDeclaration: 'ClassDeclaration',
                        ClassExpression: 'ClassExpression',
                        ConditionalExpression: 'ConditionalExpression',
                        ContinueStatement: 'ContinueStatement',
                        DoWhileStatement: 'DoWhileStatement',
                        DebuggerStatement: 'DebuggerStatement',
                        EmptyStatement: 'EmptyStatement',
                        ExportAllDeclaration: 'ExportAllDeclaration',
                        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
                        ExportNamedDeclaration: 'ExportNamedDeclaration',
                        ExportSpecifier: 'ExportSpecifier',
                        ExpressionStatement: 'ExpressionStatement',
                        ForStatement: 'ForStatement',
                        ForInStatement: 'ForInStatement',
                        FunctionDeclaration: 'FunctionDeclaration',
                        FunctionExpression: 'FunctionExpression',
                        Identifier: 'Identifier',
                        IfStatement: 'IfStatement',
                        ImportDeclaration: 'ImportDeclaration',
                        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
                        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
                        ImportSpecifier: 'ImportSpecifier',
                        Literal: 'Literal',
                        LabeledStatement: 'LabeledStatement',
                        LogicalExpression: 'LogicalExpression',
                        MemberExpression: 'MemberExpression',
                        MethodDefinition: 'MethodDefinition',
                        NewExpression: 'NewExpression',
                        ObjectExpression: 'ObjectExpression',
                        ObjectPattern: 'ObjectPattern',
                        Program: 'Program',
                        Property: 'Property',
                        RestElement: 'RestElement',
                        ReturnStatement: 'ReturnStatement',
                        SequenceExpression: 'SequenceExpression',
                        SpreadElement: 'SpreadElement',
                        Super: 'Super',
                        SwitchCase: 'SwitchCase',
                        SwitchStatement: 'SwitchStatement',
                        TaggedTemplateExpression: 'TaggedTemplateExpression',
                        TemplateElement: 'TemplateElement',
                        TemplateLiteral: 'TemplateLiteral',
                        ThisExpression: 'ThisExpression',
                        ThrowStatement: 'ThrowStatement',
                        TryStatement: 'TryStatement',
                        UnaryExpression: 'UnaryExpression',
                        UpdateExpression: 'UpdateExpression',
                        VariableDeclaration: 'VariableDeclaration',
                        VariableDeclarator: 'VariableDeclarator',
                        WhileStatement: 'WhileStatement',
                        WithStatement: 'WithStatement'
                    };

                    PlaceHolders = {
                        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
                    };

                    // Error messages should be identical to V8.
                    Messages = {
                        UnexpectedToken: 'Unexpected token %0',
                        UnexpectedNumber: 'Unexpected number',
                        UnexpectedString: 'Unexpected string',
                        UnexpectedIdentifier: 'Unexpected identifier',
                        UnexpectedReserved: 'Unexpected reserved word',
                        UnexpectedTemplate: 'Unexpected quasi %0',
                        UnexpectedEOS: 'Unexpected end of input',
                        NewlineAfterThrow: 'Illegal newline after throw',
                        InvalidRegExp: 'Invalid regular expression',
                        UnterminatedRegExp: 'Invalid regular expression: missing /',
                        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
                        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
                        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
                        NoCatchOrFinally: 'Missing catch or finally after try',
                        UnknownLabel: 'Undefined label \'%0\'',
                        Redeclaration: '%0 \'%1\' has already been declared',
                        IllegalContinue: 'Illegal continue statement',
                        IllegalBreak: 'Illegal break statement',
                        IllegalReturn: 'Illegal return statement',
                        StrictModeWith: 'Strict mode code may not include a with statement',
                        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
                        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
                        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
                        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
                        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
                        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
                        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
                        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
                        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
                        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
                        StrictReservedWord: 'Use of future reserved word in strict mode',
                        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
                        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
                        DefaultRestParameter: 'Unexpected token =',
                        ObjectPatternAsRestParameter: 'Unexpected token {',
                        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
                        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
                        DuplicateConstructor: 'A class may only have one constructor',
                        StaticPrototype: 'Classes may not have static property named prototype',
                        MissingFromClause: 'Unexpected token',
                        NoAsAfterImportNamespace: 'Unexpected token',
                        InvalidModuleSpecifier: 'Unexpected token',
                        IllegalImportDeclaration: 'Unexpected token',
                        IllegalExportDeclaration: 'Unexpected token'
                    };

                    // See also tools/generate-unicode-regex.py.
                    Regex = {
                        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
                        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
                    };

                    // Ensure the condition is true, otherwise throw an error.
                    // This is only to have a better contract semantic, i.e. another safety net
                    // to catch a logic error. The condition shall be fulfilled in normal case.
                    // Do NOT use this to enforce a certain condition on any user input.

                    function assert(condition, message) {
                        /* istanbul ignore if */
                        if (!condition) {
                            throw new Error('ASSERT: ' + message);
                        }
                    }

                    function isDecimalDigit(ch) {
                        return ch >= 0x30 && ch <= 0x39;   // 0..9
                    }

                    function isHexDigit(ch) {
                        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
                    }

                    function isOctalDigit(ch) {
                        return '01234567'.indexOf(ch) >= 0;
                    }

                    function octalToDecimal(ch) {
                        // \0 is not octal escape sequence
                        var octal = ch !== '0',
 code = '01234567'.indexOf(ch);

                        if (index < length && isOctalDigit(source[index])) {
                            octal = true;
                            code = code * 8 + '01234567'.indexOf(source[index++]);

                            // 3 digits are only allowed when string starts
                            // with 0, 1, 2, 3
                            if ('0123'.indexOf(ch) >= 0 &&
                                index < length &&
                                isOctalDigit(source[index])) {
                                code = code * 8 + '01234567'.indexOf(source[index++]);
                            }
                        }

                        return {
                            code: code,
                            octal: octal
                        };
                    }

                    // 7.2 White Space

                    function isWhiteSpace(ch) {
                        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
                            ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;
                    }

                    // 7.3 Line Terminators

                    function isLineTerminator(ch) {
                        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
                    }

                    // 7.6 Identifier Names and Identifiers

                    function isIdentifierStart(ch) {
                        return ch === 0x24 || ch === 0x5F ||  // $ (dollar) and _ (underscore)
                            ch >= 0x41 && ch <= 0x5A ||         // A..Z
                            ch >= 0x61 && ch <= 0x7A ||         // a..z
                            ch === 0x5C ||                      // \ (backslash)
                            ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
                    }

                    function isIdentifierPart(ch) {
                        return ch === 0x24 || ch === 0x5F ||  // $ (dollar) and _ (underscore)
                            ch >= 0x41 && ch <= 0x5A ||         // A..Z
                            ch >= 0x61 && ch <= 0x7A ||         // a..z
                            ch >= 0x30 && ch <= 0x39 ||         // 0..9
                            ch === 0x5C ||                      // \ (backslash)
                            ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
                    }

                    // 7.6.1.2 Future Reserved Words

                    function isFutureReservedWord(id) {
                        switch (id) {
                            case 'enum':
                            case 'export':
                            case 'import':
                            case 'super':
                                return true;
                            default:
                                return false;
                        }
                    }

                    // 11.6.2.2 Future Reserved Words

                    function isStrictModeReservedWord(id) {
                        switch (id) {
                            case 'implements':
                            case 'interface':
                            case 'package':
                            case 'private':
                            case 'protected':
                            case 'public':
                            case 'static':
                            case 'yield':
                            case 'let':
                                return true;
                            default:
                                return false;
                        }
                    }

                    function isRestrictedWord(id) {
                        return id === 'eval' || id === 'arguments';
                    }

                    // 7.6.1.1 Keywords

                    function isKeyword(id) {

                        // 'const' is specialized as Keyword in V8.
                        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.
                        // Some others are from future reserved words.

                        switch (id.length) {
                            case 2:
                                return id === 'if' || id === 'in' || id === 'do';

                            case 3:
                                return id === 'var' || id === 'for' || id === 'new' ||
                                    id === 'try' || id === 'let';

                            case 4:
                                return id === 'this' || id === 'else' || id === 'case' ||
                                    id === 'void' || id === 'with' || id === 'enum';

                            case 5:
                                return id === 'while' || id === 'break' || id === 'catch' ||
                                    id === 'throw' || id === 'const' || id === 'yield' ||
                                    id === 'class' || id === 'super';

                            case 6:
                                return id === 'return' || id === 'typeof' || id === 'delete' ||
                                    id === 'switch' || id === 'export' || id === 'import';

                            case 7:
                                return id === 'default' || id === 'finally' || id === 'extends';

                            case 8:
                                return id === 'function' || id === 'continue' || id === 'debugger';

                            case 10:
                                return id === 'instanceof';
                            default:
                                return false;
                        }
                    }

                    // 7.4 Comments

                    function addComment(type, value, start, end, loc) {
                        var comment;

                        assert(typeof start === 'number', 'Comment must have valid position');

                        state.lastCommentStart = start;

                        comment = {
                            type: type,
                            value: value
                        };

                        if (extra.range) {
                            comment.range = [start, end];
                        }

                        if (extra.loc) {
                            comment.loc = loc;
                        }
                        extra.comments.push(comment);

                        if (extra.attachComment) {
                            extra.leadingComments.push(comment);
                            extra.trailingComments.push(comment);
                        }
                    }

                    function skipSingleLineComment(offset) {
                        var start, loc, ch, comment;

                        start = index - offset;
                        loc = {
                            start: {
                                line: lineNumber,
                                column: index - lineStart - offset
                            }
                        };

                        while (index < length) {
                            ch = source.charCodeAt(index);
                            ++index;

                            if (isLineTerminator(ch)) {
                                hasLineTerminator = true;

                                if (extra.comments) {
                                    comment = source.slice(start + offset, index - 1);
                                    loc.end = {
                                        line: lineNumber,
                                        column: index - lineStart - 1
                                    };
                                    addComment('Line', comment, start, index - 1, loc);
                                }

                                if (ch === 13 && source.charCodeAt(index) === 10) {
                                    ++index;
                                }
                                ++lineNumber;
                                lineStart = index;

                                return;
                            }
                        }

                        if (extra.comments) {
                            comment = source.slice(start + offset, index);
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Line', comment, start, index, loc);
                        }
                    }

                    function skipMultiLineComment() {
                        var start, loc, ch, comment;

                        if (extra.comments) {
                            start = index - 2;
                            loc = {
                                start: {
                                    line: lineNumber,
                                    column: index - lineStart - 2
                                }
                            };
                        }

                        while (index < length) {
                            ch = source.charCodeAt(index);

                            if (isLineTerminator(ch)) {
                                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                                    ++index;
                                }
                                hasLineTerminator = true;
                                ++lineNumber;
                                ++index;
                                lineStart = index;
                            } else if (ch === 0x2A) {
                                // Block comment ends with '*/'.
                                if (source.charCodeAt(index + 1) === 0x2F) {
                                    ++index;
                                    ++index;

                                    if (extra.comments) {
                                        comment = source.slice(start + 2, index - 2);
                                        loc.end = {
                                            line: lineNumber,
                                            column: index - lineStart
                                        };
                                        addComment('Block', comment, start, index, loc);
                                    }

                                    return;
                                }
                                ++index;
                            } else {
                                ++index;
                            }
                        }

                        // Ran off the end of the file - the whole thing is a comment
                        if (extra.comments) {
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            comment = source.slice(start + 2, index);
                            addComment('Block', comment, start, index, loc);
                        }
                        tolerateUnexpectedToken();
                    }

                    function skipComment() {
                        var ch, start;

                        hasLineTerminator = false;

                        start = index === 0;

                        while (index < length) {
                            ch = source.charCodeAt(index);

                            if (isWhiteSpace(ch)) {
                                ++index;
                            } else if (isLineTerminator(ch)) {
                                hasLineTerminator = true;
                                ++index;

                                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                                    ++index;
                                }
                                ++lineNumber;
                                lineStart = index;
                                start = true;
                            } else if (ch === 0x2F) { // U+002F is '/'
                                ch = source.charCodeAt(index + 1);

                                if (ch === 0x2F) {
                                    ++index;
                                    ++index;
                                    skipSingleLineComment(2);
                                    start = true;
                                } else if (ch === 0x2A) {  // U+002A is '*'
                                    ++index;
                                    ++index;
                                    skipMultiLineComment();
                                } else {
                                    break;
                                }
                            } else if (start && ch === 0x2D) { // U+002D is '-'
                                // U+003E is '>'
                                if (source.charCodeAt(index + 1) === 0x2D && source.charCodeAt(index + 2) === 0x3E) {
                                    // '-->' is a single-line comment
                                    index += 3;
                                    skipSingleLineComment(3);
                                } else {
                                    break;
                                }
                            } else if (ch === 0x3C) { // U+003C is '<'
                                if (source.slice(index + 1, index + 4) === '!--') {
                                    ++index; // `<`
                                    ++index; // `!`
                                    ++index; // `-`
                                    ++index; // `-`
                                    skipSingleLineComment(4);
                                } else {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }
                    }

                    function scanHexEscape(prefix) {
                        var i, len, ch, code = 0;

                        len = prefix === 'u' ? 4 : 2;

                        for (i = 0; i < len; ++i) {
                            if (index < length && isHexDigit(source[index])) {
                                ch = source[index++];
                                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
                            } else {
                                return '';
                            }
                        }

                        return String.fromCharCode(code);
                    }

                    function scanUnicodeCodePointEscape() {
                        var ch, code, cu1, cu2;

                        ch = source[index];
                        code = 0;

                        // At least, one hex digit is required.
                        if (ch === '}') {
                            throwUnexpectedToken();
                        }

                        while (index < length) {
                            ch = source[index++];

                            if (!isHexDigit(ch)) {
                                break;
                            }
                            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
                        }

                        if (code > 0x10FFFF || ch !== '}') {
                            throwUnexpectedToken();
                        }

                        // UTF-16 Encoding
                        if (code <= 0xFFFF) {
                            return String.fromCharCode(code);
                        }
                        cu1 = (code - 0x10000 >> 10) + 0xD800;
                        cu2 = (code - 0x10000 & 1023) + 0xDC00;

                        return String.fromCharCode(cu1, cu2);
                    }

                    function getEscapedIdentifier() {
                        var ch, id;

                        ch = source.charCodeAt(index++);
                        id = String.fromCharCode(ch);

                        // '\u' (U+005C, U+0075) denotes an escaped character.
                        if (ch === 0x5C) {
                            if (source.charCodeAt(index) !== 0x75) {
                                throwUnexpectedToken();
                            }
                            ++index;
                            ch = scanHexEscape('u');

                            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                                throwUnexpectedToken();
                            }
                            id = ch;
                        }

                        while (index < length) {
                            ch = source.charCodeAt(index);

                            if (!isIdentifierPart(ch)) {
                                break;
                            }
                            ++index;
                            id += String.fromCharCode(ch);

                            // '\u' (U+005C, U+0075) denotes an escaped character.
                            if (ch === 0x5C) {
                                id = id.substr(0, id.length - 1);

                                if (source.charCodeAt(index) !== 0x75) {
                                    throwUnexpectedToken();
                                }
                                ++index;
                                ch = scanHexEscape('u');

                                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                                    throwUnexpectedToken();
                                }
                                id += ch;
                            }
                        }

                        return id;
                    }

                    function getIdentifier() {
                        var start, ch;

                        start = index++;

                        while (index < length) {
                            ch = source.charCodeAt(index);

                            if (ch === 0x5C) {
                                // Blackslash (U+005C) marks Unicode escape sequence.
                                index = start;

                                return getEscapedIdentifier();
                            }

                            if (isIdentifierPart(ch)) {
                                ++index;
                            } else {
                                break;
                            }
                        }

                        return source.slice(start, index);
                    }

                    function scanIdentifier() {
                        var start, id, type;

                        start = index;

                        // Backslash (U+005C) starts an escaped character.
                        id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier();

                        // There is no keyword or literal with only one character.
                        // Thus, it must be an identifier.
                        if (id.length === 1) {
                            type = Token.Identifier;
                        } else if (isKeyword(id)) {
                            type = Token.Keyword;
                        } else if (id === 'null') {
                            type = Token.NullLiteral;
                        } else if (id === 'true' || id === 'false') {
                            type = Token.BooleanLiteral;
                        } else {
                            type = Token.Identifier;
                        }

                        return {
                            type: type,
                            value: id,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }


                    // 7.7 Punctuators

                    function scanPunctuator() {
                        var token, str;

                        token = {
                            type: Token.Punctuator,
                            value: '',
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: index,
                            end: index
                        };

                        // Check for most common single-character punctuators.
                        str = source[index];

                        switch (str) {

                            case '(':
                                if (extra.tokenize) {
                                    extra.openParenToken = extra.tokens.length;
                                }
                                ++index;
                                break;

                            case '{':
                                if (extra.tokenize) {
                                    extra.openCurlyToken = extra.tokens.length;
                                }
                                state.curlyStack.push('{');
                                ++index;
                                break;

                            case '.':
                                ++index;

                                if (source[index] === '.' && source[index + 1] === '.') {
                                    // Spread operator: ...
                                    index += 2;
                                    str = '...';
                                }
                                break;

                            case '}':
                                ++index;
                                state.curlyStack.pop();
                                break;

                            case ')':
                            case ';':
                            case ',':
                            case '[':
                            case ']':
                            case ':':
                            case '?':
                            case '~':
                                ++index;
                                break;

                            default:
                                // 4-character punctuator.
                                str = source.substr(index, 4);

                                if (str === '>>>=') {
                                    index += 4;
                                } else {

                                    // 3-character punctuators.
                                    str = str.substr(0, 3);

                                    if (str === '===' || str === '!==' || str === '>>>' ||
                                        str === '<<=' || str === '>>=') {
                                        index += 3;
                                    } else {

                                        // 2-character punctuators.
                                        str = str.substr(0, 2);

                                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
                                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                                            str === '<=' || str === '>=' || str === '=>') {
                                            index += 2;
                                        } else {

                                            // 1-character punctuators.
                                            str = source[index];

                                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                                                ++index;
                                            }
                                        }
                                    }
                                }
                        }

                        if (index === token.start) {
                            throwUnexpectedToken();
                        }

                        token.end = index;
                        token.value = str;

                        return token;
                    }

                    // 7.8.3 Numeric Literals

                    function scanHexLiteral(start) {
                        var number = '';

                        while (index < length) {
                            if (!isHexDigit(source[index])) {
                                break;
                            }
                            number += source[index++];
                        }

                        if (number.length === 0) {
                            throwUnexpectedToken();
                        }

                        if (isIdentifierStart(source.charCodeAt(index))) {
                            throwUnexpectedToken();
                        }

                        return {
                            type: Token.NumericLiteral,
                            value: parseInt('0x' + number, 16),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }

                    function scanBinaryLiteral(start) {
                        var ch, number;

                        number = '';

                        while (index < length) {
                            ch = source[index];

                            if (ch !== '0' && ch !== '1') {
                                break;
                            }
                            number += source[index++];
                        }

                        if (number.length === 0) {
                            // only 0b or 0B
                            throwUnexpectedToken();
                        }

                        if (index < length) {
                            ch = source.charCodeAt(index);
                            /* istanbul ignore else */
                            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                                throwUnexpectedToken();
                            }
                        }

                        return {
                            type: Token.NumericLiteral,
                            value: parseInt(number, 2),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }

                    function scanOctalLiteral(prefix, start) {
                        var number, octal;

                        if (isOctalDigit(prefix)) {
                            octal = true;
                            number = '0' + source[index++];
                        } else {
                            octal = false;
                            ++index;
                            number = '';
                        }

                        while (index < length) {
                            if (!isOctalDigit(source[index])) {
                                break;
                            }
                            number += source[index++];
                        }

                        if (!octal && number.length === 0) {
                            // only 0o or 0O
                            throwUnexpectedToken();
                        }

                        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
                            throwUnexpectedToken();
                        }

                        return {
                            type: Token.NumericLiteral,
                            value: parseInt(number, 8),
                            octal: octal,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }

                    function isImplicitOctalLiteral() {
                        var i, ch;

                        // Implicit octal, unless there is a non-octal digit.
                        // (Annex B.1.1 on Numeric Literals)
                        for (i = index + 1; i < length; ++i) {
                            ch = source[i];

                            if (ch === '8' || ch === '9') {
                                return false;
                            }

                            if (!isOctalDigit(ch)) {
                                return true;
                            }
                        }

                        return true;
                    }

                    function scanNumericLiteral() {
                        var number, start, ch;

                        ch = source[index];
                        assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.',
                            'Numeric literal must start with a decimal digit or a decimal point');

                        start = index;
                        number = '';

                        if (ch !== '.') {
                            number = source[index++];
                            ch = source[index];

                            // Hex number starts with '0x'.
                            // Octal number starts with '0'.
                            // Octal number in ES6 starts with '0o'.
                            // Binary number in ES6 starts with '0b'.
                            if (number === '0') {
                                if (ch === 'x' || ch === 'X') {
                                    ++index;

                                    return scanHexLiteral(start);
                                }

                                if (ch === 'b' || ch === 'B') {
                                    ++index;

                                    return scanBinaryLiteral(start);
                                }

                                if (ch === 'o' || ch === 'O') {
                                    return scanOctalLiteral(ch, start);
                                }

                                if (isOctalDigit(ch)) {
                                    if (isImplicitOctalLiteral()) {
                                        return scanOctalLiteral(ch, start);
                                    }
                                }
                            }

                            while (isDecimalDigit(source.charCodeAt(index))) {
                                number += source[index++];
                            }
                            ch = source[index];
                        }

                        if (ch === '.') {
                            number += source[index++];

                            while (isDecimalDigit(source.charCodeAt(index))) {
                                number += source[index++];
                            }
                            ch = source[index];
                        }

                        if (ch === 'e' || ch === 'E') {
                            number += source[index++];

                            ch = source[index];

                            if (ch === '+' || ch === '-') {
                                number += source[index++];
                            }

                            if (isDecimalDigit(source.charCodeAt(index))) {
                                while (isDecimalDigit(source.charCodeAt(index))) {
                                    number += source[index++];
                                }
                            } else {
                                throwUnexpectedToken();
                            }
                        }

                        if (isIdentifierStart(source.charCodeAt(index))) {
                            throwUnexpectedToken();
                        }

                        return {
                            type: Token.NumericLiteral,
                            value: parseFloat(number),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }

                    // 7.8.4 String Literals

                    function scanStringLiteral() {
                        var str = '',
 quote, start, ch, unescaped, octToDec, octal = false;

                        quote = source[index];
                        assert(quote === '\'' || quote === '"',
                            'String literal must starts with a quote');

                        start = index;
                        ++index;

                        while (index < length) {
                            ch = source[index++];

                            if (ch === quote) {
                                quote = '';
                                break;
                            } else if (ch === '\\') {
                                ch = source[index++];

                                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                                    switch (ch) {
                                        case 'u':
                                        case 'x':
                                            if (source[index] === '{') {
                                                ++index;
                                                str += scanUnicodeCodePointEscape();
                                            } else {
                                                unescaped = scanHexEscape(ch);

                                                if (!unescaped) {
                                                    throw throwUnexpectedToken();
                                                }
                                                str += unescaped;
                                            }
                                            break;

                                        case 'n':
                                            str += '\n';
                                            break;

                                        case 'r':
                                            str += '\r';
                                            break;

                                        case 't':
                                            str += '\t';
                                            break;

                                        case 'b':
                                            str += '\b';
                                            break;

                                        case 'f':
                                            str += '\f';
                                            break;

                                        case 'v':
                                            str += '\x0B';
                                            break;

                                        case '8':
                                        case '9':
                                            throw throwUnexpectedToken();

                                        default:
                                            if (isOctalDigit(ch)) {
                                                octToDec = octalToDecimal(ch);

                                                octal = octToDec.octal || octal;
                                                str += String.fromCharCode(octToDec.code);
                                            } else {
                                                str += ch;
                                            }
                                            break;
                                    }
                                } else {
                                    ++lineNumber;

                                    if (ch === '\r' && source[index] === '\n') {
                                        ++index;
                                    }
                                    lineStart = index;
                                }
                            } else if (isLineTerminator(ch.charCodeAt(0))) {
                                break;
                            } else {
                                str += ch;
                            }
                        }

                        if (quote !== '') {
                            throwUnexpectedToken();
                        }

                        return {
                            type: Token.StringLiteral,
                            value: str,
                            octal: octal,
                            lineNumber: startLineNumber,
                            lineStart: startLineStart,
                            start: start,
                            end: index
                        };
                    }

                    function scanTemplate() {
                        var cooked = '',
 ch, start, rawOffset, terminated, head, tail, restore, unescaped;

                        terminated = false;
                        tail = false;
                        start = index;
                        head = source[index] === '`';
                        rawOffset = 2;

                        ++index;

                        while (index < length) {
                            ch = source[index++];

                            if (ch === '`') {
                                rawOffset = 1;
                                tail = true;
                                terminated = true;
                                break;
                            } else if (ch === '$') {
                                if (source[index] === '{') {
                                    state.curlyStack.push('${');
                                    ++index;
                                    terminated = true;
                                    break;
                                }
                                cooked += ch;
                            } else if (ch === '\\') {
                                ch = source[index++];

                                if (!isLineTerminator(ch.charCodeAt(0))) {
                                    switch (ch) {
                                        case 'n':
                                            cooked += '\n';
                                            break;

                                        case 'r':
                                            cooked += '\r';
                                            break;

                                        case 't':
                                            cooked += '\t';
                                            break;

                                        case 'u':
                                        case 'x':
                                            if (source[index] === '{') {
                                                ++index;
                                                cooked += scanUnicodeCodePointEscape();
                                            } else {
                                                restore = index;
                                                unescaped = scanHexEscape(ch);

                                                if (unescaped) {
                                                    cooked += unescaped;
                                                } else {
                                                    index = restore;
                                                    cooked += ch;
                                                }
                                            }
                                            break;

                                        case 'b':
                                            cooked += '\b';
                                            break;

                                        case 'f':
                                            cooked += '\f';
                                            break;

                                        case 'v':
                                            cooked += '\v';
                                            break;

                                        default:
                                            if (ch === '0') {
                                                if (isDecimalDigit(source.charCodeAt(index))) {
                                                    // Illegal: \01 \02 and so on
                                                    throwError(Messages.TemplateOctalLiteral);
                                                }
                                                cooked += '\0';
                                            } else if (isOctalDigit(ch)) {
                                                // Illegal: \1 \2
                                                throwError(Messages.TemplateOctalLiteral);
                                            } else {
                                                cooked += ch;
                                            }
                                            break;
                                    }
                                } else {
                                    ++lineNumber;

                                    if (ch === '\r' && source[index] === '\n') {
                                        ++index;
                                    }
                                    lineStart = index;
                                }
                            } else if (isLineTerminator(ch.charCodeAt(0))) {
                                ++lineNumber;

                                if (ch === '\r' && source[index] === '\n') {
                                    ++index;
                                }
                                lineStart = index;
                                cooked += '\n';
                            } else {
                                cooked += ch;
                            }
                        }

                        if (!terminated) {
                            throwUnexpectedToken();
                        }

                        if (!head) {
                            state.curlyStack.pop();
                        }

                        return {
                            type: Token.Template,
                            value: {
                                cooked: cooked,
                                raw: source.slice(start + 1, index - rawOffset)
                            },
                            head: head,
                            tail: tail,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }

                    function testRegExp(pattern, flags) {
                        var tmp = pattern;

                        if (flags.indexOf('u') >= 0) {
                            // Replace each astral symbol and every Unicode escape sequence
                            // that possibly represents an astral symbol or a paired surrogate
                            // with a single ASCII symbol to avoid throwing on regular
                            // expressions that are only valid in combination with the `/u`
                            // flag.
                            // Note: replacing with the ASCII symbol `x` might cause false
                            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
                            // perfectly valid pattern that is equivalent to `[a-b]`, but it
                            // would be replaced by `[x-b]` which throws an error.
                            tmp = tmp
                                .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                                    if (parseInt($1, 16) <= 0x10FFFF) {
                                        return 'x';
                                    }
                                    throwUnexpectedToken(null, Messages.InvalidRegExp);
                                })
                                .replace(
                                /\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                                'x'
                            );
                        }

                        // First, detect invalid regular expressions.
                        try {
                            RegExp(tmp);
                        } catch (e) {
                            throwUnexpectedToken(null, Messages.InvalidRegExp);
                        }

                        // Return a regular expression object for this pattern-flag pair, or
                        // `null` in case the current environment doesn't support the flags it
                        // uses.
                        try {
                            return new RegExp(pattern, flags);
                        } catch (exception) {
                            return null;
                        }
                    }

                    function scanRegExpBody() {
                        var ch, str, classMarker, terminated, body;

                        ch = source[index];
                        assert(ch === '/', 'Regular expression literal must start with a slash');
                        str = source[index++];

                        classMarker = false;
                        terminated = false;

                        while (index < length) {
                            ch = source[index++];
                            str += ch;

                            if (ch === '\\') {
                                ch = source[index++];
                                // ECMA-262 7.8.5
                                if (isLineTerminator(ch.charCodeAt(0))) {
                                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                                }
                                str += ch;
                            } else if (isLineTerminator(ch.charCodeAt(0))) {
                                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                            } else if (classMarker) {
                                if (ch === ']') {
                                    classMarker = false;
                                }
                            } else if (ch === '/') {
                                terminated = true;
                                break;
                            } else if (ch === '[') {
                                classMarker = true;
                            }
                        }

                        if (!terminated) {
                            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                        }

                        // Exclude leading and trailing slash.
                        body = str.substr(1, str.length - 2);

                        return {
                            value: body,
                            literal: str
                        };
                    }

                    function scanRegExpFlags() {
                        var ch, str, flags, restore;

                        str = '';
                        flags = '';

                        while (index < length) {
                            ch = source[index];

                            if (!isIdentifierPart(ch.charCodeAt(0))) {
                                break;
                            }

                            ++index;

                            if (ch === '\\' && index < length) {
                                ch = source[index];

                                if (ch === 'u') {
                                    ++index;
                                    restore = index;
                                    ch = scanHexEscape('u');

                                    if (ch) {
                                        flags += ch;

                                        for (str += '\\u'; restore < index; ++restore) {
                                            str += source[restore];
                                        }
                                    } else {
                                        index = restore;
                                        flags += 'u';
                                        str += '\\u';
                                    }
                                    tolerateUnexpectedToken();
                                } else {
                                    str += '\\';
                                    tolerateUnexpectedToken();
                                }
                            } else {
                                flags += ch;
                                str += ch;
                            }
                        }

                        return {
                            value: flags,
                            literal: str
                        };
                    }

                    function scanRegExp() {
                        scanning = true;
                        var start, body, flags, value;

                        lookahead = null;
                        skipComment();
                        start = index;

                        body = scanRegExpBody();
                        flags = scanRegExpFlags();
                        value = testRegExp(body.value, flags.value);
                        scanning = false;

                        if (extra.tokenize) {
                            return {
                                type: Token.RegularExpression,
                                value: value,
                                regex: {
                                    pattern: body.value,
                                    flags: flags.value
                                },
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                start: start,
                                end: index
                            };
                        }

                        return {
                            literal: body.literal + flags.literal,
                            value: value,
                            regex: {
                                pattern: body.value,
                                flags: flags.value
                            },
                            start: start,
                            end: index
                        };
                    }

                    function collectRegex() {
                        var pos, loc, regex, token;

                        skipComment();

                        pos = index;
                        loc = {
                            start: {
                                line: lineNumber,
                                column: index - lineStart
                            }
                        };

                        regex = scanRegExp();

                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };

                        /* istanbul ignore next */
                        if (!extra.tokenize) {
                            // Pop the previous token, which is likely '/' or '/='
                            if (extra.tokens.length > 0) {
                                token = extra.tokens[extra.tokens.length - 1];

                                if (token.range[0] === pos && token.type === 'Punctuator') {
                                    if (token.value === '/' || token.value === '/=') {
                                        extra.tokens.pop();
                                    }
                                }
                            }

                            extra.tokens.push({
                                type: 'RegularExpression',
                                value: regex.literal,
                                regex: regex.regex,
                                range: [pos, index],
                                loc: loc
                            });
                        }

                        return regex;
                    }

                    function isIdentifierName(token) {
                        return token.type === Token.Identifier ||
                            token.type === Token.Keyword ||
                            token.type === Token.BooleanLiteral ||
                            token.type === Token.NullLiteral;
                    }

                    function advanceSlash() {
                        var prevToken,
                            checkToken;
                        // Using the following algorithm:
                        // https://github.com/mozilla/sweet.js/wiki/design

                        prevToken = extra.tokens[extra.tokens.length - 1];

                        if (!prevToken) {
                            // Nothing before that: it cannot be a division.
                            return collectRegex();
                        }

                        if (prevToken.type === 'Punctuator') {
                            if (prevToken.value === ']') {
                                return scanPunctuator();
                            }

                            if (prevToken.value === ')') {
                                checkToken = extra.tokens[extra.openParenToken - 1];

                                if (checkToken &&
                                    checkToken.type === 'Keyword' &&
                                    (checkToken.value === 'if' ||
                                    checkToken.value === 'while' ||
                                    checkToken.value === 'for' ||
                                    checkToken.value === 'with')) {
                                    return collectRegex();
                                }

                                return scanPunctuator();
                            }

                            if (prevToken.value === '}') {
                                // Dividing a function by anything makes little sense,
                                // but we have to check for that.
                                if (extra.tokens[extra.openCurlyToken - 3] &&
                                    extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                                    // Anonymous function.
                                    checkToken = extra.tokens[extra.openCurlyToken - 4];

                                    if (!checkToken) {
                                        return scanPunctuator();
                                    }
                                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                                    extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                                    // Named function.
                                    checkToken = extra.tokens[extra.openCurlyToken - 5];

                                    if (!checkToken) {
                                        return collectRegex();
                                    }
                                } else {
                                    return scanPunctuator();
                                }
                                // checkToken determines whether the function is
                                // a declaration or an expression.
                                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                                    // It is an expression.
                                    return scanPunctuator();
                                }
                                // It is a declaration.
                                return collectRegex();
                            }

                            return collectRegex();
                        }

                        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
                            return collectRegex();
                        }

                        return scanPunctuator();
                    }

                    function advance() {
                        var ch, token;

                        if (index >= length) {
                            return {
                                type: Token.EOF,
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                start: index,
                                end: index
                            };
                        }

                        ch = source.charCodeAt(index);

                        if (isIdentifierStart(ch)) {
                            token = scanIdentifier();

                            if (strict && isStrictModeReservedWord(token.value)) {
                                token.type = Token.Keyword;
                            }

                            return token;
                        }

                        // Very common: ( and ) and ;
                        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
                            return scanPunctuator();
                        }

                        // String literal starts with single quote (U+0027) or double quote (U+0022).
                        if (ch === 0x27 || ch === 0x22) {
                            return scanStringLiteral();
                        }

                        // Dot (.) U+002E can also start a floating-point number, hence the need
                        // to check the next character.
                        if (ch === 0x2E) {
                            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                                return scanNumericLiteral();
                            }

                            return scanPunctuator();
                        }

                        if (isDecimalDigit(ch)) {
                            return scanNumericLiteral();
                        }

                        // Slash (/) U+002F can also start a regex.
                        if (extra.tokenize && ch === 0x2F) {
                            return advanceSlash();
                        }

                        // Template literals start with ` (U+0060) for template head
                        // or } (U+007D) for template middle or template tail.
                        if (ch === 0x60 || ch === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${') {
                            return scanTemplate();
                        }

                        return scanPunctuator();
                    }

                    function collectToken() {
                        var loc, token, value, entry;

                        loc = {
                            start: {
                                line: lineNumber,
                                column: index - lineStart
                            }
                        };

                        token = advance();
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };

                        if (token.type !== Token.EOF) {
                            value = source.slice(token.start, token.end);
                            entry = {
                                type: TokenName[token.type],
                                value: value,
                                range: [token.start, token.end],
                                loc: loc
                            };

                            if (token.regex) {
                                entry.regex = {
                                    pattern: token.regex.pattern,
                                    flags: token.regex.flags
                                };
                            }
                            extra.tokens.push(entry);
                        }

                        return token;
                    }

                    function lex() {
                        var token;

                        scanning = true;

                        lastIndex = index;
                        lastLineNumber = lineNumber;
                        lastLineStart = lineStart;

                        skipComment();

                        token = lookahead;

                        startIndex = index;
                        startLineNumber = lineNumber;
                        startLineStart = lineStart;

                        lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
                        scanning = false;

                        return token;
                    }

                    function peek() {
                        scanning = true;

                        skipComment();

                        lastIndex = index;
                        lastLineNumber = lineNumber;
                        lastLineStart = lineStart;

                        startIndex = index;
                        startLineNumber = lineNumber;
                        startLineStart = lineStart;

                        lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
                        scanning = false;
                    }

                    function Position() {
                        this.line = startLineNumber;
                        this.column = startIndex - startLineStart;
                    }

                    function SourceLocation() {
                        this.start = new Position();
                        this.end = null;
                    }

                    function WrappingSourceLocation(startToken) {
                        this.start = {
                            line: startToken.lineNumber,
                            column: startToken.start - startToken.lineStart
                        };
                        this.end = null;
                    }

                    function Node() {
                        if (extra.range) {
                            this.range = [startIndex, 0];
                        }

                        if (extra.loc) {
                            this.loc = new SourceLocation();
                        }
                    }

                    function WrappingNode(startToken) {
                        if (extra.range) {
                            this.range = [startToken.start, 0];
                        }

                        if (extra.loc) {
                            this.loc = new WrappingSourceLocation(startToken);
                        }
                    }

                    WrappingNode.prototype = Node.prototype = {

                        processComment: function () {
                            var lastChild,
                                leadingComments,
                                trailingComments,
                                bottomRight = extra.bottomRightStack,
                                i,
                                comment,
                                last = bottomRight[bottomRight.length - 1];

                            if (this.type === Syntax.Program) {
                                if (this.body.length > 0) {
                                    return;
                                }
                            }

                            if (extra.trailingComments.length > 0) {
                                trailingComments = [];

                                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                                    comment = extra.trailingComments[i];

                                    if (comment.range[0] >= this.range[1]) {
                                        trailingComments.unshift(comment);
                                        extra.trailingComments.splice(i, 1);
                                    }
                                }
                                extra.trailingComments = [];
                            } else if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                                trailingComments = last.trailingComments;
                                delete last.trailingComments;
                            }

                            // Eating the stack.
                            if (last) {
                                while (last && last.range[0] >= this.range[0]) {
                                    lastChild = last;
                                    last = bottomRight.pop();
                                }
                            }

                            if (lastChild) {
                                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {
                                    this.leadingComments = lastChild.leadingComments;
                                    lastChild.leadingComments = undefined;
                                }
                            } else if (extra.leadingComments.length > 0) {
                                leadingComments = [];

                                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                                    comment = extra.leadingComments[i];

                                    if (comment.range[1] <= this.range[0]) {
                                        leadingComments.unshift(comment);
                                        extra.leadingComments.splice(i, 1);
                                    }
                                }
                            }

                            if (leadingComments && leadingComments.length > 0) {
                                this.leadingComments = leadingComments;
                            }

                            if (trailingComments && trailingComments.length > 0) {
                                this.trailingComments = trailingComments;
                            }

                            bottomRight.push(this);
                        },

                        finish: function () {
                            if (extra.range) {
                                this.range[1] = lastIndex;
                            }

                            if (extra.loc) {
                                this.loc.end = {
                                    line: lastLineNumber,
                                    column: lastIndex - lastLineStart
                                };

                                if (extra.source) {
                                    this.loc.source = extra.source;
                                }
                            }

                            if (extra.attachComment) {
                                this.processComment();
                            }
                        },

                        finishArrayExpression: function (elements) {
                            this.type = Syntax.ArrayExpression;
                            this.elements = elements;
                            this.finish();

                            return this;
                        },

                        finishArrayPattern: function (elements) {
                            this.type = Syntax.ArrayPattern;
                            this.elements = elements;
                            this.finish();

                            return this;
                        },

                        finishArrowFunctionExpression: function (params, defaults, body, expression) {
                            this.type = Syntax.ArrowFunctionExpression;
                            this.id = null;
                            this.params = params;
                            this.defaults = defaults;
                            this.body = body;
                            this.generator = false;
                            this.expression = expression;
                            this.finish();

                            return this;
                        },

                        finishAssignmentExpression: function (operator, left, right) {
                            this.type = Syntax.AssignmentExpression;
                            this.operator = operator;
                            this.left = left;
                            this.right = right;
                            this.finish();

                            return this;
                        },

                        finishAssignmentPattern: function (left, right) {
                            this.type = Syntax.AssignmentPattern;
                            this.left = left;
                            this.right = right;
                            this.finish();

                            return this;
                        },

                        finishBinaryExpression: function (operator, left, right) {
                            this.type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;
                            this.operator = operator;
                            this.left = left;
                            this.right = right;
                            this.finish();

                            return this;
                        },

                        finishBlockStatement: function (body) {
                            this.type = Syntax.BlockStatement;
                            this.body = body;
                            this.finish();

                            return this;
                        },

                        finishBreakStatement: function (label) {
                            this.type = Syntax.BreakStatement;
                            this.label = label;
                            this.finish();

                            return this;
                        },

                        finishCallExpression: function (callee, args) {
                            this.type = Syntax.CallExpression;
                            this.callee = callee;
                            this.arguments = args;
                            this.finish();

                            return this;
                        },

                        finishCatchClause: function (param, body) {
                            this.type = Syntax.CatchClause;
                            this.param = param;
                            this.body = body;
                            this.finish();

                            return this;
                        },

                        finishClassBody: function (body) {
                            this.type = Syntax.ClassBody;
                            this.body = body;
                            this.finish();

                            return this;
                        },

                        finishClassDeclaration: function (id, superClass, body) {
                            this.type = Syntax.ClassDeclaration;
                            this.id = id;
                            this.superClass = superClass;
                            this.body = body;
                            this.finish();

                            return this;
                        },

                        finishClassExpression: function (id, superClass, body) {
                            this.type = Syntax.ClassExpression;
                            this.id = id;
                            this.superClass = superClass;
                            this.body = body;
                            this.finish();

                            return this;
                        },

                        finishConditionalExpression: function (test, consequent, alternate) {
                            this.type = Syntax.ConditionalExpression;
                            this.test = test;
                            this.consequent = consequent;
                            this.alternate = alternate;
                            this.finish();

                            return this;
                        },

                        finishContinueStatement: function (label) {
                            this.type = Syntax.ContinueStatement;
                            this.label = label;
                            this.finish();

                            return this;
                        },

                        finishDebuggerStatement: function () {
                            this.type = Syntax.DebuggerStatement;
                            this.finish();

                            return this;
                        },

                        finishDoWhileStatement: function (body, test) {
                            this.type = Syntax.DoWhileStatement;
                            this.body = body;
                            this.test = test;
                            this.finish();

                            return this;
                        },

                        finishEmptyStatement: function () {
                            this.type = Syntax.EmptyStatement;
                            this.finish();

                            return this;
                        },

                        finishExpressionStatement: function (expression) {
                            this.type = Syntax.ExpressionStatement;
                            this.expression = expression;
                            this.finish();

                            return this;
                        },

                        finishForStatement: function (init, test, update, body) {
                            this.type = Syntax.ForStatement;
                            this.init = init;
                            this.test = test;
                            this.update = update;
                            this.body = body;
                            this.finish();

                            return this;
                        },

                        finishForInStatement: function (left, right, body) {
                            this.type = Syntax.ForInStatement;
                            this.left = left;
                            this.right = right;
                            this.body = body;
                            this.each = false;
                            this.finish();

                            return this;
                        },

                        finishFunctionDeclaration: function (id, params, defaults, body) {
                            this.type = Syntax.FunctionDeclaration;
                            this.id = id;
                            this.params = params;
                            this.defaults = defaults;
                            this.body = body;
                            this.generator = false;
                            this.expression = false;
                            this.finish();

                            return this;
                        },

                        finishFunctionExpression: function (id, params, defaults, body) {
                            this.type = Syntax.FunctionExpression;
                            this.id = id;
                            this.params = params;
                            this.defaults = defaults;
                            this.body = body;
                            this.generator = false;
                            this.expression = false;
                            this.finish();

                            return this;
                        },

                        finishIdentifier: function (name) {
                            this.type = Syntax.Identifier;
                            this.name = name;
                            this.finish();

                            return this;
                        },

                        finishIfStatement: function (test, consequent, alternate) {
                            this.type = Syntax.IfStatement;
                            this.test = test;
                            this.consequent = consequent;
                            this.alternate = alternate;
                            this.finish();

                            return this;
                        },

                        finishLabeledStatement: function (label, body) {
                            this.type = Syntax.LabeledStatement;
                            this.label = label;
                            this.body = body;
                            this.finish();

                            return this;
                        },

                        finishLiteral: function (token) {
                            this.type = Syntax.Literal;
                            this.value = token.value;
                            this.raw = source.slice(token.start, token.end);

                            if (token.regex) {
                                this.regex = token.regex;
                            }
                            this.finish();

                            return this;
                        },

                        finishMemberExpression: function (accessor, object, property) {
                            this.type = Syntax.MemberExpression;
                            this.computed = accessor === '[';
                            this.object = object;
                            this.property = property;
                            this.finish();

                            return this;
                        },

                        finishNewExpression: function (callee, args) {
                            this.type = Syntax.NewExpression;
                            this.callee = callee;
                            this.arguments = args;
                            this.finish();

                            return this;
                        },

                        finishObjectExpression: function (properties) {
                            this.type = Syntax.ObjectExpression;
                            this.properties = properties;
                            this.finish();

                            return this;
                        },

                        finishObjectPattern: function (properties) {
                            this.type = Syntax.ObjectPattern;
                            this.properties = properties;
                            this.finish();

                            return this;
                        },

                        finishPostfixExpression: function (operator, argument) {
                            this.type = Syntax.UpdateExpression;
                            this.operator = operator;
                            this.argument = argument;
                            this.prefix = false;
                            this.finish();

                            return this;
                        },

                        finishProgram: function (body) {
                            this.type = Syntax.Program;
                            this.body = body;

                            if (sourceType === 'module') {
                                // very restrictive for now
                                this.sourceType = sourceType;
                            }
                            this.finish();

                            return this;
                        },

                        finishProperty: function (kind, key, computed, value, method, shorthand) {
                            this.type = Syntax.Property;
                            this.key = key;
                            this.computed = computed;
                            this.value = value;
                            this.kind = kind;
                            this.method = method;
                            this.shorthand = shorthand;
                            this.finish();

                            return this;
                        },

                        finishRestElement: function (argument) {
                            this.type = Syntax.RestElement;
                            this.argument = argument;
                            this.finish();

                            return this;
                        },

                        finishReturnStatement: function (argument) {
                            this.type = Syntax.ReturnStatement;
                            this.argument = argument;
                            this.finish();

                            return this;
                        },

                        finishSequenceExpression: function (expressions) {
                            this.type = Syntax.SequenceExpression;
                            this.expressions = expressions;
                            this.finish();

                            return this;
                        },

                        finishSpreadElement: function (argument) {
                            this.type = Syntax.SpreadElement;
                            this.argument = argument;
                            this.finish();

                            return this;
                        },

                        finishSwitchCase: function (test, consequent) {
                            this.type = Syntax.SwitchCase;
                            this.test = test;
                            this.consequent = consequent;
                            this.finish();

                            return this;
                        },

                        finishSuper: function () {
                            this.type = Syntax.Super;
                            this.finish();

                            return this;
                        },

                        finishSwitchStatement: function (discriminant, cases) {
                            this.type = Syntax.SwitchStatement;
                            this.discriminant = discriminant;
                            this.cases = cases;
                            this.finish();

                            return this;
                        },

                        finishTaggedTemplateExpression: function (tag, quasi) {
                            this.type = Syntax.TaggedTemplateExpression;
                            this.tag = tag;
                            this.quasi = quasi;
                            this.finish();

                            return this;
                        },

                        finishTemplateElement: function (value, tail) {
                            this.type = Syntax.TemplateElement;
                            this.value = value;
                            this.tail = tail;
                            this.finish();

                            return this;
                        },

                        finishTemplateLiteral: function (quasis, expressions) {
                            this.type = Syntax.TemplateLiteral;
                            this.quasis = quasis;
                            this.expressions = expressions;
                            this.finish();

                            return this;
                        },

                        finishThisExpression: function () {
                            this.type = Syntax.ThisExpression;
                            this.finish();

                            return this;
                        },

                        finishThrowStatement: function (argument) {
                            this.type = Syntax.ThrowStatement;
                            this.argument = argument;
                            this.finish();

                            return this;
                        },

                        finishTryStatement: function (block, handler, finalizer) {
                            this.type = Syntax.TryStatement;
                            this.block = block;
                            this.guardedHandlers = [];
                            this.handlers = handler ? [handler] : [];
                            this.handler = handler;
                            this.finalizer = finalizer;
                            this.finish();

                            return this;
                        },

                        finishUnaryExpression: function (operator, argument) {
                            this.type = operator === '++' || operator === '--' ? Syntax.UpdateExpression : Syntax.UnaryExpression;
                            this.operator = operator;
                            this.argument = argument;
                            this.prefix = true;
                            this.finish();

                            return this;
                        },

                        finishVariableDeclaration: function (declarations) {
                            this.type = Syntax.VariableDeclaration;
                            this.declarations = declarations;
                            this.kind = 'var';
                            this.finish();

                            return this;
                        },

                        finishLexicalDeclaration: function (declarations, kind) {
                            this.type = Syntax.VariableDeclaration;
                            this.declarations = declarations;
                            this.kind = kind;
                            this.finish();

                            return this;
                        },

                        finishVariableDeclarator: function (id, init) {
                            this.type = Syntax.VariableDeclarator;
                            this.id = id;
                            this.init = init;
                            this.finish();

                            return this;
                        },

                        finishWhileStatement: function (test, body) {
                            this.type = Syntax.WhileStatement;
                            this.test = test;
                            this.body = body;
                            this.finish();

                            return this;
                        },

                        finishWithStatement: function (object, body) {
                            this.type = Syntax.WithStatement;
                            this.object = object;
                            this.body = body;
                            this.finish();

                            return this;
                        },

                        finishExportSpecifier: function (local, exported) {
                            this.type = Syntax.ExportSpecifier;
                            this.exported = exported || local;
                            this.local = local;
                            this.finish();

                            return this;
                        },

                        finishImportDefaultSpecifier: function (local) {
                            this.type = Syntax.ImportDefaultSpecifier;
                            this.local = local;
                            this.finish();

                            return this;
                        },

                        finishImportNamespaceSpecifier: function (local) {
                            this.type = Syntax.ImportNamespaceSpecifier;
                            this.local = local;
                            this.finish();

                            return this;
                        },

                        finishExportNamedDeclaration: function (declaration, specifiers, src) {
                            this.type = Syntax.ExportNamedDeclaration;
                            this.declaration = declaration;
                            this.specifiers = specifiers;
                            this.source = src;
                            this.finish();

                            return this;
                        },

                        finishExportDefaultDeclaration: function (declaration) {
                            this.type = Syntax.ExportDefaultDeclaration;
                            this.declaration = declaration;
                            this.finish();

                            return this;
                        },

                        finishExportAllDeclaration: function (src) {
                            this.type = Syntax.ExportAllDeclaration;
                            this.source = src;
                            this.finish();

                            return this;
                        },

                        finishImportSpecifier: function (local, imported) {
                            this.type = Syntax.ImportSpecifier;
                            this.local = local || imported;
                            this.imported = imported;
                            this.finish();

                            return this;
                        },

                        finishImportDeclaration: function (specifiers, src) {
                            this.type = Syntax.ImportDeclaration;
                            this.specifiers = specifiers;
                            this.source = src;
                            this.finish();

                            return this;
                        }
                    };

                    function recordError(error) {
                        var e, existing;

                        for (e = 0; e < extra.errors.length; e++) {
                            existing = extra.errors[e];
                            // Prevent duplicated error.
                            /* istanbul ignore next */
                            if (existing.index === error.index && existing.message === error.message) {
                                return;
                            }
                        }

                        extra.errors.push(error);
                    }

                    function createError(line, pos, description) {
                        var error = new Error('Line ' + line + ': ' + description);

                        error.index = pos;
                        error.lineNumber = line;
                        error.column = pos - (scanning ? lineStart : lastLineStart) + 1;
                        error.description = description;

                        return error;
                    }

                    // Throw an exception

                    function throwError(messageFormat) {
                        var args, msg;

                        args = Array.prototype.slice.call(arguments, 1);
                        msg = messageFormat.replace(/%(\d)/g,
                            function (whole, idx) {
                                assert(idx < args.length, 'Message reference must be in range');

                                return args[idx];
                            }
                        );

                        throw createError(lastLineNumber, lastIndex, msg);
                    }

                    function tolerateError(messageFormat) {
                        var args, msg, error;

                        args = Array.prototype.slice.call(arguments, 1);
                        /* istanbul ignore next */
                        msg = messageFormat.replace(/%(\d)/g,
                            function (whole, idx) {
                                assert(idx < args.length, 'Message reference must be in range');

                                return args[idx];
                            }
                        );

                        error = createError(lineNumber, lastIndex, msg);

                        if (extra.errors) {
                            recordError(error);
                        } else {
                            throw error;
                        }
                    }

                    // Throw an exception because of the token.

                    function unexpectedTokenError(token, message) {
                        var value, msg = message || Messages.UnexpectedToken;

                        if (token) {
                            if (!message) {
                                msg = token.type === Token.EOF ? Messages.UnexpectedEOS :
                                    token.type === Token.Identifier ? Messages.UnexpectedIdentifier :
                                        token.type === Token.NumericLiteral ? Messages.UnexpectedNumber :
                                            token.type === Token.StringLiteral ? Messages.UnexpectedString :
                                                token.type === Token.Template ? Messages.UnexpectedTemplate :
                                                    Messages.UnexpectedToken;

                                if (token.type === Token.Keyword) {
                                    if (isFutureReservedWord(token.value)) {
                                        msg = Messages.UnexpectedReserved;
                                    } else if (strict && isStrictModeReservedWord(token.value)) {
                                        msg = Messages.StrictReservedWord;
                                    }
                                }
                            }

                            value = token.type === Token.Template ? token.value.raw : token.value;
                        } else {
                            value = 'ILLEGAL';
                        }

                        msg = msg.replace('%0', value);

                        return token && typeof token.lineNumber === 'number' ?
                            createError(token.lineNumber, token.start, msg) :
                            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
                    }

                    function throwUnexpectedToken(token, message) {
                        throw unexpectedTokenError(token, message);
                    }

                    function tolerateUnexpectedToken(token, message) {
                        var error = unexpectedTokenError(token, message);

                        if (extra.errors) {
                            recordError(error);
                        } else {
                            throw error;
                        }
                    }

                    // Expect the next token to match the specified punctuator.
                    // If not, an exception will be thrown.

                    function expect(value) {
                        var token = lex();

                        if (token.type !== Token.Punctuator || token.value !== value) {
                            throwUnexpectedToken(token);
                        }
                    }

                    /**
                     * @name expectCommaSeparator
                     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
                     * to <code>expect(value)</code>
                     * @since 2.0
                     */
                    function expectCommaSeparator() {
                        var token;

                        if (extra.errors) {
                            token = lookahead;

                            if (token.type === Token.Punctuator && token.value === ',') {
                                lex();
                            } else if (token.type === Token.Punctuator && token.value === ';') {
                                lex();
                                tolerateUnexpectedToken(token);
                            } else {
                                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
                            }
                        } else {
                            expect(',');
                        }
                    }

                    // Expect the next token to match the specified keyword.
                    // If not, an exception will be thrown.

                    function expectKeyword(keyword) {
                        var token = lex();

                        if (token.type !== Token.Keyword || token.value !== keyword) {
                            throwUnexpectedToken(token);
                        }
                    }

                    // Return true if the next token matches the specified punctuator.

                    function match(value) {
                        return lookahead.type === Token.Punctuator && lookahead.value === value;
                    }

                    // Return true if the next token matches the specified keyword

                    function matchKeyword(keyword) {
                        return lookahead.type === Token.Keyword && lookahead.value === keyword;
                    }

                    // Return true if the next token matches the specified contextual keyword
                    // (where an identifier is sometimes a keyword depending on the context)

                    function matchContextualKeyword(keyword) {
                        return lookahead.type === Token.Identifier && lookahead.value === keyword;
                    }

                    // Return true if the next token is an assignment operator

                    function matchAssign() {
                        var op;

                        if (lookahead.type !== Token.Punctuator) {
                            return false;
                        }
                        op = lookahead.value;

                        return op === '=' ||
                            op === '*=' ||
                            op === '/=' ||
                            op === '%=' ||
                            op === '+=' ||
                            op === '-=' ||
                            op === '<<=' ||
                            op === '>>=' ||
                            op === '>>>=' ||
                            op === '&=' ||
                            op === '^=' ||
                            op === '|=';
                    }

                    function consumeSemicolon() {
                        // Catch the very common case first: immediately a semicolon (U+003B).
                        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
                            lex();

                            return;
                        }

                        if (hasLineTerminator) {
                            return;
                        }

                        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
                        lastIndex = startIndex;
                        lastLineNumber = startLineNumber;
                        lastLineStart = startLineStart;

                        if (lookahead.type !== Token.EOF && !match('}')) {
                            throwUnexpectedToken(lookahead);
                        }
                    }

                    // Cover grammar support.
                    //
                    // When an assignment expression position starts with an left parenthesis, the determination of the type
                    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
                    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
                    //
                    // There are three productions that can be parsed in a parentheses pair that needs to be determined
                    // after the outermost pair is closed. They are:
                    //
                    //   1. AssignmentExpression
                    //   2. BindingElements
                    //   3. AssignmentTargets
                    //
                    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
                    // binding element or assignment target.
                    //
                    // The three productions have the relationship:
                    //
                    //   BindingElements â AssignmentTargets â AssignmentExpression
                    //
                    // with a single exception that CoverInitializedName when used directly in an Expression, generates
                    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
                    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
                    //
                    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
                    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
                    // the CoverInitializedName check is conducted.
                    //
                    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
                    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
                    // pattern. The CoverInitializedName check is deferred.
                    function isolateCoverGrammar(parser) {
                        var oldIsBindingElement = isBindingElement,
                            oldIsAssignmentTarget = isAssignmentTarget,
                            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
                            result;

                        isBindingElement = true;
                        isAssignmentTarget = true;
                        firstCoverInitializedNameError = null;
                        result = parser();

                        if (firstCoverInitializedNameError !== null) {
                            throwUnexpectedToken(firstCoverInitializedNameError);
                        }
                        isBindingElement = oldIsBindingElement;
                        isAssignmentTarget = oldIsAssignmentTarget;
                        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;

                        return result;
                    }

                    function inheritCoverGrammar(parser) {
                        var oldIsBindingElement = isBindingElement,
                            oldIsAssignmentTarget = isAssignmentTarget,
                            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
                            result;

                        isBindingElement = true;
                        isAssignmentTarget = true;
                        firstCoverInitializedNameError = null;
                        result = parser();
                        isBindingElement = isBindingElement && oldIsBindingElement;
                        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
                        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;

                        return result;
                    }

                    function parseArrayPattern() {
                        var node = new Node(),
 elements = [],
 rest, restNode;

                        expect('[');

                        while (!match(']')) {
                            if (match(',')) {
                                lex();
                                elements.push(null);
                            } else {
                                if (match('...')) {
                                    restNode = new Node();
                                    lex();
                                    rest = parseVariableIdentifier();
                                    elements.push(restNode.finishRestElement(rest));
                                    break;
                                } else {
                                    elements.push(parsePatternWithDefault());
                                }

                                if (!match(']')) {
                                    expect(',');
                                }
                            }

                        }

                        expect(']');

                        return node.finishArrayPattern(elements);
                    }

                    function parsePropertyPattern() {
                        var node = new Node(),
 key, computed = match('['),
 init;

                        if (lookahead.type === Token.Identifier) {
                            key = parseVariableIdentifier();

                            if (match('=')) {
                                lex();
                                init = parseAssignmentExpression();

                                return node.finishProperty(
                                    'init', key, false,
                                    new WrappingNode(key).finishAssignmentPattern(key, init), false, false);
                            } else if (!match(':')) {
                                return node.finishProperty('init', key, false, key, false, true);
                            }
                        } else {
                            key = parseObjectPropertyKey();
                        }
                        expect(':');
                        init = parsePatternWithDefault();

                        return node.finishProperty('init', key, computed, init, false, false);
                    }

                    function parseObjectPattern() {
                        var node = new Node(),
 properties = [];

                        expect('{');

                        while (!match('}')) {
                            properties.push(parsePropertyPattern());

                            if (!match('}')) {
                                expect(',');
                            }
                        }

                        lex();

                        return node.finishObjectPattern(properties);
                    }

                    function parsePattern() {
                        if (lookahead.type === Token.Identifier) {
                            return parseVariableIdentifier();
                        } else if (match('[')) {
                            return parseArrayPattern();
                        } else if (match('{')) {
                            return parseObjectPattern();
                        }
                        throwUnexpectedToken(lookahead);
                    }

                    function parsePatternWithDefault() {
                        var startToken = lookahead,
 pattern, right;

                        pattern = parsePattern();

                        if (match('=')) {
                            lex();
                            right = isolateCoverGrammar(parseAssignmentExpression);
                            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
                        }

                        return pattern;
                    }

                    // 11.1.4 Array Initialiser

                    function parseArrayInitialiser() {
                        var elements = [],
 node = new Node(),
 restSpread;

                        expect('[');

                        while (!match(']')) {
                            if (match(',')) {
                                lex();
                                elements.push(null);
                            } else if (match('...')) {
                                restSpread = new Node();
                                lex();
                                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

                                if (!match(']')) {
                                    isAssignmentTarget = isBindingElement = false;
                                    expect(',');
                                }
                                elements.push(restSpread);
                            } else {
                                elements.push(inheritCoverGrammar(parseAssignmentExpression));

                                if (!match(']')) {
                                    expect(',');
                                }
                            }
                        }

                        lex();

                        return node.finishArrayExpression(elements);
                    }

                    // 11.1.5 Object Initialiser

                    function parsePropertyFunction(node, paramInfo) {
                        var previousStrict, body;

                        isAssignmentTarget = isBindingElement = false;

                        previousStrict = strict;
                        body = isolateCoverGrammar(parseFunctionSourceElements);

                        if (strict && paramInfo.firstRestricted) {
                            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
                        }

                        if (strict && paramInfo.stricted) {
                            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
                        }

                        strict = previousStrict;

                        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body);
                    }

                    function parsePropertyMethodFunction() {
                        var params, method, node = new Node();

                        params = parseParams();
                        method = parsePropertyFunction(node, params);

                        return method;
                    }

                    function parseObjectPropertyKey() {
                        var token, node = new Node(),
 expr;

                        token = lex();

                        // Note: This function is called only from parseObjectProperty(), where
                        // EOF and Punctuator tokens are already filtered out.

                        switch (token.type) {
                            case Token.StringLiteral:
                            case Token.NumericLiteral:
                                if (strict && token.octal) {
                                    tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
                                }

                                return node.finishLiteral(token);

                            case Token.Identifier:
                            case Token.BooleanLiteral:
                            case Token.NullLiteral:
                            case Token.Keyword:
                                return node.finishIdentifier(token.value);

                            case Token.Punctuator:
                                if (token.value === '[') {
                                    expr = isolateCoverGrammar(parseAssignmentExpression);
                                    expect(']');

                                    return expr;
                                }
                                break;
                        }
                        throwUnexpectedToken(token);
                    }

                    function lookaheadPropertyName() {
                        switch (lookahead.type) {
                            case Token.Identifier:
                            case Token.StringLiteral:
                            case Token.BooleanLiteral:
                            case Token.NullLiteral:
                            case Token.NumericLiteral:
                            case Token.Keyword:
                                return true;

                            case Token.Punctuator:
                                return lookahead.value === '[';
                        }

                        return false;
                    }

                    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
                    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
                    // This can only be determined after we consumed up to the left parentheses.
                    //
                    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
                    // is responsible to visit other options.
                    function tryParseMethodDefinition(token, key, computed, node) {
                        var value, options, methodNode;

                        if (token.type === Token.Identifier) {
                            // check for `get` and `set`;

                            if (token.value === 'get' && lookaheadPropertyName()) {
                                computed = match('[');
                                key = parseObjectPropertyKey();
                                methodNode = new Node();
                                expect('(');
                                expect(')');
                                value = parsePropertyFunction(methodNode, {
                                    params: [],
                                    defaults: [],
                                    stricted: null,
                                    firstRestricted: null,
                                    message: null
                                });

                                return node.finishProperty('get', key, computed, value, false, false);
                            } else if (token.value === 'set' && lookaheadPropertyName()) {
                                computed = match('[');
                                key = parseObjectPropertyKey();
                                methodNode = new Node();
                                expect('(');

                                options = {
                                    params: [],
                                    defaultCount: 0,
                                    defaults: [],
                                    firstRestricted: null,
                                    paramSet: {}
                                };

                                if (match(')')) {
                                    tolerateUnexpectedToken(lookahead);
                                } else {
                                    parseParam(options);

                                    if (options.defaultCount === 0) {
                                        options.defaults = [];
                                    }
                                }
                                expect(')');

                                value = parsePropertyFunction(methodNode, options);

                                return node.finishProperty('set', key, computed, value, false, false);
                            }
                        }

                        if (match('(')) {
                            value = parsePropertyMethodFunction();

                            return node.finishProperty('init', key, computed, value, true, false);
                        }

                        // Not a MethodDefinition.
                        return null;
                    }

                    function checkProto(key, computed, hasProto) {
                        if (computed === false && (key.type === Syntax.Identifier && key.name === '__proto__' ||
                            key.type === Syntax.Literal && key.value === '__proto__')) {
                            if (hasProto.value) {
                                tolerateError(Messages.DuplicateProtoProperty);
                            } else {
                                hasProto.value = true;
                            }
                        }
                    }

                    function parseObjectProperty(hasProto) {
                        var token = lookahead,
 node = new Node(),
 computed, key, maybeMethod, value;

                        computed = match('[');
                        key = parseObjectPropertyKey();
                        maybeMethod = tryParseMethodDefinition(token, key, computed, node);

                        if (maybeMethod) {
                            checkProto(maybeMethod.key, maybeMethod.computed, hasProto);
                            // finished
                            return maybeMethod;
                        }

                        // init property or short hand property.
                        checkProto(key, computed, hasProto);

                        if (match(':')) {
                            lex();
                            value = inheritCoverGrammar(parseAssignmentExpression);

                            return node.finishProperty('init', key, computed, value, false, false);
                        }

                        if (token.type === Token.Identifier) {
                            if (match('=')) {
                                firstCoverInitializedNameError = lookahead;
                                lex();
                                value = isolateCoverGrammar(parseAssignmentExpression);

                                return node.finishProperty('init', key, computed,
                                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
                            }

                            return node.finishProperty('init', key, computed, key, false, true);
                        }

                        throwUnexpectedToken(lookahead);
                    }

                    function parseObjectInitialiser() {
                        var properties = [],
 hasProto = {
                            value: false
                        },
 node = new Node();

                        expect('{');

                        while (!match('}')) {
                            properties.push(parseObjectProperty(hasProto));

                            if (!match('}')) {
                                expectCommaSeparator();
                            }
                        }

                        expect('}');

                        return node.finishObjectExpression(properties);
                    }

                    function reinterpretExpressionAsPattern(expr) {
                        var i;

                        switch (expr.type) {
                            case Syntax.Identifier:
                            case Syntax.MemberExpression:
                            case Syntax.RestElement:
                            case Syntax.AssignmentPattern:
                                break;

                            case Syntax.SpreadElement:
                                expr.type = Syntax.RestElement;
                                reinterpretExpressionAsPattern(expr.argument);
                                break;

                            case Syntax.ArrayExpression:
                                expr.type = Syntax.ArrayPattern;

                                for (i = 0; i < expr.elements.length; i++) {
                                    if (expr.elements[i] !== null) {
                                        reinterpretExpressionAsPattern(expr.elements[i]);
                                    }
                                }
                                break;

                            case Syntax.ObjectExpression:
                                expr.type = Syntax.ObjectPattern;

                                for (i = 0; i < expr.properties.length; i++) {
                                    reinterpretExpressionAsPattern(expr.properties[i].value);
                                }
                                break;

                            case Syntax.AssignmentExpression:
                                expr.type = Syntax.AssignmentPattern;
                                reinterpretExpressionAsPattern(expr.left);
                                break;
                            default:
                                // Allow other node type for tolerant parsing.
                                break;
                        }
                    }

                    function parseTemplateElement(option) {
                        var node, token;

                        if (lookahead.type !== Token.Template || option.head && !lookahead.head) {
                            throwUnexpectedToken();
                        }

                        node = new Node();
                        token = lex();

                        return node.finishTemplateElement({
                            raw: token.value.raw, cooked: token.value.cooked
                        }, token.tail);
                    }

                    function parseTemplateLiteral() {
                        var quasi, quasis, expressions, node = new Node();

                        quasi = parseTemplateElement({
                            head: true
                        });
                        quasis = [quasi];
                        expressions = [];

                        while (!quasi.tail) {
                            expressions.push(parseExpression());
                            quasi = parseTemplateElement({
                                head: false
                            });
                            quasis.push(quasi);
                        }

                        return node.finishTemplateLiteral(quasis, expressions);
                    }

                    // 11.1.6 The Grouping Operator

                    function parseGroupExpression() {
                        var expr, expressions, startToken, i;

                        expect('(');

                        if (match(')')) {
                            lex();

                            if (!match('=>')) {
                                expect('=>');
                            }

                            return {
                                type: PlaceHolders.ArrowParameterPlaceHolder,
                                params: []
                            };
                        }

                        startToken = lookahead;

                        if (match('...')) {
                            expr = parseRestElement();
                            expect(')');

                            if (!match('=>')) {
                                expect('=>');
                            }

                            return {
                                type: PlaceHolders.ArrowParameterPlaceHolder,
                                params: [expr]
                            };
                        }

                        isBindingElement = true;
                        expr = inheritCoverGrammar(parseAssignmentExpression);

                        if (match(',')) {
                            isAssignmentTarget = false;
                            expressions = [expr];

                            while (startIndex < length) {
                                if (!match(',')) {
                                    break;
                                }
                                lex();

                                if (match('...')) {
                                    if (!isBindingElement) {
                                        throwUnexpectedToken(lookahead);
                                    }
                                    expressions.push(parseRestElement());
                                    expect(')');

                                    if (!match('=>')) {
                                        expect('=>');
                                    }
                                    isBindingElement = false;

                                    for (i = 0; i < expressions.length; i++) {
                                        reinterpretExpressionAsPattern(expressions[i]);
                                    }

                                    return {
                                        type: PlaceHolders.ArrowParameterPlaceHolder,
                                        params: expressions
                                    };
                                }

                                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
                            }

                            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
                        }

                        expect(')');

                        if (match('=>')) {
                            if (!isBindingElement) {
                                throwUnexpectedToken(lookahead);
                            }

                            if (expr.type === Syntax.SequenceExpression) {
                                for (i = 0; i < expr.expressions.length; i++) {
                                    reinterpretExpressionAsPattern(expr.expressions[i]);
                                }
                            } else {
                                reinterpretExpressionAsPattern(expr);
                            }

                            expr = {
                                type: PlaceHolders.ArrowParameterPlaceHolder,
                                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
                            };
                        }
                        isBindingElement = false;

                        return expr;
                    }


                    // 11.1 Primary Expressions

                    function parsePrimaryExpression() {
                        var type, token, expr, node;

                        if (match('(')) {
                            isBindingElement = false;

                            return inheritCoverGrammar(parseGroupExpression);
                        }

                        if (match('[')) {
                            return inheritCoverGrammar(parseArrayInitialiser);
                        }

                        if (match('{')) {
                            return inheritCoverGrammar(parseObjectInitialiser);
                        }

                        type = lookahead.type;
                        node = new Node();

                        if (type === Token.Identifier) {
                            expr = node.finishIdentifier(lex().value);
                        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
                            isAssignmentTarget = isBindingElement = false;

                            if (strict && lookahead.octal) {
                                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
                            }
                            expr = node.finishLiteral(lex());
                        } else if (type === Token.Keyword) {
                            isAssignmentTarget = isBindingElement = false;

                            if (matchKeyword('function')) {
                                return parseFunctionExpression();
                            }

                            if (matchKeyword('this')) {
                                lex();

                                return node.finishThisExpression();
                            }

                            if (matchKeyword('class')) {
                                return parseClassExpression();
                            }
                            throwUnexpectedToken(lex());
                        } else if (type === Token.BooleanLiteral) {
                            isAssignmentTarget = isBindingElement = false;
                            token = lex();
                            token.value = token.value === 'true';
                            expr = node.finishLiteral(token);
                        } else if (type === Token.NullLiteral) {
                            isAssignmentTarget = isBindingElement = false;
                            token = lex();
                            token.value = null;
                            expr = node.finishLiteral(token);
                        } else if (match('/') || match('/=')) {
                            isAssignmentTarget = isBindingElement = false;
                            index = startIndex;

                            if (typeof extra.tokens !== 'undefined') {
                                token = collectRegex();
                            } else {
                                token = scanRegExp();
                            }
                            lex();
                            expr = node.finishLiteral(token);
                        } else if (type === Token.Template) {
                            expr = parseTemplateLiteral();
                        } else {
                            throwUnexpectedToken(lex());
                        }

                        return expr;
                    }

                    // 11.2 Left-Hand-Side Expressions

                    function parseArguments() {
                        var args = [];

                        expect('(');

                        if (!match(')')) {
                            while (startIndex < length) {
                                args.push(isolateCoverGrammar(parseAssignmentExpression));

                                if (match(')')) {
                                    break;
                                }
                                expectCommaSeparator();
                            }
                        }

                        expect(')');

                        return args;
                    }

                    function parseNonComputedProperty() {
                        var token, node = new Node();

                        token = lex();

                        if (!isIdentifierName(token)) {
                            throwUnexpectedToken(token);
                        }

                        return node.finishIdentifier(token.value);
                    }

                    function parseNonComputedMember() {
                        expect('.');

                        return parseNonComputedProperty();
                    }

                    function parseComputedMember() {
                        var expr;

                        expect('[');

                        expr = isolateCoverGrammar(parseExpression);

                        expect(']');

                        return expr;
                    }

                    function parseNewExpression() {
                        var callee, args, node = new Node();

                        expectKeyword('new');
                        callee = isolateCoverGrammar(parseLeftHandSideExpression);
                        args = match('(') ? parseArguments() : [];

                        isAssignmentTarget = isBindingElement = false;

                        return node.finishNewExpression(callee, args);
                    }

                    function parseLeftHandSideExpressionAllowCall() {
                        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

                        startToken = lookahead;
                        state.allowIn = true;

                        if (matchKeyword('super') && state.inFunctionBody) {
                            expr = new Node();
                            lex();
                            expr = expr.finishSuper();

                            if (!match('(') && !match('.') && !match('[')) {
                                throwUnexpectedToken(lookahead);
                            }
                        } else {
                            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
                        }

                        for (;;) {
                            if (match('.')) {
                                isBindingElement = false;
                                isAssignmentTarget = true;
                                property = parseNonComputedMember();
                                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
                            } else if (match('(')) {
                                isBindingElement = false;
                                isAssignmentTarget = false;
                                args = parseArguments();
                                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
                            } else if (match('[')) {
                                isBindingElement = false;
                                isAssignmentTarget = true;
                                property = parseComputedMember();
                                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
                            } else if (lookahead.type === Token.Template && lookahead.head) {
                                quasi = parseTemplateLiteral();
                                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
                            } else {
                                break;
                            }
                        }
                        state.allowIn = previousAllowIn;

                        return expr;
                    }

                    function parseLeftHandSideExpression() {
                        var quasi, expr, property, startToken;

                        assert(state.allowIn, 'callee of new expression always allow in keyword.');

                        startToken = lookahead;

                        if (matchKeyword('super') && state.inFunctionBody) {
                            expr = new Node();
                            lex();
                            expr = expr.finishSuper();

                            if (!match('[') && !match('.')) {
                                throwUnexpectedToken(lookahead);
                            }
                        } else {
                            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
                        }

                        for (;;) {
                            if (match('[')) {
                                isBindingElement = false;
                                isAssignmentTarget = true;
                                property = parseComputedMember();
                                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
                            } else if (match('.')) {
                                isBindingElement = false;
                                isAssignmentTarget = true;
                                property = parseNonComputedMember();
                                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
                            } else if (lookahead.type === Token.Template && lookahead.head) {
                                quasi = parseTemplateLiteral();
                                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
                            } else {
                                break;
                            }
                        }

                        return expr;
                    }

                    // 11.3 Postfix Expressions

                    function parsePostfixExpression() {
                        var expr, token, startToken = lookahead;

                        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

                        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
                            if (match('++') || match('--')) {
                                // 11.3.1, 11.3.2
                                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                                    tolerateError(Messages.StrictLHSPostfix);
                                }

                                if (!isAssignmentTarget) {
                                    tolerateError(Messages.InvalidLHSInAssignment);
                                }

                                isAssignmentTarget = isBindingElement = false;

                                token = lex();
                                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
                            }
                        }

                        return expr;
                    }

                    // 11.4 Unary Operators

                    function parseUnaryExpression() {
                        var token, expr, startToken;

                        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
                            expr = parsePostfixExpression();
                        } else if (match('++') || match('--')) {
                            startToken = lookahead;
                            token = lex();
                            expr = inheritCoverGrammar(parseUnaryExpression);
                            // 11.4.4, 11.4.5
                            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                                tolerateError(Messages.StrictLHSPrefix);
                            }

                            if (!isAssignmentTarget) {
                                tolerateError(Messages.InvalidLHSInAssignment);
                            }
                            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
                            isAssignmentTarget = isBindingElement = false;
                        } else if (match('+') || match('-') || match('~') || match('!')) {
                            startToken = lookahead;
                            token = lex();
                            expr = inheritCoverGrammar(parseUnaryExpression);
                            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
                            isAssignmentTarget = isBindingElement = false;
                        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
                            startToken = lookahead;
                            token = lex();
                            expr = inheritCoverGrammar(parseUnaryExpression);
                            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);

                            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                                tolerateError(Messages.StrictDelete);
                            }
                            isAssignmentTarget = isBindingElement = false;
                        } else {
                            expr = parsePostfixExpression();
                        }

                        return expr;
                    }

                    function binaryPrecedence(token, allowIn) {
                        var prec = 0;

                        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
                            return 0;
                        }

                        switch (token.value) {
                            case '||':
                                prec = 1;
                                break;

                            case '&&':
                                prec = 2;
                                break;

                            case '|':
                                prec = 3;
                                break;

                            case '^':
                                prec = 4;
                                break;

                            case '&':
                                prec = 5;
                                break;

                            case '==':
                            case '!=':
                            case '===':
                            case '!==':
                                prec = 6;
                                break;

                            case '<':
                            case '>':
                            case '<=':
                            case '>=':
                            case 'instanceof':
                                prec = 7;
                                break;

                            case 'in':
                                prec = allowIn ? 7 : 0;
                                break;

                            case '<<':
                            case '>>':
                            case '>>>':
                                prec = 8;
                                break;

                            case '+':
                            case '-':
                                prec = 9;
                                break;

                            case '*':
                            case '/':
                            case '%':
                                prec = 11;
                                break;

                            default:
                                break;
                        }

                        return prec;
                    }

                    // 11.5 Multiplicative Operators
                    // 11.6 Additive Operators
                    // 11.7 Bitwise Shift Operators
                    // 11.8 Relational Operators
                    // 11.9 Equality Operators
                    // 11.10 Binary Bitwise Operators
                    // 11.11 Binary Logical Operators

                    function parseBinaryExpression() {
                        var marker, markers, expr, token, prec, stack, right, operator, left, i;

                        marker = lookahead;
                        left = inheritCoverGrammar(parseUnaryExpression);

                        token = lookahead;
                        prec = binaryPrecedence(token, state.allowIn);

                        if (prec === 0) {
                            return left;
                        }
                        isAssignmentTarget = isBindingElement = false;
                        token.prec = prec;
                        lex();

                        markers = [marker, lookahead];
                        right = isolateCoverGrammar(parseUnaryExpression);

                        stack = [left, token, right];

                        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

                            // Reduce: make a binary expression from the three topmost entries.
                            while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
                                right = stack.pop();
                                operator = stack.pop().value;
                                left = stack.pop();
                                markers.pop();
                                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                                stack.push(expr);
                            }

                            // Shift.
                            token = lex();
                            token.prec = prec;
                            stack.push(token);
                            markers.push(lookahead);
                            expr = isolateCoverGrammar(parseUnaryExpression);
                            stack.push(expr);
                        }

                        // Final reduce to clean-up the stack.
                        i = stack.length - 1;
                        expr = stack[i];
                        markers.pop();

                        while (i > 1) {
                            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
                            i -= 2;
                        }

                        return expr;
                    }


                    // 11.12 Conditional Operator

                    function parseConditionalExpression() {
                        var expr, previousAllowIn, consequent, alternate, startToken;

                        startToken = lookahead;

                        expr = inheritCoverGrammar(parseBinaryExpression);

                        if (match('?')) {
                            lex();
                            previousAllowIn = state.allowIn;
                            state.allowIn = true;
                            consequent = isolateCoverGrammar(parseAssignmentExpression);
                            state.allowIn = previousAllowIn;
                            expect(':');
                            alternate = isolateCoverGrammar(parseAssignmentExpression);

                            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
                            isAssignmentTarget = isBindingElement = false;
                        }

                        return expr;
                    }

                    // [ES6] 14.2 Arrow Function

                    function parseConciseBody() {
                        if (match('{')) {
                            return parseFunctionSourceElements();
                        }

                        return isolateCoverGrammar(parseAssignmentExpression);
                    }

                    function checkPatternParam(options, param) {
                        var i;

                        switch (param.type) {
                            case Syntax.Identifier:
                                validateParam(options, param, param.name);
                                break;

                            case Syntax.RestElement:
                                checkPatternParam(options, param.argument);
                                break;

                            case Syntax.AssignmentPattern:
                                checkPatternParam(options, param.left);
                                break;

                            case Syntax.ArrayPattern:
                                for (i = 0; i < param.elements.length; i++) {
                                    if (param.elements[i] !== null) {
                                        checkPatternParam(options, param.elements[i]);
                                    }
                                }
                                break;
                            default:
                                assert(param.type === Syntax.ObjectPattern, 'Invalid type');

                                for (i = 0; i < param.properties.length; i++) {
                                    checkPatternParam(options, param.properties[i].value);
                                }
                                break;
                        }
                    }
                    function reinterpretAsCoverFormalsList(expr) {
                        var i, len, param, params, defaults, defaultCount, options, token;

                        defaults = [];
                        defaultCount = 0;
                        params = [expr];

                        switch (expr.type) {
                            case Syntax.Identifier:
                                break;

                            case PlaceHolders.ArrowParameterPlaceHolder:
                                params = expr.params;
                                break;
                            default:
                                return null;
                        }

                        options = {
                            paramSet: {}
                        };

                        for (i = 0, len = params.length; i < len; i += 1) {
                            param = params[i];

                            switch (param.type) {
                                case Syntax.AssignmentPattern:
                                    params[i] = param.left;
                                    defaults.push(param.right);
                                    ++defaultCount;
                                    checkPatternParam(options, param.left);
                                    break;
                                default:
                                    checkPatternParam(options, param);
                                    params[i] = param;
                                    defaults.push(null);
                                    break;
                            }
                        }

                        if (options.message === Messages.StrictParamDupe) {
                            token = strict ? options.stricted : options.firstRestricted;
                            throwUnexpectedToken(token, options.message);
                        }

                        if (defaultCount === 0) {
                            defaults = [];
                        }

                        return {
                            params: params,
                            defaults: defaults,
                            stricted: options.stricted,
                            firstRestricted: options.firstRestricted,
                            message: options.message
                        };
                    }

                    function parseArrowFunctionExpression(options, node) {
                        var previousStrict, body;

                        if (hasLineTerminator) {
                            tolerateUnexpectedToken(lookahead);
                        }
                        expect('=>');
                        previousStrict = strict;

                        body = parseConciseBody();

                        if (strict && options.firstRestricted) {
                            throwUnexpectedToken(options.firstRestricted, options.message);
                        }

                        if (strict && options.stricted) {
                            tolerateUnexpectedToken(options.stricted, options.message);
                        }

                        strict = previousStrict;

                        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
                    }

                    // 11.13 Assignment Operators

                    function parseAssignmentExpression() {
                        var token, expr, right, list, startToken;

                        startToken = lookahead;
                        token = lookahead;

                        expr = parseConditionalExpression();

                        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
                            isAssignmentTarget = isBindingElement = false;
                            list = reinterpretAsCoverFormalsList(expr);

                            if (list) {
                                firstCoverInitializedNameError = null;

                                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
                            }

                            return expr;
                        }

                        if (matchAssign()) {
                            if (!isAssignmentTarget) {
                                tolerateError(Messages.InvalidLHSInAssignment);
                            }

                            // 11.13.1
                            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
                            }

                            if (!match('=')) {
                                isAssignmentTarget = isBindingElement = false;
                            } else {
                                reinterpretExpressionAsPattern(expr);
                            }

                            token = lex();
                            right = isolateCoverGrammar(parseAssignmentExpression);
                            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
                            firstCoverInitializedNameError = null;
                        }

                        return expr;
                    }

                    // 11.14 Comma Operator

                    function parseExpression() {
                        var expr, startToken = lookahead,
 expressions;

                        expr = isolateCoverGrammar(parseAssignmentExpression);

                        if (match(',')) {
                            expressions = [expr];

                            while (startIndex < length) {
                                if (!match(',')) {
                                    break;
                                }
                                lex();
                                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
                            }

                            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
                        }

                        return expr;
                    }

                    // 12.1 Block

                    function parseStatementListItem() {
                        if (lookahead.type === Token.Keyword) {
                            switch (lookahead.value) {
                                case 'export':
                                    if (sourceType !== 'module') {
                                        tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                                    }

                                    return parseExportDeclaration();

                                case 'import':
                                    if (sourceType !== 'module') {
                                        tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                                    }

                                    return parseImportDeclaration();

                                case 'const':
                                case 'let':
                                    return parseLexicalDeclaration({
                                        inFor: false
                                    });

                                case 'function':
                                    return parseFunctionDeclaration(new Node());

                                case 'class':
                                    return parseClassDeclaration();
                            }
                        }

                        return parseStatement();
                    }

                    function parseStatementList() {
                        var list = [];

                        while (startIndex < length) {
                            if (match('}')) {
                                break;
                            }
                            list.push(parseStatementListItem());
                        }

                        return list;
                    }

                    function parseBlock() {
                        var block, node = new Node();

                        expect('{');

                        block = parseStatementList();

                        expect('}');

                        return node.finishBlockStatement(block);
                    }

                    // 12.2 Variable Statement

                    function parseVariableIdentifier() {
                        var token, node = new Node();

                        token = lex();

                        if (token.type !== Token.Identifier) {
                            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                            } else {
                                throwUnexpectedToken(token);
                            }
                        }

                        return node.finishIdentifier(token.value);
                    }

                    function parseVariableDeclaration() {
                        var init = null,
 id, node = new Node();

                        id = parsePattern();

                        // 12.2.1
                        if (strict && isRestrictedWord(id.name)) {
                            tolerateError(Messages.StrictVarName);
                        }

                        if (match('=')) {
                            lex();
                            init = isolateCoverGrammar(parseAssignmentExpression);
                        } else if (id.type !== Syntax.Identifier) {
                            expect('=');
                        }

                        return node.finishVariableDeclarator(id, init);
                    }

                    function parseVariableDeclarationList() {
                        var list = [];

                        do {
                            list.push(parseVariableDeclaration());

                            if (!match(',')) {
                                break;
                            }
                            lex();
                        } while (startIndex < length);

                        return list;
                    }

                    function parseVariableStatement(node) {
                        var declarations;

                        expectKeyword('var');

                        declarations = parseVariableDeclarationList();

                        consumeSemicolon();

                        return node.finishVariableDeclaration(declarations);
                    }

                    function parseLexicalBinding(kind, options) {
                        var init = null,
 id, node = new Node();

                        id = parsePattern();

                        // 12.2.1
                        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
                            tolerateError(Messages.StrictVarName);
                        }

                        if (kind === 'const') {
                            if (!matchKeyword('in')) {
                                expect('=');
                                init = isolateCoverGrammar(parseAssignmentExpression);
                            }
                        } else if (!options.inFor && id.type !== Syntax.Identifier || match('=')) {
                            expect('=');
                            init = isolateCoverGrammar(parseAssignmentExpression);
                        }

                        return node.finishVariableDeclarator(id, init);
                    }

                    function parseBindingList(kind, options) {
                        var list = [];

                        do {
                            list.push(parseLexicalBinding(kind, options));

                            if (!match(',')) {
                                break;
                            }
                            lex();
                        } while (startIndex < length);

                        return list;
                    }

                    function parseLexicalDeclaration(options) {
                        var kind, declarations, node = new Node();

                        kind = lex().value;
                        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

                        declarations = parseBindingList(kind, options);

                        consumeSemicolon();

                        return node.finishLexicalDeclaration(declarations, kind);
                    }

                    function parseRestElement() {
                        var param, node = new Node();

                        lex();

                        if (match('{')) {
                            throwError(Messages.ObjectPatternAsRestParameter);
                        }

                        param = parseVariableIdentifier();

                        if (match('=')) {
                            throwError(Messages.DefaultRestParameter);
                        }

                        if (!match(')')) {
                            throwError(Messages.ParameterAfterRestParameter);
                        }

                        return node.finishRestElement(param);
                    }

                    // 12.3 Empty Statement

                    function parseEmptyStatement(node) {
                        expect(';');

                        return node.finishEmptyStatement();
                    }

                    // 12.4 Expression Statement

                    function parseExpressionStatement(node) {
                        var expr = parseExpression();

                        consumeSemicolon();

                        return node.finishExpressionStatement(expr);
                    }

                    // 12.5 If statement

                    function parseIfStatement(node) {
                        var test, consequent, alternate;

                        expectKeyword('if');

                        expect('(');

                        test = parseExpression();

                        expect(')');

                        consequent = parseStatement();

                        if (matchKeyword('else')) {
                            lex();
                            alternate = parseStatement();
                        } else {
                            alternate = null;
                        }

                        return node.finishIfStatement(test, consequent, alternate);
                    }

                    // 12.6 Iteration Statements

                    function parseDoWhileStatement(node) {
                        var body, test, oldInIteration;

                        expectKeyword('do');

                        oldInIteration = state.inIteration;
                        state.inIteration = true;

                        body = parseStatement();

                        state.inIteration = oldInIteration;

                        expectKeyword('while');

                        expect('(');

                        test = parseExpression();

                        expect(')');

                        if (match(';')) {
                            lex();
                        }

                        return node.finishDoWhileStatement(body, test);
                    }

                    function parseWhileStatement(node) {
                        var test, body, oldInIteration;

                        expectKeyword('while');

                        expect('(');

                        test = parseExpression();

                        expect(')');

                        oldInIteration = state.inIteration;
                        state.inIteration = true;

                        body = parseStatement();

                        state.inIteration = oldInIteration;

                        return node.finishWhileStatement(test, body);
                    }

                    function parseForStatement(node) {
                        var init, initSeq, initStartToken, test, update, left, right, kind, declarations,
                            body, oldInIteration, previousAllowIn = state.allowIn;

                        init = test = update = null;

                        expectKeyword('for');

                        expect('(');

                        if (match(';')) {
                            lex();
                        } else if (matchKeyword('var')) {
                            init = new Node();
                            lex();

                            state.allowIn = false;
                            init = init.finishVariableDeclaration(parseVariableDeclarationList());
                            state.allowIn = previousAllowIn;

                            if (init.declarations.length === 1 && matchKeyword('in')) {
                                lex();
                                left = init;
                                right = parseExpression();
                                init = null;
                            } else {
                                expect(';');
                            }
                        } else if (matchKeyword('const') || matchKeyword('let')) {
                            init = new Node();
                            kind = lex().value;

                            state.allowIn = false;
                            declarations = parseBindingList(kind, {
                                inFor: true
                            });
                            state.allowIn = previousAllowIn;

                            if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
                                init = init.finishLexicalDeclaration(declarations, kind);
                                lex();
                                left = init;
                                right = parseExpression();
                                init = null;
                            } else {
                                consumeSemicolon();
                                init = init.finishLexicalDeclaration(declarations, kind);
                            }
                        } else {
                            initStartToken = lookahead;
                            state.allowIn = false;
                            init = inheritCoverGrammar(parseAssignmentExpression);
                            state.allowIn = previousAllowIn;

                            if (matchKeyword('in')) {
                                if (!isAssignmentTarget) {
                                    tolerateError(Messages.InvalidLHSInForIn);
                                }

                                lex();
                                reinterpretExpressionAsPattern(init);
                                left = init;
                                right = parseExpression();
                                init = null;
                            } else {
                                if (match(',')) {
                                    initSeq = [init];

                                    while (match(',')) {
                                        lex();
                                        initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                                    }
                                    init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                                }
                                expect(';');
                            }
                        }

                        if (typeof left === 'undefined') {

                            if (!match(';')) {
                                test = parseExpression();
                            }
                            expect(';');

                            if (!match(')')) {
                                update = parseExpression();
                            }
                        }

                        expect(')');

                        oldInIteration = state.inIteration;
                        state.inIteration = true;

                        body = isolateCoverGrammar(parseStatement);

                        state.inIteration = oldInIteration;

                        return typeof left === 'undefined' ?
                            node.finishForStatement(init, test, update, body) :
                            node.finishForInStatement(left, right, body);
                    }

                    // 12.7 The continue statement

                    function parseContinueStatement(node) {
                        var label = null,
 key;

                        expectKeyword('continue');

                        // Optimize the most common form: 'continue;'.
                        if (source.charCodeAt(startIndex) === 0x3B) {
                            lex();

                            if (!state.inIteration) {
                                throwError(Messages.IllegalContinue);
                            }

                            return node.finishContinueStatement(null);
                        }

                        if (hasLineTerminator) {
                            if (!state.inIteration) {
                                throwError(Messages.IllegalContinue);
                            }

                            return node.finishContinueStatement(null);
                        }

                        if (lookahead.type === Token.Identifier) {
                            label = parseVariableIdentifier();

                            key = '$' + label.name;

                            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                                throwError(Messages.UnknownLabel, label.name);
                            }
                        }

                        consumeSemicolon();

                        if (label === null && !state.inIteration) {
                            throwError(Messages.IllegalContinue);
                        }

                        return node.finishContinueStatement(label);
                    }

                    // 12.8 The break statement

                    function parseBreakStatement(node) {
                        var label = null,
 key;

                        expectKeyword('break');

                        // Catch the very common case first: immediately a semicolon (U+003B).
                        if (source.charCodeAt(lastIndex) === 0x3B) {
                            lex();

                            if (!(state.inIteration || state.inSwitch)) {
                                throwError(Messages.IllegalBreak);
                            }

                            return node.finishBreakStatement(null);
                        }

                        if (hasLineTerminator) {
                            if (!(state.inIteration || state.inSwitch)) {
                                throwError(Messages.IllegalBreak);
                            }

                            return node.finishBreakStatement(null);
                        }

                        if (lookahead.type === Token.Identifier) {
                            label = parseVariableIdentifier();

                            key = '$' + label.name;

                            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                                throwError(Messages.UnknownLabel, label.name);
                            }
                        }

                        consumeSemicolon();

                        if (label === null && !(state.inIteration || state.inSwitch)) {
                            throwError(Messages.IllegalBreak);
                        }

                        return node.finishBreakStatement(label);
                    }

                    // 12.9 The return statement

                    function parseReturnStatement(node) {
                        var argument = null;

                        expectKeyword('return');

                        if (!state.inFunctionBody) {
                            tolerateError(Messages.IllegalReturn);
                        }

                        // 'return' followed by a space and an identifier is very common.
                        if (source.charCodeAt(lastIndex) === 0x20) {
                            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                                argument = parseExpression();
                                consumeSemicolon();

                                return node.finishReturnStatement(argument);
                            }
                        }

                        if (hasLineTerminator) {
                            // HACK
                            return node.finishReturnStatement(null);
                        }

                        if (!match(';')) {
                            if (!match('}') && lookahead.type !== Token.EOF) {
                                argument = parseExpression();
                            }
                        }

                        consumeSemicolon();

                        return node.finishReturnStatement(argument);
                    }

                    // 12.10 The with statement

                    function parseWithStatement(node) {
                        var object, body;

                        if (strict) {
                            tolerateError(Messages.StrictModeWith);
                        }

                        expectKeyword('with');

                        expect('(');

                        object = parseExpression();

                        expect(')');

                        body = parseStatement();

                        return node.finishWithStatement(object, body);
                    }

                    // 12.10 The swith statement

                    function parseSwitchCase() {
                        var test, consequent = [],
 statement, node = new Node();

                        if (matchKeyword('default')) {
                            lex();
                            test = null;
                        } else {
                            expectKeyword('case');
                            test = parseExpression();
                        }
                        expect(':');

                        while (startIndex < length) {
                            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                                break;
                            }
                            statement = parseStatementListItem();
                            consequent.push(statement);
                        }

                        return node.finishSwitchCase(test, consequent);
                    }

                    function parseSwitchStatement(node) {
                        var discriminant, cases, clause, oldInSwitch, defaultFound;

                        expectKeyword('switch');

                        expect('(');

                        discriminant = parseExpression();

                        expect(')');

                        expect('{');

                        cases = [];

                        if (match('}')) {
                            lex();

                            return node.finishSwitchStatement(discriminant, cases);
                        }

                        oldInSwitch = state.inSwitch;
                        state.inSwitch = true;
                        defaultFound = false;

                        while (startIndex < length) {
                            if (match('}')) {
                                break;
                            }
                            clause = parseSwitchCase();

                            if (clause.test === null) {
                                if (defaultFound) {
                                    throwError(Messages.MultipleDefaultsInSwitch);
                                }
                                defaultFound = true;
                            }
                            cases.push(clause);
                        }

                        state.inSwitch = oldInSwitch;

                        expect('}');

                        return node.finishSwitchStatement(discriminant, cases);
                    }

                    // 12.13 The throw statement

                    function parseThrowStatement(node) {
                        var argument;

                        expectKeyword('throw');

                        if (hasLineTerminator) {
                            throwError(Messages.NewlineAfterThrow);
                        }

                        argument = parseExpression();

                        consumeSemicolon();

                        return node.finishThrowStatement(argument);
                    }

                    // 12.14 The try statement

                    function parseCatchClause() {
                        var param, body, node = new Node();

                        expectKeyword('catch');

                        expect('(');

                        if (match(')')) {
                            throwUnexpectedToken(lookahead);
                        }

                        param = parsePattern();

                        // 12.14.1
                        if (strict && isRestrictedWord(param.name)) {
                            tolerateError(Messages.StrictCatchVariable);
                        }

                        expect(')');
                        body = parseBlock();

                        return node.finishCatchClause(param, body);
                    }

                    function parseTryStatement(node) {
                        var block, handler = null,
 finalizer = null;

                        expectKeyword('try');

                        block = parseBlock();

                        if (matchKeyword('catch')) {
                            handler = parseCatchClause();
                        }

                        if (matchKeyword('finally')) {
                            lex();
                            finalizer = parseBlock();
                        }

                        if (!handler && !finalizer) {
                            throwError(Messages.NoCatchOrFinally);
                        }

                        return node.finishTryStatement(block, handler, finalizer);
                    }

                    // 12.15 The debugger statement

                    function parseDebuggerStatement(node) {
                        expectKeyword('debugger');

                        consumeSemicolon();

                        return node.finishDebuggerStatement();
                    }

                    // 12 Statements

                    function parseStatement() {
                        var type = lookahead.type,
                            expr,
                            labeledBody,
                            key,
                            node;

                        if (type === Token.EOF) {
                            throwUnexpectedToken(lookahead);
                        }

                        if (type === Token.Punctuator && lookahead.value === '{') {
                            return parseBlock();
                        }
                        isAssignmentTarget = isBindingElement = true;
                        node = new Node();

                        if (type === Token.Punctuator) {
                            switch (lookahead.value) {
                                case ';':
                                    return parseEmptyStatement(node);

                                case '(':
                                    return parseExpressionStatement(node);
                                default:
                                    break;
                            }
                        } else if (type === Token.Keyword) {
                            switch (lookahead.value) {
                                case 'break':
                                    return parseBreakStatement(node);

                                case 'continue':
                                    return parseContinueStatement(node);

                                case 'debugger':
                                    return parseDebuggerStatement(node);

                                case 'do':
                                    return parseDoWhileStatement(node);

                                case 'for':
                                    return parseForStatement(node);

                                case 'function':
                                    return parseFunctionDeclaration(node);

                                case 'if':
                                    return parseIfStatement(node);

                                case 'return':
                                    return parseReturnStatement(node);

                                case 'switch':
                                    return parseSwitchStatement(node);

                                case 'throw':
                                    return parseThrowStatement(node);

                                case 'try':
                                    return parseTryStatement(node);

                                case 'var':
                                    return parseVariableStatement(node);

                                case 'while':
                                    return parseWhileStatement(node);

                                case 'with':
                                    return parseWithStatement(node);
                                default:
                                    break;
                            }
                        }

                        expr = parseExpression();

                        // 12.12 Labelled Statements
                        if (expr.type === Syntax.Identifier && match(':')) {
                            lex();

                            key = '$' + expr.name;

                            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                                throwError(Messages.Redeclaration, 'Label', expr.name);
                            }

                            state.labelSet[key] = true;
                            labeledBody = parseStatement();
                            delete state.labelSet[key];

                            return node.finishLabeledStatement(expr, labeledBody);
                        }

                        consumeSemicolon();

                        return node.finishExpressionStatement(expr);
                    }

                    // 13 Function Definition

                    function parseFunctionSourceElements() {
                        var statement, body = [],
 token, directive, firstRestricted,
                            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
                            node = new Node();

                        expect('{');

                        while (startIndex < length) {
                            if (lookahead.type !== Token.StringLiteral) {
                                break;
                            }
                            token = lookahead;

                            statement = parseStatementListItem();
                            body.push(statement);

                            if (statement.expression.type !== Syntax.Literal) {
                                // this is not directive
                                break;
                            }
                            directive = source.slice(token.start + 1, token.end - 1);

                            if (directive === 'use strict') {
                                strict = true;

                                if (firstRestricted) {
                                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                                }
                            } else if (!firstRestricted && token.octal) {
                                firstRestricted = token;
                            }
                        }

                        oldLabelSet = state.labelSet;
                        oldInIteration = state.inIteration;
                        oldInSwitch = state.inSwitch;
                        oldInFunctionBody = state.inFunctionBody;
                        oldParenthesisCount = state.parenthesizedCount;

                        state.labelSet = {};
                        state.inIteration = false;
                        state.inSwitch = false;
                        state.inFunctionBody = true;
                        state.parenthesizedCount = 0;

                        while (startIndex < length) {
                            if (match('}')) {
                                break;
                            }
                            body.push(parseStatementListItem());
                        }

                        expect('}');

                        state.labelSet = oldLabelSet;
                        state.inIteration = oldInIteration;
                        state.inSwitch = oldInSwitch;
                        state.inFunctionBody = oldInFunctionBody;
                        state.parenthesizedCount = oldParenthesisCount;

                        return node.finishBlockStatement(body);
                    }

                    function validateParam(options, param, name) {
                        var key = '$' + name;

                        if (strict) {
                            if (isRestrictedWord(name)) {
                                options.stricted = param;
                                options.message = Messages.StrictParamName;
                            }

                            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                                options.stricted = param;
                                options.message = Messages.StrictParamDupe;
                            }
                        } else if (!options.firstRestricted) {
                            if (isRestrictedWord(name)) {
                                options.firstRestricted = param;
                                options.message = Messages.StrictParamName;
                            } else if (isStrictModeReservedWord(name)) {
                                options.firstRestricted = param;
                                options.message = Messages.StrictReservedWord;
                            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                                options.firstRestricted = param;
                                options.message = Messages.StrictParamDupe;
                            }
                        }
                        options.paramSet[key] = true;
                    }

                    function parseParam(options) {
                        var token, param, def;

                        token = lookahead;

                        if (token.value === '...') {
                            param = parseRestElement();
                            validateParam(options, param.argument, param.argument.name);
                            options.params.push(param);
                            options.defaults.push(null);

                            return false;
                        }

                        param = parsePatternWithDefault();
                        validateParam(options, token, token.value);

                        if (param.type === Syntax.AssignmentPattern) {
                            def = param.right;
                            param = param.left;
                            ++options.defaultCount;
                        }

                        options.params.push(param);
                        options.defaults.push(def);

                        return !match(')');
                    }

                    function parseParams(firstRestricted) {
                        var options;

                        options = {
                            params: [],
                            defaultCount: 0,
                            defaults: [],
                            firstRestricted: firstRestricted
                        };

                        expect('(');

                        if (!match(')')) {
                            options.paramSet = {};

                            while (startIndex < length) {
                                if (!parseParam(options)) {
                                    break;
                                }
                                expect(',');
                            }
                        }

                        expect(')');

                        if (options.defaultCount === 0) {
                            options.defaults = [];
                        }

                        return {
                            params: options.params,
                            defaults: options.defaults,
                            stricted: options.stricted,
                            firstRestricted: options.firstRestricted,
                            message: options.message
                        };
                    }

                    function parseFunctionDeclaration(node, identifierIsOptional) {
                        var id = null,
 params = [],
 defaults = [],
 body, token, stricted, tmp, firstRestricted, message, previousStrict;

                        expectKeyword('function');

                        if (!identifierIsOptional || !match('(')) {
                            token = lookahead;
                            id = parseVariableIdentifier();

                            if (strict) {
                                if (isRestrictedWord(token.value)) {
                                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                                }
                            } else if (isRestrictedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictFunctionName;
                            } else if (isStrictModeReservedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictReservedWord;
                            }
                        }

                        tmp = parseParams(firstRestricted);
                        params = tmp.params;
                        defaults = tmp.defaults;
                        stricted = tmp.stricted;
                        firstRestricted = tmp.firstRestricted;

                        if (tmp.message) {
                            message = tmp.message;
                        }

                        previousStrict = strict;
                        body = parseFunctionSourceElements();

                        if (strict && firstRestricted) {
                            throwUnexpectedToken(firstRestricted, message);
                        }

                        if (strict && stricted) {
                            tolerateUnexpectedToken(stricted, message);
                        }
                        strict = previousStrict;

                        return node.finishFunctionDeclaration(id, params, defaults, body);
                    }

                    function parseFunctionExpression() {
                        var token, id = null,
 stricted, firstRestricted, message, tmp,
                            params = [],
 defaults = [],
 body, previousStrict, node = new Node();

                        expectKeyword('function');

                        if (!match('(')) {
                            token = lookahead;
                            id = parseVariableIdentifier();

                            if (strict) {
                                if (isRestrictedWord(token.value)) {
                                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                                }
                            } else if (isRestrictedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictFunctionName;
                            } else if (isStrictModeReservedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictReservedWord;
                            }
                        }

                        tmp = parseParams(firstRestricted);
                        params = tmp.params;
                        defaults = tmp.defaults;
                        stricted = tmp.stricted;
                        firstRestricted = tmp.firstRestricted;

                        if (tmp.message) {
                            message = tmp.message;
                        }

                        previousStrict = strict;
                        body = parseFunctionSourceElements();

                        if (strict && firstRestricted) {
                            throwUnexpectedToken(firstRestricted, message);
                        }

                        if (strict && stricted) {
                            tolerateUnexpectedToken(stricted, message);
                        }
                        strict = previousStrict;

                        return node.finishFunctionExpression(id, params, defaults, body);
                    }

                    function parseClassBody() {
                        var classBody, token, isStatic, hasConstructor = false,
 body, method, computed, key;

                        classBody = new Node();

                        expect('{');
                        body = [];

                        while (!match('}')) {
                            if (match(';')) {
                                lex();
                            } else {
                                method = new Node();
                                token = lookahead;
                                isStatic = false;
                                computed = match('[');
                                key = parseObjectPropertyKey();

                                if (key.name === 'static' && lookaheadPropertyName()) {
                                    token = lookahead;
                                    isStatic = true;
                                    computed = match('[');
                                    key = parseObjectPropertyKey();
                                }
                                method = tryParseMethodDefinition(token, key, computed, method);

                                if (method) {
                                    method['static'] = isStatic;

                                    if (method.kind === 'init') {
                                        method.kind = 'method';
                                    }

                                    if (!isStatic) {
                                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
                                            if (method.kind !== 'method' || !method.method || method.value.generator) {
                                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                                            }

                                            if (hasConstructor) {
                                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
                                            } else {
                                                hasConstructor = true;
                                            }
                                            method.kind = 'constructor';
                                        }
                                    } else if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
                                        throwUnexpectedToken(token, Messages.StaticPrototype);
                                    }
                                    method.type = Syntax.MethodDefinition;
                                    delete method.method;
                                    delete method.shorthand;
                                    body.push(method);
                                } else {
                                    throwUnexpectedToken(lookahead);
                                }
                            }
                        }
                        lex();

                        return classBody.finishClassBody(body);
                    }

                    function parseClassDeclaration(identifierIsOptional) {
                        var id = null,
 superClass = null,
 classNode = new Node(),
 classBody, previousStrict = strict;

                        strict = true;

                        expectKeyword('class');

                        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
                            id = parseVariableIdentifier();
                        }

                        if (matchKeyword('extends')) {
                            lex();
                            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
                        }
                        classBody = parseClassBody();
                        strict = previousStrict;

                        return classNode.finishClassDeclaration(id, superClass, classBody);
                    }

                    function parseClassExpression() {
                        var id = null,
 superClass = null,
 classNode = new Node(),
 classBody, previousStrict = strict;

                        strict = true;

                        expectKeyword('class');

                        if (lookahead.type === Token.Identifier) {
                            id = parseVariableIdentifier();
                        }

                        if (matchKeyword('extends')) {
                            lex();
                            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
                        }
                        classBody = parseClassBody();
                        strict = previousStrict;

                        return classNode.finishClassExpression(id, superClass, classBody);
                    }

                    // Modules grammar from:
                    // people.mozilla.org/~jorendorff/es6-draft.html

                    function parseModuleSpecifier() {
                        var node = new Node();

                        if (lookahead.type !== Token.StringLiteral) {
                            throwError(Messages.InvalidModuleSpecifier);
                        }

                        return node.finishLiteral(lex());
                    }

                    function parseExportSpecifier() {
                        var exported, local, node = new Node(),
 def;

                        if (matchKeyword('default')) {
                            // export {default} from 'something';
                            def = new Node();
                            lex();
                            local = def.finishIdentifier('default');
                        } else {
                            local = parseVariableIdentifier();
                        }

                        if (matchContextualKeyword('as')) {
                            lex();
                            exported = parseNonComputedProperty();
                        }

                        return node.finishExportSpecifier(local, exported);
                    }

                    function parseExportNamedDeclaration(node) {
                        var declaration = null,
                            isExportFromIdentifier,
                            src = null,
 specifiers = [];

                        // non-default export
                        if (lookahead.type === Token.Keyword) {
                            // covers:
                            // export var f = 1;
                            switch (lookahead.value) {
                                case 'let':
                                case 'const':
                                case 'var':
                                case 'class':
                                case 'function':
                                    declaration = parseStatementListItem();

                                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
                            }
                        }

                        expect('{');

                        if (!match('}')) {
                            do {
                                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
                                specifiers.push(parseExportSpecifier());
                            } while (match(',') && lex());
                        }
                        expect('}');

                        if (matchContextualKeyword('from')) {
                            // covering:
                            // export {default} from 'foo';
                            // export {foo} from 'foo';
                            lex();
                            src = parseModuleSpecifier();
                            consumeSemicolon();
                        } else if (isExportFromIdentifier) {
                            // covering:
                            // export {default}; // missing fromClause
                            throwError(lookahead.value ?
                                Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
                        } else {
                            // cover
                            // export {foo};
                            consumeSemicolon();
                        }

                        return node.finishExportNamedDeclaration(declaration, specifiers, src);
                    }

                    function parseExportDefaultDeclaration(node) {
                        var declaration = null,
                            expression = null;

                        // covers:
                        // export default ...
                        expectKeyword('default');

                        if (matchKeyword('function')) {
                            // covers:
                            // export default function foo () {}
                            // export default function () {}
                            declaration = parseFunctionDeclaration(new Node(), true);

                            return node.finishExportDefaultDeclaration(declaration);
                        }

                        if (matchKeyword('class')) {
                            declaration = parseClassDeclaration(true);

                            return node.finishExportDefaultDeclaration(declaration);
                        }

                        if (matchContextualKeyword('from')) {
                            throwError(Messages.UnexpectedToken, lookahead.value);
                        }

                        // covers:
                        // export default {};
                        // export default [];
                        // export default (1 + 2);
                        if (match('{')) {
                            expression = parseObjectInitialiser();
                        } else if (match('[')) {
                            expression = parseArrayInitialiser();
                        } else {
                            expression = parseAssignmentExpression();
                        }
                        consumeSemicolon();

                        return node.finishExportDefaultDeclaration(expression);
                    }

                    function parseExportAllDeclaration(node) {
                        var src;

                        // covers:
                        // export * from 'foo';
                        expect('*');

                        if (!matchContextualKeyword('from')) {
                            throwError(lookahead.value ?
                                Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
                        }
                        lex();
                        src = parseModuleSpecifier();
                        consumeSemicolon();

                        return node.finishExportAllDeclaration(src);
                    }

                    function parseExportDeclaration() {
                        var node = new Node();

                        if (state.inFunctionBody) {
                            throwError(Messages.IllegalExportDeclaration);
                        }

                        expectKeyword('export');

                        if (matchKeyword('default')) {
                            return parseExportDefaultDeclaration(node);
                        }

                        if (match('*')) {
                            return parseExportAllDeclaration(node);
                        }

                        return parseExportNamedDeclaration(node);
                    }

                    function parseImportSpecifier() {
                        // import {<foo as bar>} ...;
                        var local, imported, node = new Node();

                        imported = parseNonComputedProperty();

                        if (matchContextualKeyword('as')) {
                            lex();
                            local = parseVariableIdentifier();
                        }

                        return node.finishImportSpecifier(local, imported);
                    }

                    function parseNamedImports() {
                        var specifiers = [];
                        // {foo, bar as bas}

                        expect('{');

                        if (!match('}')) {
                            do {
                                specifiers.push(parseImportSpecifier());
                            } while (match(',') && lex());
                        }
                        expect('}');

                        return specifiers;
                    }

                    function parseImportDefaultSpecifier() {
                        // import <foo> ...;
                        var local, node = new Node();

                        local = parseNonComputedProperty();

                        return node.finishImportDefaultSpecifier(local);
                    }

                    function parseImportNamespaceSpecifier() {
                        // import <* as foo> ...;
                        var local, node = new Node();

                        expect('*');

                        if (!matchContextualKeyword('as')) {
                            throwError(Messages.NoAsAfterImportNamespace);
                        }
                        lex();
                        local = parseNonComputedProperty();

                        return node.finishImportNamespaceSpecifier(local);
                    }

                    function parseImportDeclaration() {
                        var specifiers, src, node = new Node();

                        if (state.inFunctionBody) {
                            throwError(Messages.IllegalImportDeclaration);
                        }

                        expectKeyword('import');
                        specifiers = [];

                        if (lookahead.type === Token.StringLiteral) {
                            // covers:
                            // import 'foo';
                            src = parseModuleSpecifier();
                            consumeSemicolon();

                            return node.finishImportDeclaration(specifiers, src);
                        }

                        if (!matchKeyword('default') && isIdentifierName(lookahead)) {
                            // covers:
                            // import foo
                            // import foo, ...
                            specifiers.push(parseImportDefaultSpecifier());

                            if (match(',')) {
                                lex();
                            }
                        }

                        if (match('*')) {
                            // covers:
                            // import foo, * as foo
                            // import * as foo
                            specifiers.push(parseImportNamespaceSpecifier());
                        } else if (match('{')) {
                            // covers:
                            // import foo, {bar}
                            // import {bar}
                            specifiers = specifiers.concat(parseNamedImports());
                        }

                        if (!matchContextualKeyword('from')) {
                            throwError(lookahead.value ?
                                Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
                        }
                        lex();
                        src = parseModuleSpecifier();
                        consumeSemicolon();

                        return node.finishImportDeclaration(specifiers, src);
                    }

                    // 14 Program

                    function parseScriptBody() {
                        var statement, body = [],
 token, directive, firstRestricted;

                        while (startIndex < length) {
                            token = lookahead;

                            if (token.type !== Token.StringLiteral) {
                                break;
                            }

                            statement = parseStatementListItem();
                            body.push(statement);

                            if (statement.expression.type !== Syntax.Literal) {
                                // this is not directive
                                break;
                            }
                            directive = source.slice(token.start + 1, token.end - 1);

                            if (directive === 'use strict') {
                                strict = true;

                                if (firstRestricted) {
                                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                                }
                            } else if (!firstRestricted && token.octal) {
                                firstRestricted = token;
                            }
                        }

                        while (startIndex < length) {
                            statement = parseStatementListItem();
                            /* istanbul ignore if */
                            if (typeof statement === 'undefined') {
                                break;
                            }
                            body.push(statement);
                        }

                        return body;
                    }

                    function parseProgram() {
                        var body, node;

                        peek();
                        node = new Node();

                        body = parseScriptBody();

                        return node.finishProgram(body);
                    }

                    function filterTokenLocation() {
                        var i, entry, token, tokens = [];

                        for (i = 0; i < extra.tokens.length; ++i) {
                            entry = extra.tokens[i];
                            token = {
                                type: entry.type,
                                value: entry.value
                            };

                            if (entry.regex) {
                                token.regex = {
                                    pattern: entry.regex.pattern,
                                    flags: entry.regex.flags
                                };
                            }

                            if (extra.range) {
                                token.range = entry.range;
                            }

                            if (extra.loc) {
                                token.loc = entry.loc;
                            }
                            tokens.push(token);
                        }

                        extra.tokens = tokens;
                    }

                    function tokenize(code, options) {
                        var toString,
                            tokens;

                        toString = String;

                        if (typeof code !== 'string' && !(code instanceof String)) {
                            code = toString(code);
                        }

                        source = code;
                        index = 0;
                        lineNumber = source.length > 0 ? 1 : 0;
                        lineStart = 0;
                        startIndex = index;
                        startLineNumber = lineNumber;
                        startLineStart = lineStart;
                        length = source.length;
                        lookahead = null;
                        state = {
                            allowIn: true,
                            labelSet: {},
                            inFunctionBody: false,
                            inIteration: false,
                            inSwitch: false,
                            lastCommentStart: -1,
                            curlyStack: []
                        };

                        extra = {};

                        // Options matching.
                        options = options || {};

                        // Of course we collect tokens here.
                        options.tokens = true;
                        extra.tokens = [];
                        extra.tokenize = true;
                        // The following two fields are necessary to compute the Regex tokens.
                        extra.openParenToken = -1;
                        extra.openCurlyToken = -1;

                        extra.range = typeof options.range === 'boolean' && options.range;
                        extra.loc = typeof options.loc === 'boolean' && options.loc;

                        if (typeof options.comment === 'boolean' && options.comment) {
                            extra.comments = [];
                        }

                        if (typeof options.tolerant === 'boolean' && options.tolerant) {
                            extra.errors = [];
                        }

                        try {
                            peek();

                            if (lookahead.type === Token.EOF) {
                                return extra.tokens;
                            }

                            lex();

                            while (lookahead.type !== Token.EOF) {
                                try {
                                    lex();
                                } catch (lexError) {
                                    if (extra.errors) {
                                        recordError(lexError);
                                        // We have to break on the first error
                                        // to avoid infinite loops.
                                        break;
                                    } else {
                                        throw lexError;
                                    }
                                }
                            }

                            filterTokenLocation();
                            tokens = extra.tokens;

                            if (typeof extra.comments !== 'undefined') {
                                tokens.comments = extra.comments;
                            }

                            if (typeof extra.errors !== 'undefined') {
                                tokens.errors = extra.errors;
                            }
                        } catch (e) {
                            throw e;
                        } finally {
                            extra = {};
                        }

                        return tokens;
                    }

                    function parse(code, options) {
                        var program, toString;

                        toString = String;

                        if (typeof code !== 'string' && !(code instanceof String)) {
                            code = toString(code);
                        }

                        source = code;
                        index = 0;
                        lineNumber = source.length > 0 ? 1 : 0;
                        lineStart = 0;
                        startIndex = index;
                        startLineNumber = lineNumber;
                        startLineStart = lineStart;
                        length = source.length;
                        lookahead = null;
                        state = {
                            allowIn: true,
                            labelSet: {},
                            inFunctionBody: false,
                            inIteration: false,
                            inSwitch: false,
                            lastCommentStart: -1,
                            curlyStack: []
                        };
                        sourceType = 'script';
                        strict = false;

                        extra = {};

                        if (typeof options !== 'undefined') {
                            extra.range = typeof options.range === 'boolean' && options.range;
                            extra.loc = typeof options.loc === 'boolean' && options.loc;
                            extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;

                            if (extra.loc && options.source !== null && options.source !== undefined) {
                                extra.source = toString(options.source);
                            }

                            if (typeof options.tokens === 'boolean' && options.tokens) {
                                extra.tokens = [];
                            }

                            if (typeof options.comment === 'boolean' && options.comment) {
                                extra.comments = [];
                            }

                            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                                extra.errors = [];
                            }

                            if (extra.attachComment) {
                                extra.range = true;
                                extra.comments = [];
                                extra.bottomRightStack = [];
                                extra.trailingComments = [];
                                extra.leadingComments = [];
                            }

                            if (options.sourceType === 'module') {
                                // very restrictive condition for now
                                sourceType = options.sourceType;
                                strict = true;
                            }
                        }

                        try {
                            program = parseProgram();

                            if (typeof extra.comments !== 'undefined') {
                                program.comments = extra.comments;
                            }

                            if (typeof extra.tokens !== 'undefined') {
                                filterTokenLocation();
                                program.tokens = extra.tokens;
                            }

                            if (typeof extra.errors !== 'undefined') {
                                program.errors = extra.errors;
                            }
                        } catch (e) {
                            throw e;
                        } finally {
                            extra = {};
                        }

                        return program;
                    }

                    // Sync with *.json manifests.
                    exports.version = '2.2.0';

                    exports.tokenize = tokenize;

                    exports.parse = parse;

                    // Deep copy.
                    /* istanbul ignore next */
                    exports.Syntax = (function () {
                        var name, types = {};

                        if (typeof Object.create === 'function') {
                            types = Object.create(null);
                        }

                        for (name in Syntax) {
                            if (Syntax.hasOwnProperty(name)) {
                                types[name] = Syntax[name];
                            }
                        }

                        if (typeof Object.freeze === 'function') {
                            Object.freeze(types);
                        }

                        return types;
                    }());

                }));

                /* vim: set sw=4 ts=4 et tw=80 : */

            },{}],52: [function (require, module, exports) {
                var baseIndexOf = require('../internal/baseIndexOf'),
                    binaryIndex = require('../internal/binaryIndex');

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeMax = Math.max;

                /**
                 * Gets the index at which the first occurrence of `value` is found in `array`
                 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                 * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
                 * performs a faster binary search.
                 *
                 * @static
                 * @memberOf _
                 * @category Array
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {boolean|number} [fromIndex=0] The index to search from or `true`
                 *  to perform a binary search on a sorted array.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 * @example
                 *
                 * _.indexOf([1, 2, 1, 2], 2);
                 * // => 1
                 *
                 * // using `fromIndex`
                 * _.indexOf([1, 2, 1, 2], 2, 2);
                 * // => 3
                 *
                 * // performing a binary search
                 * _.indexOf([1, 1, 2, 2], 2, true);
                 * // => 2
                 */
                function indexOf(array, value, fromIndex) {
                    var length = array ? array.length : 0;

                    if (!length) {
                        return -1;
                    }

                    if (typeof fromIndex == 'number') {
                        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
                    } else if (fromIndex) {
                        var index = binaryIndex(array, value);

                        if (index < length &&
                            (value === value ? value === array[index] : array[index] !== array[index])) {
                            return index;
                        }

                        return -1;
                    }

                    return baseIndexOf(array, value, fromIndex || 0);
                }

                module.exports = indexOf;

            },{
                '../internal/baseIndexOf': 81,'../internal/binaryIndex': 95
            }],53: [function (require, module, exports) {
                /**
                 * Gets the last element of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @category Array
                 * @param {Array} array The array to query.
                 * @returns {*} Returns the last element of `array`.
                 * @example
                 *
                 * _.last([1, 2, 3]);
                 * // => 3
                 */
                function last(array) {
                    var length = array ? array.length : 0;

                    return length ? array[length - 1] : undefined;
                }

                module.exports = last;

            },{}],54: [function (require, module, exports) {
                var LazyWrapper = require('../internal/LazyWrapper'),
                    LodashWrapper = require('../internal/LodashWrapper'),
                    baseLodash = require('../internal/baseLodash'),
                    isArray = require('../lang/isArray'),
                    isObjectLike = require('../internal/isObjectLike'),
                    wrapperClone = require('../internal/wrapperClone');

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /**
                 * Creates a `lodash` object which wraps `value` to enable implicit chaining.
                 * Methods that operate on and return arrays, collections, and functions can
                 * be chained together. Methods that retrieve a single value or may return a
                 * primitive value will automatically end the chain returning the unwrapped
                 * value. Explicit chaining may be enabled using `_.chain`. The execution of
                 * chained methods is lazy, that is, execution is deferred until `_#value`
                 * is implicitly or explicitly called.
                 *
                 * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
                 * fusion is an optimization strategy which merge iteratee calls; this can help
                 * to avoid the creation of intermediate data structures and greatly reduce the
                 * number of iteratee executions.
                 *
                 * Chaining is supported in custom builds as long as the `_#value` method is
                 * directly or indirectly included in the build.
                 *
                 * In addition to lodash methods, wrappers have `Array` and `String` methods.
                 *
                 * The wrapper `Array` methods are:
                 * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
                 * `splice`, and `unshift`
                 *
                 * The wrapper `String` methods are:
                 * `replace` and `split`
                 *
                 * The wrapper methods that support shortcut fusion are:
                 * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
                 * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
                 * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
                 * and `where`
                 *
                 * The chainable wrapper methods are:
                 * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
                 * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
                 * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
                 * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
                 * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
                 * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
                 * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
                 * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
                 * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
                 * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
                 * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
                 * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
                 * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
                 * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
                 * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
                 * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
                 * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
                 *
                 * The wrapper methods that are **not** chainable by default are:
                 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
                 * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
                 * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
                 * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
                 * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
                 * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
                 * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
                 * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
                 * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
                 * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
                 * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
                 * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
                 * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
                 * `unescape`, `uniqueId`, `value`, and `words`
                 *
                 * The wrapper method `sample` will return a wrapped value when `n` is provided,
                 * otherwise an unwrapped value is returned.
                 *
                 * @name _
                 * @constructor
                 * @category Chain
                 * @param {*} value The value to wrap in a `lodash` instance.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var wrapped = _([1, 2, 3]);
                 *
                 * // returns an unwrapped value
                 * wrapped.reduce(function(total, n) {
         *   return total + n;
         * });
                 * // => 6
                 *
                 * // returns a wrapped value
                 * var squares = wrapped.map(function(n) {
         *   return n * n;
         * });
                 *
                 * _.isArray(squares);
                 * // => false
                 *
                 * _.isArray(squares.value());
                 * // => true
                 */
                function lodash(value) {
                    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                        if (value instanceof LodashWrapper) {
                            return value;
                        }

                        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                            return wrapperClone(value);
                        }
                    }

                    return new LodashWrapper(value);
                }

                // Ensure wrappers are instances of `baseLodash`.
                lodash.prototype = baseLodash.prototype;

                module.exports = lodash;

            },{
                '../internal/LazyWrapper': 63,'../internal/LodashWrapper': 64,'../internal/baseLodash': 85,'../internal/isObjectLike': 129,'../internal/wrapperClone': 140,'../lang/isArray': 143
            }],55: [function (require, module, exports) {
                module.exports = require('./forEach');

            },{
                './forEach': 57
            }],56: [function (require, module, exports) {
                var baseEach = require('../internal/baseEach'),
                    createFind = require('../internal/createFind');

                /**
                 * Iterates over elements of `collection`, returning the first element
                 * `predicate` returns truthy for. The predicate is bound to `thisArg` and
                 * invoked with three arguments: (value, index|key, collection).
                 *
                 * If a property name is provided for `predicate` the created `_.property`
                 * style callback returns the property value of the given element.
                 *
                 * If a value is also provided for `thisArg` the created `_.matchesProperty`
                 * style callback returns `true` for elements that have a matching property
                 * value, else `false`.
                 *
                 * If an object is provided for `predicate` the created `_.matches` style
                 * callback returns `true` for elements that have the properties of the given
                 * object, else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @alias detect
                 * @category Collection
                 * @param {Array|Object|string} collection The collection to search.
                 * @param {Function|Object|string} [predicate=_.identity] The function invoked
                 *  per iteration.
                 * @param {*} [thisArg] The `this` binding of `predicate`.
                 * @returns {*} Returns the matched element, else `undefined`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'age': 36, 'active': true },
                 *   { 'user': 'fred',    'age': 40, 'active': false },
                 *   { 'user': 'pebbles', 'age': 1,  'active': true }
                 * ];
                 *
                 * _.result(_.find(users, function(chr) {
         *   return chr.age < 40;
         * }), 'user');
                 * // => 'barney'
                 *
                 * // using the `_.matches` callback shorthand
                 * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
                 * // => 'pebbles'
                 *
                 * // using the `_.matchesProperty` callback shorthand
                 * _.result(_.find(users, 'active', false), 'user');
                 * // => 'fred'
                 *
                 * // using the `_.property` callback shorthand
                 * _.result(_.find(users, 'active'), 'user');
                 * // => 'barney'
                 */
                var find = createFind(baseEach);

                module.exports = find;

            },{
                '../internal/baseEach': 74,'../internal/createFind': 105
            }],57: [function (require, module, exports) {
                var arrayEach = require('../internal/arrayEach'),
                    baseEach = require('../internal/baseEach'),
                    createForEach = require('../internal/createForEach');

                /**
                 * Iterates over elements of `collection` invoking `iteratee` for each element.
                 * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                 * (value, index|key, collection). Iteratee functions may exit iteration early
                 * by explicitly returning `false`.
                 *
                 * **Note:** As with other "Collections" methods, objects with a "length" property
                 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
                 * may be used for object iteration.
                 *
                 * @static
                 * @memberOf _
                 * @alias each
                 * @category Collection
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @param {*} [thisArg] The `this` binding of `iteratee`.
                 * @returns {Array|Object|string} Returns `collection`.
                 * @example
                 *
                 * _([1, 2]).forEach(function(n) {
         *   console.log(n);
         * }).value();
                 * // => logs each value from left to right and returns the array
                 *
                 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
         *   console.log(n, key);
         * });
                 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
                 */
                var forEach = createForEach(arrayEach, baseEach);

                module.exports = forEach;

            },{
                '../internal/arrayEach': 66,'../internal/baseEach': 74,'../internal/createForEach': 106
            }],58: [function (require, module, exports) {
                var baseIndexOf = require('../internal/baseIndexOf'),
                    getLength = require('../internal/getLength'),
                    isArray = require('../lang/isArray'),
                    isIterateeCall = require('../internal/isIterateeCall'),
                    isLength = require('../internal/isLength'),
                    isString = require('../lang/isString'),
                    values = require('../object/values');

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeMax = Math.max;

                /**
                 * Checks if `value` is in `collection` using
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                 * from the end of `collection`.
                 *
                 * @static
                 * @memberOf _
                 * @alias contains, include
                 * @category Collection
                 * @param {Array|Object|string} collection The collection to search.
                 * @param {*} target The value to search for.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
                 * @returns {boolean} Returns `true` if a matching element is found, else `false`.
                 * @example
                 *
                 * _.includes([1, 2, 3], 1);
                 * // => true
                 *
                 * _.includes([1, 2, 3], 1, 2);
                 * // => false
                 *
                 * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
                 * // => true
                 *
                 * _.includes('pebbles', 'eb');
                 * // => true
                 */
                function includes(collection, target, fromIndex, guard) {
                    var length = collection ? getLength(collection) : 0;

                    if (!isLength(length)) {
                        collection = values(collection);
                        length = collection.length;
                    }

                    if (typeof fromIndex != 'number' || guard && isIterateeCall(target, fromIndex, guard)) {
                        fromIndex = 0;
                    } else {
                        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex || 0;
                    }

                    return typeof collection == 'string' || !isArray(collection) && isString(collection) ?
                        fromIndex <= length && collection.indexOf(target, fromIndex) > -1
                        : !!length && baseIndexOf(collection, target, fromIndex) > -1;
                }

                module.exports = includes;

            },{
                '../internal/baseIndexOf': 81,'../internal/getLength': 115,'../internal/isIterateeCall': 125,'../internal/isLength': 128,'../lang/isArray': 143,'../lang/isString': 149,'../object/values': 155
            }],59: [function (require, module, exports) {
                var arrayMap = require('../internal/arrayMap'),
                    baseCallback = require('../internal/baseCallback'),
                    baseMap = require('../internal/baseMap'),
                    isArray = require('../lang/isArray');

                /**
                 * Creates an array of values by running each element in `collection` through
                 * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
                 * arguments: (value, index|key, collection).
                 *
                 * If a property name is provided for `iteratee` the created `_.property`
                 * style callback returns the property value of the given element.
                 *
                 * If a value is also provided for `thisArg` the created `_.matchesProperty`
                 * style callback returns `true` for elements that have a matching property
                 * value, else `false`.
                 *
                 * If an object is provided for `iteratee` the created `_.matches` style
                 * callback returns `true` for elements that have the properties of the given
                 * object, else `false`.
                 *
                 * Many lodash methods are guarded to work as iteratees for methods like
                 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                 *
                 * The guarded methods are:
                 * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
                 * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
                 * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
                 * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
                 * `sum`, `uniq`, and `words`
                 *
                 * @static
                 * @memberOf _
                 * @alias collect
                 * @category Collection
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                 *  per iteration.
                 * @param {*} [thisArg] The `this` binding of `iteratee`.
                 * @returns {Array} Returns the new mapped array.
                 * @example
                 *
                 * function timesThree(n) {
         *   return n * 3;
         * }
                 *
                 * _.map([1, 2], timesThree);
                 * // => [3, 6]
                 *
                 * _.map({ 'a': 1, 'b': 2 }, timesThree);
                 * // => [3, 6] (iteration order is not guaranteed)
                 *
                 * var users = [
                 *   { 'user': 'barney' },
                 *   { 'user': 'fred' }
                 * ];
                 *
                 * // using the `_.property` callback shorthand
                 * _.map(users, 'user');
                 * // => ['barney', 'fred']
                 */
                function map(collection, iteratee, thisArg) {
                    var func = isArray(collection) ? arrayMap : baseMap;

                    iteratee = baseCallback(iteratee, thisArg, 3);

                    return func(collection, iteratee);
                }

                module.exports = map;

            },{
                '../internal/arrayMap': 67,'../internal/baseCallback': 70,'../internal/baseMap': 86,'../lang/isArray': 143
            }],60: [function (require, module, exports) {
                var getNative = require('../internal/getNative');

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeNow = getNative(Date, 'now');

                /**
                 * Gets the number of milliseconds that have elapsed since the Unix epoch
                 * (1 January 1970 00:00:00 UTC).
                 *
                 * @static
                 * @memberOf _
                 * @category Date
                 * @example
                 *
                 * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
                 * // => logs the number of milliseconds it took for the deferred function to be invoked
                 */
                var now = nativeNow || function () {
                        return new Date().getTime();
                    };

                module.exports = now;

            },{
                '../internal/getNative': 117
            }],61: [function (require, module, exports) {
                var createWrapper = require('../internal/createWrapper'),
                    replaceHolders = require('../internal/replaceHolders'),
                    restParam = require('./restParam');

                /** Used to compose bitmasks for wrapper metadata. */
                var BIND_FLAG = 1,
                    PARTIAL_FLAG = 32;

                /**
                 * Creates a function that invokes `func` with the `this` binding of `thisArg`
                 * and prepends any additional `_.bind` arguments to those provided to the
                 * bound function.
                 *
                 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
                 * may be used as a placeholder for partially applied arguments.
                 *
                 * **Note:** Unlike native `Function#bind` this method does not set the "length"
                 * property of bound functions.
                 *
                 * @static
                 * @memberOf _
                 * @category Function
                 * @param {Function} func The function to bind.
                 * @param {*} thisArg The `this` binding of `func`.
                 * @param {...*} [partials] The arguments to be partially applied.
                 * @returns {Function} Returns the new bound function.
                 * @example
                 *
                 * var greet = function(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * };
                 *
                 * var object = { 'user': 'fred' };
                 *
                 * var bound = _.bind(greet, object, 'hi');
                 * bound('!');
                 * // => 'hi fred!'
                 *
                 * // using placeholders
                 * var bound = _.bind(greet, object, _, '!');
                 * bound('hi');
                 * // => 'hi fred!'
                 */
                var bind = restParam(function (func, thisArg, partials) {
                    var bitmask = BIND_FLAG;

                    if (partials.length) {
                        var holders = replaceHolders(partials, bind.placeholder);

                        bitmask |= PARTIAL_FLAG;
                    }

                    return createWrapper(func, bitmask, thisArg, partials, holders);
                });

                // Assign default placeholders.
                bind.placeholder = {};

                module.exports = bind;

            },{
                '../internal/createWrapper': 109,'../internal/replaceHolders': 135,'./restParam': 62
            }],62: [function (require, module, exports) {
                /** Used as the `TypeError` message for "Functions" methods. */
                var FUNC_ERROR_TEXT = 'Expected a function';

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeMax = Math.max;

                /**
                 * Creates a function that invokes `func` with the `this` binding of the
                 * created function and arguments from `start` and beyond provided as an array.
                 *
                 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
                 *
                 * @static
                 * @memberOf _
                 * @category Function
                 * @param {Function} func The function to apply a rest parameter to.
                 * @param {number} [start=func.length-1] The start position of the rest parameter.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var say = _.restParam(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
                 *
                 * say('hello', 'fred', 'barney', 'pebbles');
                 * // => 'hello fred, barney, & pebbles'
                 */
                function restParam(func, start) {
                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    start = nativeMax(start === undefined ? func.length - 1 : +start || 0, 0);

                    return function () {
                        var args = arguments,
                            index = -1,
                            length = nativeMax(args.length - start, 0),
                            rest = Array(length);

                        while (++index < length) {
                            rest[index] = args[start + index];
                        }

                        switch (start) {
                            case 0: return func.call(this, rest);

                            case 1: return func.call(this, args[0], rest);

                            case 2: return func.call(this, args[0], args[1], rest);
                        }
                        var otherArgs = Array(start + 1);

                        index = -1;

                        while (++index < start) {
                            otherArgs[index] = args[index];
                        }
                        otherArgs[start] = rest;

                        return func.apply(this, otherArgs);
                    };
                }

                module.exports = restParam;

            },{}],63: [function (require, module, exports) {
                var baseCreate = require('./baseCreate'),
                    baseLodash = require('./baseLodash');

                /** Used as references for `-Infinity` and `Infinity`. */
                var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

                /**
                 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
                 *
                 * @private
                 * @param {*} value The value to wrap.
                 */
                function LazyWrapper(value) {
                    this.__wrapped__ = value;
                    this.__actions__ = [];
                    this.__dir__ = 1;
                    this.__filtered__ = false;
                    this.__iteratees__ = [];
                    this.__takeCount__ = POSITIVE_INFINITY;
                    this.__views__ = [];
                }

                LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                LazyWrapper.prototype.constructor = LazyWrapper;

                module.exports = LazyWrapper;

            },{
                './baseCreate': 73,'./baseLodash': 85
            }],64: [function (require, module, exports) {
                var baseCreate = require('./baseCreate'),
                    baseLodash = require('./baseLodash');

                /**
                 * The base constructor for creating `lodash` wrapper objects.
                 *
                 * @private
                 * @param {*} value The value to wrap.
                 * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
                 * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
                 */
                function LodashWrapper(value, chainAll, actions) {
                    this.__wrapped__ = value;
                    this.__actions__ = actions || [];
                    this.__chain__ = !!chainAll;
                }

                LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                LodashWrapper.prototype.constructor = LodashWrapper;

                module.exports = LodashWrapper;

            },{
                './baseCreate': 73,'./baseLodash': 85
            }],65: [function (require, module, exports) {
                /**
                 * Copies the values of `source` to `array`.
                 *
                 * @private
                 * @param {Array} source The array to copy values from.
                 * @param {Array} [array=[]] The array to copy values to.
                 * @returns {Array} Returns `array`.
                 */
                function arrayCopy(source, array) {
                    var index = -1,
                        length = source.length;

                    array || (array = Array(length));

                    while (++index < length) {
                        array[index] = source[index];
                    }

                    return array;
                }

                module.exports = arrayCopy;

            },{}],66: [function (require, module, exports) {
                /**
                 * A specialized version of `_.forEach` for arrays without support for callback
                 * shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array} Returns `array`.
                 */
                function arrayEach(array, iteratee) {
                    var index = -1,
                        length = array.length;

                    while (++index < length) {
                        if (iteratee(array[index], index, array) === false) {
                            break;
                        }
                    }

                    return array;
                }

                module.exports = arrayEach;

            },{}],67: [function (require, module, exports) {
                /**
                 * A specialized version of `_.map` for arrays without support for callback
                 * shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array} Returns the new mapped array.
                 */
                function arrayMap(array, iteratee) {
                    var index = -1,
                        length = array.length,
                        result = Array(length);

                    while (++index < length) {
                        result[index] = iteratee(array[index], index, array);
                    }

                    return result;
                }

                module.exports = arrayMap;

            },{}],68: [function (require, module, exports) {
                /**
                 * A specialized version of `_.some` for arrays without support for callback
                 * shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} predicate The function invoked per iteration.
                 * @returns {boolean} Returns `true` if any element passes the predicate check,
                 *  else `false`.
                 */
                function arraySome(array, predicate) {
                    var index = -1,
                        length = array.length;

                    while (++index < length) {
                        if (predicate(array[index], index, array)) {
                            return true;
                        }
                    }

                    return false;
                }

                module.exports = arraySome;

            },{}],69: [function (require, module, exports) {
                var baseCopy = require('./baseCopy'),
                    keys = require('../object/keys');

                /**
                 * The base implementation of `_.assign` without support for argument juggling,
                 * multiple sources, and `customizer` functions.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @returns {Object} Returns `object`.
                 */
                function baseAssign(object, source) {
                    return source == null ?
                        object
                        : baseCopy(source, keys(source), object);
                }

                module.exports = baseAssign;

            },{
                '../object/keys': 152,'./baseCopy': 72
            }],70: [function (require, module, exports) {
                var baseMatches = require('./baseMatches'),
                    baseMatchesProperty = require('./baseMatchesProperty'),
                    bindCallback = require('./bindCallback'),
                    identity = require('../utility/identity'),
                    property = require('../utility/property');

                /**
                 * The base implementation of `_.callback` which supports specifying the
                 * number of arguments to provide to `func`.
                 *
                 * @private
                 * @param {*} [func=_.identity] The value to convert to a callback.
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {number} [argCount] The number of arguments to provide to `func`.
                 * @returns {Function} Returns the callback.
                 */
                function baseCallback(func, thisArg, argCount) {
                    var type = typeof func;

                    if (type == 'function') {
                        return thisArg === undefined ?
                            func
                            : bindCallback(func, thisArg, argCount);
                    }

                    if (func == null) {
                        return identity;
                    }

                    if (type == 'object') {
                        return baseMatches(func);
                    }

                    return thisArg === undefined ?
                        property(func)
                        : baseMatchesProperty(func, thisArg);
                }

                module.exports = baseCallback;

            },{
                '../utility/identity': 157,'../utility/property': 159,'./baseMatches': 87,'./baseMatchesProperty': 88,'./bindCallback': 97
            }],71: [function (require, module, exports) {
                var arrayCopy = require('./arrayCopy'),
                    arrayEach = require('./arrayEach'),
                    baseAssign = require('./baseAssign'),
                    baseForOwn = require('./baseForOwn'),
                    initCloneArray = require('./initCloneArray'),
                    initCloneByTag = require('./initCloneByTag'),
                    initCloneObject = require('./initCloneObject'),
                    isArray = require('../lang/isArray'),
                    isHostObject = require('./isHostObject'),
                    isObject = require('../lang/isObject');

                /** `Object#toString` result references. */
                var argsTag = '[object Arguments]',
                    arrayTag = '[object Array]',
                    boolTag = '[object Boolean]',
                    dateTag = '[object Date]',
                    errorTag = '[object Error]',
                    funcTag = '[object Function]',
                    mapTag = '[object Map]',
                    numberTag = '[object Number]',
                    objectTag = '[object Object]',
                    regexpTag = '[object RegExp]',
                    setTag = '[object Set]',
                    stringTag = '[object String]',
                    weakMapTag = '[object WeakMap]';

                var arrayBufferTag = '[object ArrayBuffer]',
                    float32Tag = '[object Float32Array]',
                    float64Tag = '[object Float64Array]',
                    int8Tag = '[object Int8Array]',
                    int16Tag = '[object Int16Array]',
                    int32Tag = '[object Int32Array]',
                    uint8Tag = '[object Uint8Array]',
                    uint8ClampedTag = '[object Uint8ClampedArray]',
                    uint16Tag = '[object Uint16Array]',
                    uint32Tag = '[object Uint32Array]';

                /** Used to identify `toStringTag` values supported by `_.clone`. */
                var cloneableTags = {};

                cloneableTags[argsTag] = cloneableTags[arrayTag] =
                    cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
                        cloneableTags[dateTag] = cloneableTags[float32Tag] =
                            cloneableTags[float64Tag] = cloneableTags[int8Tag] =
                                cloneableTags[int16Tag] = cloneableTags[int32Tag] =
                                    cloneableTags[numberTag] = cloneableTags[objectTag] =
                                        cloneableTags[regexpTag] = cloneableTags[stringTag] =
                                            cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                                                cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] =
                    cloneableTags[mapTag] = cloneableTags[setTag] =
                        cloneableTags[weakMapTag] = false;

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /**
                 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objToString = objectProto.toString;

                /**
                 * The base implementation of `_.clone` without support for argument juggling
                 * and `this` binding `customizer` functions.
                 *
                 * @private
                 * @param {*} value The value to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @param {Function} [customizer] The function to customize cloning values.
                 * @param {string} [key] The key of `value`.
                 * @param {Object} [object] The object `value` belongs to.
                 * @param {Array} [stackA=[]] Tracks traversed source objects.
                 * @param {Array} [stackB=[]] Associates clones with source counterparts.
                 * @returns {*} Returns the cloned value.
                 */
                function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
                    var result;

                    if (customizer) {
                        result = object ? customizer(value, key, object) : customizer(value);
                    }

                    if (result !== undefined) {
                        return result;
                    }

                    if (!isObject(value)) {
                        return value;
                    }
                    var isArr = isArray(value);

                    if (isArr) {
                        result = initCloneArray(value);

                        if (!isDeep) {
                            return arrayCopy(value, result);
                        }
                    } else {
                        var tag = objToString.call(value),
                            isFunc = tag == funcTag;

                        if (tag == objectTag || tag == argsTag || isFunc && !object) {
                            if (isHostObject(value)) {
                                return object ? value : {};
                            }
                            result = initCloneObject(isFunc ? {} : value);

                            if (!isDeep) {
                                return baseAssign(result, value);
                            }
                        } else {
                            return cloneableTags[tag] ?
                                initCloneByTag(value, tag, isDeep)
                                : object ? value : {};
                        }
                    }
                    // Check for circular references and return its corresponding clone.
                    stackA || (stackA = []);
                    stackB || (stackB = []);

                    var length = stackA.length;

                    while (length--) {
                        if (stackA[length] == value) {
                            return stackB[length];
                        }
                    }
                    // Add the source value to the stack of traversed objects and associate it with its clone.
                    stackA.push(value);
                    stackB.push(result);

                    // Recursively populate clone (susceptible to call stack limits).
                    (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
                        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
                    });

                    return result;
                }

                module.exports = baseClone;

            },{
                '../lang/isArray': 143,'../lang/isObject': 147,'./arrayCopy': 65,'./arrayEach': 66,'./baseAssign': 69,'./baseForOwn': 79,'./initCloneArray': 119,'./initCloneByTag': 120,'./initCloneObject': 121,'./isHostObject': 123
            }],72: [function (require, module, exports) {
                /**
                 * Copies properties of `source` to `object`.
                 *
                 * @private
                 * @param {Object} source The object to copy properties from.
                 * @param {Array} props The property names to copy.
                 * @param {Object} [object={}] The object to copy properties to.
                 * @returns {Object} Returns `object`.
                 */
                function baseCopy(source, props, object) {
                    object || (object = {});

                    var index = -1,
                        length = props.length;

                    while (++index < length) {
                        var key = props[index];

                        object[key] = source[key];
                    }

                    return object;
                }

                module.exports = baseCopy;

            },{}],73: [function (require, module, exports) {
                var isObject = require('../lang/isObject');

                /**
                 * The base implementation of `_.create` without support for assigning
                 * properties to the created object.
                 *
                 * @private
                 * @param {Object} prototype The object to inherit from.
                 * @returns {Object} Returns the new object.
                 */
                var baseCreate = (function () {
                    function object() {}

                    return function (prototype) {
                        if (isObject(prototype)) {
                            object.prototype = prototype;
                            var result = new object;

                            object.prototype = undefined;
                        }

                        return result || {};
                    };
                }());

                module.exports = baseCreate;

            },{
                '../lang/isObject': 147
            }],74: [function (require, module, exports) {
                var baseForOwn = require('./baseForOwn'),
                    createBaseEach = require('./createBaseEach');

                /**
                 * The base implementation of `_.forEach` without support for callback
                 * shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array|Object|string} Returns `collection`.
                 */
                var baseEach = createBaseEach(baseForOwn);

                module.exports = baseEach;

            },{
                './baseForOwn': 79,'./createBaseEach': 101
            }],75: [function (require, module, exports) {
                /**
                 * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
                 * without support for callback shorthands and `this` binding, which iterates
                 * over `collection` using the provided `eachFunc`.
                 *
                 * @private
                 * @param {Array|Object|string} collection The collection to search.
                 * @param {Function} predicate The function invoked per iteration.
                 * @param {Function} eachFunc The function to iterate over `collection`.
                 * @param {boolean} [retKey] Specify returning the key of the found element
                 *  instead of the element itself.
                 * @returns {*} Returns the found element or its key, else `undefined`.
                 */
                function baseFind(collection, predicate, eachFunc, retKey) {
                    var result;

                    eachFunc(collection, function (value, key, collection) {
                        if (predicate(value, key, collection)) {
                            result = retKey ? key : value;

                            return false;
                        }
                    });

                    return result;
                }

                module.exports = baseFind;

            },{}],76: [function (require, module, exports) {
                /**
                 * The base implementation of `_.findIndex` and `_.findLastIndex` without
                 * support for callback shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {Function} predicate The function invoked per iteration.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function baseFindIndex(array, predicate, fromRight) {
                    var length = array.length,
                        index = fromRight ? length : -1;

                    while (fromRight ? index-- : ++index < length) {
                        if (predicate(array[index], index, array)) {
                            return index;
                        }
                    }

                    return -1;
                }

                module.exports = baseFindIndex;

            },{}],77: [function (require, module, exports) {
                var createBaseFor = require('./createBaseFor');

                /**
                 * The base implementation of `baseForIn` and `baseForOwn` which iterates
                 * over `object` properties returned by `keysFunc` invoking `iteratee` for
                 * each property. Iteratee functions may exit iteration early by explicitly
                 * returning `false`.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @param {Function} keysFunc The function to get the keys of `object`.
                 * @returns {Object} Returns `object`.
                 */
                var baseFor = createBaseFor();

                module.exports = baseFor;

            },{
                './createBaseFor': 102
            }],78: [function (require, module, exports) {
                var baseFor = require('./baseFor'),
                    keysIn = require('../object/keysIn');

                /**
                 * The base implementation of `_.forIn` without support for callback
                 * shorthands and `this` binding.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 */
                function baseForIn(object, iteratee) {
                    return baseFor(object, iteratee, keysIn);
                }

                module.exports = baseForIn;

            },{
                '../object/keysIn': 153,'./baseFor': 77
            }],79: [function (require, module, exports) {
                var baseFor = require('./baseFor'),
                    keys = require('../object/keys');

                /**
                 * The base implementation of `_.forOwn` without support for callback
                 * shorthands and `this` binding.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 */
                function baseForOwn(object, iteratee) {
                    return baseFor(object, iteratee, keys);
                }

                module.exports = baseForOwn;

            },{
                '../object/keys': 152,'./baseFor': 77
            }],80: [function (require, module, exports) {
                var toObject = require('./toObject');

                /**
                 * The base implementation of `get` without support for string paths
                 * and default values.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array} path The path of the property to get.
                 * @param {string} [pathKey] The key representation of path.
                 * @returns {*} Returns the resolved value.
                 */
                function baseGet(object, path, pathKey) {
                    if (object == null) {
                        return;
                    }
                    object = toObject(object);

                    if (pathKey !== undefined && pathKey in object) {
                        path = [pathKey];
                    }
                    var index = 0,
                        length = path.length;

                    while (object != null && index < length) {
                        object = toObject(object)[path[index++]];
                    }

                    return index && index == length ? object : undefined;
                }

                module.exports = baseGet;

            },{
                './toObject': 138
            }],81: [function (require, module, exports) {
                var indexOfNaN = require('./indexOfNaN');

                /**
                 * The base implementation of `_.indexOf` without support for binary searches.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {number} fromIndex The index to search from.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function baseIndexOf(array, value, fromIndex) {
                    if (value !== value) {
                        return indexOfNaN(array, fromIndex);
                    }
                    var index = fromIndex - 1,
                        length = array.length;

                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }

                    return -1;
                }

                module.exports = baseIndexOf;

            },{
                './indexOfNaN': 118
            }],82: [function (require, module, exports) {
                var baseIsEqualDeep = require('./baseIsEqualDeep'),
                    isObject = require('../lang/isObject'),
                    isObjectLike = require('./isObjectLike');

                /**
                 * The base implementation of `_.isEqual` without support for `this` binding
                 * `customizer` functions.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @param {Function} [customizer] The function to customize comparing values.
                 * @param {boolean} [isLoose] Specify performing partial comparisons.
                 * @param {Array} [stackA] Tracks traversed `value` objects.
                 * @param {Array} [stackB] Tracks traversed `other` objects.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 */
                function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
                    if (value === other) {
                        return true;
                    }

                    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
                        return value !== value && other !== other;
                    }

                    return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
                }

                module.exports = baseIsEqual;

            },{
                '../lang/isObject': 147,'./baseIsEqualDeep': 83,'./isObjectLike': 129
            }],83: [function (require, module, exports) {
                var equalArrays = require('./equalArrays'),
                    equalByTag = require('./equalByTag'),
                    equalObjects = require('./equalObjects'),
                    isArray = require('../lang/isArray'),
                    isHostObject = require('./isHostObject'),
                    isTypedArray = require('../lang/isTypedArray');

                /** `Object#toString` result references. */
                var argsTag = '[object Arguments]',
                    arrayTag = '[object Array]',
                    objectTag = '[object Object]';

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /**
                 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objToString = objectProto.toString;

                /**
                 * A specialized version of `baseIsEqual` for arrays and objects which performs
                 * deep comparisons and tracks traversed objects enabling objects with circular
                 * references to be compared.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} [customizer] The function to customize comparing objects.
                 * @param {boolean} [isLoose] Specify performing partial comparisons.
                 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
                 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                    var objIsArr = isArray(object),
                        othIsArr = isArray(other),
                        objTag = arrayTag,
                        othTag = arrayTag;

                    if (!objIsArr) {
                        objTag = objToString.call(object);

                        if (objTag == argsTag) {
                            objTag = objectTag;
                        } else if (objTag != objectTag) {
                            objIsArr = isTypedArray(object);
                        }
                    }

                    if (!othIsArr) {
                        othTag = objToString.call(other);

                        if (othTag == argsTag) {
                            othTag = objectTag;
                        } else if (othTag != objectTag) {
                            othIsArr = isTypedArray(other);
                        }
                    }
                    var objIsObj = objTag == objectTag && !isHostObject(object),
                        othIsObj = othTag == objectTag && !isHostObject(other),
                        isSameTag = objTag == othTag;

                    if (isSameTag && !(objIsArr || objIsObj)) {
                        return equalByTag(object, other, objTag);
                    }

                    if (!isLoose) {
                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                        if (objIsWrapped || othIsWrapped) {
                            return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                        }
                    }

                    if (!isSameTag) {
                        return false;
                    }
                    // Assume cyclic values are equal.
                    // For more information on detecting circular references see https://es5.github.io/#JO.
                    stackA || (stackA = []);
                    stackB || (stackB = []);

                    var length = stackA.length;

                    while (length--) {
                        if (stackA[length] == object) {
                            return stackB[length] == other;
                        }
                    }
                    // Add `object` and `other` to the stack of traversed objects.
                    stackA.push(object);
                    stackB.push(other);

                    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

                    stackA.pop();
                    stackB.pop();

                    return result;
                }

                module.exports = baseIsEqualDeep;

            },{
                '../lang/isArray': 143,'../lang/isTypedArray': 150,'./equalArrays': 110,'./equalByTag': 111,'./equalObjects': 112,'./isHostObject': 123
            }],84: [function (require, module, exports) {
                var baseIsEqual = require('./baseIsEqual'),
                    toObject = require('./toObject');

                /**
                 * The base implementation of `_.isMatch` without support for callback
                 * shorthands and `this` binding.
                 *
                 * @private
                 * @param {Object} object The object to inspect.
                 * @param {Array} matchData The propery names, values, and compare flags to match.
                 * @param {Function} [customizer] The function to customize comparing objects.
                 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                 */
                function baseIsMatch(object, matchData, customizer) {
                    var index = matchData.length,
                        length = index,
                        noCustomizer = !customizer;

                    if (object == null) {
                        return !length;
                    }
                    object = toObject(object);

                    while (index--) {
                        var data = matchData[index];

                        if (noCustomizer && data[2] ?
                                data[1] !== object[data[0]]
                                : !(data[0] in object)
                        ) {
                            return false;
                        }
                    }

                    while (++index < length) {
                        data = matchData[index];
                        var key = data[0],
                            objValue = object[key],
                            srcValue = data[1];

                        if (noCustomizer && data[2]) {
                            if (objValue === undefined && !(key in object)) {
                                return false;
                            }
                        } else {
                            var result = customizer ? customizer(objValue, srcValue, key) : undefined;

                            if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                module.exports = baseIsMatch;

            },{
                './baseIsEqual': 82,'./toObject': 138
            }],85: [function (require, module, exports) {
                /**
                 * The function whose prototype all chaining wrappers inherit from.
                 *
                 * @private
                 */
                function baseLodash() {
                    // No operation performed.
                }

                module.exports = baseLodash;

            },{}],86: [function (require, module, exports) {
                var baseEach = require('./baseEach'),
                    isArrayLike = require('./isArrayLike');

                /**
                 * The base implementation of `_.map` without support for callback shorthands
                 * and `this` binding.
                 *
                 * @private
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array} Returns the new mapped array.
                 */
                function baseMap(collection, iteratee) {
                    var index = -1,
                        result = isArrayLike(collection) ? Array(collection.length) : [];

                    baseEach(collection, function (value, key, collection) {
                        result[++index] = iteratee(value, key, collection);
                    });

                    return result;
                }

                module.exports = baseMap;

            },{
                './baseEach': 74,'./isArrayLike': 122
            }],87: [function (require, module, exports) {
                var baseIsMatch = require('./baseIsMatch'),
                    getMatchData = require('./getMatchData'),
                    toObject = require('./toObject');

                /**
                 * The base implementation of `_.matches` which does not clone `source`.
                 *
                 * @private
                 * @param {Object} source The object of property values to match.
                 * @returns {Function} Returns the new function.
                 */
                function baseMatches(source) {
                    var matchData = getMatchData(source);

                    if (matchData.length == 1 && matchData[0][2]) {
                        var key = matchData[0][0],
                            value = matchData[0][1];

                        return function (object) {
                            if (object == null) {
                                return false;
                            }
                            object = toObject(object);

                            return object[key] === value && (value !== undefined || key in object);
                        };
                    }

                    return function (object) {
                        return baseIsMatch(object, matchData);
                    };
                }

                module.exports = baseMatches;

            },{
                './baseIsMatch': 84,'./getMatchData': 116,'./toObject': 138
            }],88: [function (require, module, exports) {
                var baseGet = require('./baseGet'),
                    baseIsEqual = require('./baseIsEqual'),
                    baseSlice = require('./baseSlice'),
                    isArray = require('../lang/isArray'),
                    isKey = require('./isKey'),
                    isStrictComparable = require('./isStrictComparable'),
                    last = require('../array/last'),
                    toObject = require('./toObject'),
                    toPath = require('./toPath');

                /**
                 * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
                 *
                 * @private
                 * @param {string} path The path of the property to get.
                 * @param {*} srcValue The value to compare.
                 * @returns {Function} Returns the new function.
                 */
                function baseMatchesProperty(path, srcValue) {
                    var isArr = isArray(path),
                        isCommon = isKey(path) && isStrictComparable(srcValue),
                        pathKey = path + '';

                    path = toPath(path);

                    return function (object) {
                        if (object == null) {
                            return false;
                        }
                        var key = pathKey;

                        object = toObject(object);

                        if ((isArr || !isCommon) && !(key in object)) {
                            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));

                            if (object == null) {
                                return false;
                            }
                            key = last(path);
                            object = toObject(object);
                        }

                        return object[key] === srcValue ?
                            srcValue !== undefined || key in object
                            : baseIsEqual(srcValue, object[key], undefined, true);
                    };
                }

                module.exports = baseMatchesProperty;

            },{
                '../array/last': 53,'../lang/isArray': 143,'./baseGet': 80,'./baseIsEqual': 82,'./baseSlice': 92,'./isKey': 126,'./isStrictComparable': 130,'./toObject': 138,'./toPath': 139
            }],89: [function (require, module, exports) {
                var toObject = require('./toObject');

                /**
                 * The base implementation of `_.property` without support for deep paths.
                 *
                 * @private
                 * @param {string} key The key of the property to get.
                 * @returns {Function} Returns the new function.
                 */
                function baseProperty(key) {
                    return function (object) {
                        return object == null ? undefined : toObject(object)[key];
                    };
                }

                module.exports = baseProperty;

            },{
                './toObject': 138
            }],90: [function (require, module, exports) {
                var baseGet = require('./baseGet'),
                    toPath = require('./toPath');

                /**
                 * A specialized version of `baseProperty` which supports deep paths.
                 *
                 * @private
                 * @param {Array|string} path The path of the property to get.
                 * @returns {Function} Returns the new function.
                 */
                function basePropertyDeep(path) {
                    var pathKey = path + '';

                    path = toPath(path);

                    return function (object) {
                        return baseGet(object, path, pathKey);
                    };
                }

                module.exports = basePropertyDeep;

            },{
                './baseGet': 80,'./toPath': 139
            }],91: [function (require, module, exports) {
                var identity = require('../utility/identity'),
                    metaMap = require('./metaMap');

                /**
                 * The base implementation of `setData` without support for hot loop detection.
                 *
                 * @private
                 * @param {Function} func The function to associate metadata with.
                 * @param {*} data The metadata.
                 * @returns {Function} Returns `func`.
                 */
                var baseSetData = !metaMap ? identity : function (func, data) {
                    metaMap.set(func, data);

                    return func;
                };

                module.exports = baseSetData;

            },{
                '../utility/identity': 157,'./metaMap': 132
            }],92: [function (require, module, exports) {
                /**
                 * The base implementation of `_.slice` without an iteratee call guard.
                 *
                 * @private
                 * @param {Array} array The array to slice.
                 * @param {number} [start=0] The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns the slice of `array`.
                 */
                function baseSlice(array, start, end) {
                    var index = -1,
                        length = array.length;

                    start = start == null ? 0 : +start || 0;

                    if (start < 0) {
                        start = -start > length ? 0 : length + start;
                    }
                    end = end === undefined || end > length ? length : +end || 0;

                    if (end < 0) {
                        end += length;
                    }
                    length = start > end ? 0 : end - start >>> 0;
                    start >>>= 0;

                    var result = Array(length);

                    while (++index < length) {
                        result[index] = array[index + start];
                    }

                    return result;
                }

                module.exports = baseSlice;

            },{}],93: [function (require, module, exports) {
                /**
                 * Converts `value` to a string if it's not one. An empty string is returned
                 * for `null` or `undefined` values.
                 *
                 * @private
                 * @param {*} value The value to process.
                 * @returns {string} Returns the string.
                 */
                function baseToString(value) {
                    return value == null ? '' : value + '';
                }

                module.exports = baseToString;

            },{}],94: [function (require, module, exports) {
                /**
                 * The base implementation of `_.values` and `_.valuesIn` which creates an
                 * array of `object` property values corresponding to the property names
                 * of `props`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array} props The property names to get values for.
                 * @returns {Object} Returns the array of property values.
                 */
                function baseValues(object, props) {
                    var index = -1,
                        length = props.length,
                        result = Array(length);

                    while (++index < length) {
                        result[index] = object[props[index]];
                    }

                    return result;
                }

                module.exports = baseValues;

            },{}],95: [function (require, module, exports) {
                var binaryIndexBy = require('./binaryIndexBy'),
                    identity = require('../utility/identity');

                /** Used as references for the maximum length and index of an array. */
                var MAX_ARRAY_LENGTH = 4294967295,
                    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

                /**
                 * Performs a binary search of `array` to determine the index at which `value`
                 * should be inserted into `array` in order to maintain its sort order.
                 *
                 * @private
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {boolean} [retHighest] Specify returning the highest qualified index.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 */
                function binaryIndex(array, value, retHighest) {
                    var low = 0,
                        high = array ? array.length : low;

                    if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                        while (low < high) {
                            var mid = low + high >>> 1,
                                computed = array[mid];

                            if ((retHighest ? computed <= value : computed < value) && computed !== null) {
                                low = mid + 1;
                            } else {
                                high = mid;
                            }
                        }

                        return high;
                    }

                    return binaryIndexBy(array, value, identity, retHighest);
                }

                module.exports = binaryIndex;

            },{
                '../utility/identity': 157,'./binaryIndexBy': 96
            }],96: [function (require, module, exports) {
                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeFloor = Math.floor,
                    nativeMin = Math.min;

                /** Used as references for the maximum length and index of an array. */
                var MAX_ARRAY_LENGTH = 4294967295,
                    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;

                /**
                 * This function is like `binaryIndex` except that it invokes `iteratee` for
                 * `value` and each element of `array` to compute their sort ranking. The
                 * iteratee is invoked with one argument; (value).
                 *
                 * @private
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @param {boolean} [retHighest] Specify returning the highest qualified index.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 */
                function binaryIndexBy(array, value, iteratee, retHighest) {
                    value = iteratee(value);

                    var low = 0,
                        high = array ? array.length : 0,
                        valIsNaN = value !== value,
                        valIsNull = value === null,
                        valIsUndef = value === undefined;

                    while (low < high) {
                        var mid = nativeFloor((low + high) / 2),
                            computed = iteratee(array[mid]),
                            isDef = computed !== undefined,
                            isReflexive = computed === computed;

                        if (valIsNaN) {
                            var setLow = isReflexive || retHighest;
                        } else if (valIsNull) {
                            setLow = isReflexive && isDef && (retHighest || computed != null);
                        } else if (valIsUndef) {
                            setLow = isReflexive && (retHighest || isDef);
                        } else if (computed == null) {
                            setLow = false;
                        } else {
                            setLow = retHighest ? computed <= value : computed < value;
                        }

                        if (setLow) {
                            low = mid + 1;
                        } else {
                            high = mid;
                        }
                    }

                    return nativeMin(high, MAX_ARRAY_INDEX);
                }

                module.exports = binaryIndexBy;

            },{}],97: [function (require, module, exports) {
                var identity = require('../utility/identity');

                /**
                 * A specialized version of `baseCallback` which only supports `this` binding
                 * and specifying the number of arguments to provide to `func`.
                 *
                 * @private
                 * @param {Function} func The function to bind.
                 * @param {*} thisArg The `this` binding of `func`.
                 * @param {number} [argCount] The number of arguments to provide to `func`.
                 * @returns {Function} Returns the callback.
                 */
                function bindCallback(func, thisArg, argCount) {
                    if (typeof func != 'function') {
                        return identity;
                    }

                    if (thisArg === undefined) {
                        return func;
                    }

                    switch (argCount) {
                        case 1: return function (value) {
                                return func.call(thisArg, value);
                            };

                        case 3: return function (value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };

                        case 4: return function (accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };

                        case 5: return function (value, other, key, object, source) {
                                return func.call(thisArg, value, other, key, object, source);
                            };
                    }

                    return function () {
                        return func.apply(thisArg, arguments);
                    };
                }

                module.exports = bindCallback;

            },{
                '../utility/identity': 157
            }],98: [function (require, module, exports) {
                (function (global) {
                    /** Native method references. */
                    var ArrayBuffer = global.ArrayBuffer,
                        Uint8Array = global.Uint8Array;

                    /**
                     * Creates a clone of the given array buffer.
                     *
                     * @private
                     * @param {ArrayBuffer} buffer The array buffer to clone.
                     * @returns {ArrayBuffer} Returns the cloned array buffer.
                     */
                    function bufferClone(buffer) {
                        var result = new ArrayBuffer(buffer.byteLength),
                            view = new Uint8Array(result);

                        view.set(new Uint8Array(buffer));

                        return result;
                    }

                    module.exports = bufferClone;

                }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
                //# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sb2Rhc2gtY29tcGF0L2ludGVybmFsL2J1ZmZlckNsb25lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgQXJyYXlCdWZmZXIgPSBnbG9iYWwuQXJyYXlCdWZmZXIsXG4gICAgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZ2l2ZW4gYXJyYXkgYnVmZmVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpLFxuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG5cbiAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVmZmVyQ2xvbmU7XG4iXX0=
            },{}],99: [function (require, module, exports) {
                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeMax = Math.max;

                /**
                 * Creates an array that is the composition of partially applied arguments,
                 * placeholders, and provided arguments into a single array of arguments.
                 *
                 * @private
                 * @param {Array|Object} args The provided arguments.
                 * @param {Array} partials The arguments to prepend to those provided.
                 * @param {Array} holders The `partials` placeholder indexes.
                 * @returns {Array} Returns the new array of composed arguments.
                 */
                function composeArgs(args, partials, holders) {
                    var holdersLength = holders.length,
                        argsIndex = -1,
                        argsLength = nativeMax(args.length - holdersLength, 0),
                        leftIndex = -1,
                        leftLength = partials.length,
                        result = Array(leftLength + argsLength);

                    while (++leftIndex < leftLength) {
                        result[leftIndex] = partials[leftIndex];
                    }

                    while (++argsIndex < holdersLength) {
                        result[holders[argsIndex]] = args[argsIndex];
                    }

                    while (argsLength--) {
                        result[leftIndex++] = args[argsIndex++];
                    }

                    return result;
                }

                module.exports = composeArgs;

            },{}],100: [function (require, module, exports) {
                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeMax = Math.max;

                /**
                 * This function is like `composeArgs` except that the arguments composition
                 * is tailored for `_.partialRight`.
                 *
                 * @private
                 * @param {Array|Object} args The provided arguments.
                 * @param {Array} partials The arguments to append to those provided.
                 * @param {Array} holders The `partials` placeholder indexes.
                 * @returns {Array} Returns the new array of composed arguments.
                 */
                function composeArgsRight(args, partials, holders) {
                    var holdersIndex = -1,
                        holdersLength = holders.length,
                        argsIndex = -1,
                        argsLength = nativeMax(args.length - holdersLength, 0),
                        rightIndex = -1,
                        rightLength = partials.length,
                        result = Array(argsLength + rightLength);

                    while (++argsIndex < argsLength) {
                        result[argsIndex] = args[argsIndex];
                    }
                    var offset = argsIndex;

                    while (++rightIndex < rightLength) {
                        result[offset + rightIndex] = partials[rightIndex];
                    }

                    while (++holdersIndex < holdersLength) {
                        result[offset + holders[holdersIndex]] = args[argsIndex++];
                    }

                    return result;
                }

                module.exports = composeArgsRight;

            },{}],101: [function (require, module, exports) {
                var getLength = require('./getLength'),
                    isLength = require('./isLength'),
                    toObject = require('./toObject');

                /**
                 * Creates a `baseEach` or `baseEachRight` function.
                 *
                 * @private
                 * @param {Function} eachFunc The function to iterate over a collection.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new base function.
                 */
                function createBaseEach(eachFunc, fromRight) {
                    return function (collection, iteratee) {
                        var length = collection ? getLength(collection) : 0;

                        if (!isLength(length)) {
                            return eachFunc(collection, iteratee);
                        }
                        var index = fromRight ? length : -1,
                            iterable = toObject(collection);

                        while (fromRight ? index-- : ++index < length) {
                            if (iteratee(iterable[index], index, iterable) === false) {
                                break;
                            }
                        }

                        return collection;
                    };
                }

                module.exports = createBaseEach;

            },{
                './getLength': 115,'./isLength': 128,'./toObject': 138
            }],102: [function (require, module, exports) {
                var toObject = require('./toObject');

                /**
                 * Creates a base function for `_.forIn` or `_.forInRight`.
                 *
                 * @private
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new base function.
                 */
                function createBaseFor(fromRight) {
                    return function (object, iteratee, keysFunc) {
                        var iterable = toObject(object),
                            props = keysFunc(object),
                            length = props.length,
                            index = fromRight ? length : -1;

                        while (fromRight ? index-- : ++index < length) {
                            var key = props[index];

                            if (iteratee(iterable[key], key, iterable) === false) {
                                break;
                            }
                        }

                        return object;
                    };
                }

                module.exports = createBaseFor;

            },{
                './toObject': 138
            }],103: [function (require, module, exports) {
                (function (global) {
                    var createCtorWrapper = require('./createCtorWrapper');

                    /**
                     * Creates a function that wraps `func` and invokes it with the `this`
                     * binding of `thisArg`.
                     *
                     * @private
                     * @param {Function} func The function to bind.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @returns {Function} Returns the new bound function.
                     */
                    function createBindWrapper(func, thisArg) {
                        var Ctor = createCtorWrapper(func);

                        function wrapper() {
                            var fn = this && this !== global && this instanceof wrapper ? Ctor : func;

                            return fn.apply(thisArg, arguments);
                        }

                        return wrapper;
                    }

                    module.exports = createBindWrapper;

                }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
                //# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sb2Rhc2gtY29tcGF0L2ludGVybmFsL2NyZWF0ZUJpbmRXcmFwcGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3JlYXRlQ3RvcldyYXBwZXIgPSByZXF1aXJlKCcuL2NyZWF0ZUN0b3JXcmFwcGVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIGFuZCBpbnZva2VzIGl0IHdpdGggdGhlIGB0aGlzYFxuICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJpbmRXcmFwcGVyKGZ1bmMsIHRoaXNBcmcpIHtcbiAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IGdsb2JhbCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCaW5kV3JhcHBlcjtcbiJdfQ==
            },{
                './createCtorWrapper': 104
            }],104: [function (require, module, exports) {
                var baseCreate = require('./baseCreate'),
                    isObject = require('../lang/isObject');

                /**
                 * Creates a function that produces an instance of `Ctor` regardless of
                 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
                 *
                 * @private
                 * @param {Function} Ctor The constructor to wrap.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createCtorWrapper(Ctor) {
                    return function () {
                        // Use a `switch` statement to work with class constructors.
                        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                        // for more details.
                        var args = arguments;

                        switch (args.length) {
                            case 0: return new Ctor;

                            case 1: return new Ctor(args[0]);

                            case 2: return new Ctor(args[0], args[1]);

                            case 3: return new Ctor(args[0], args[1], args[2]);

                            case 4: return new Ctor(args[0], args[1], args[2], args[3]);

                            case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);

                            case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

                            case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                        }
                        var thisBinding = baseCreate(Ctor.prototype),
                            result = Ctor.apply(thisBinding, args);

                        // Mimic the constructor's `return` behavior.
                        // See https://es5.github.io/#x13.2.2 for more details.
                        return isObject(result) ? result : thisBinding;
                    };
                }

                module.exports = createCtorWrapper;

            },{
                '../lang/isObject': 147,'./baseCreate': 73
            }],105: [function (require, module, exports) {
                var baseCallback = require('./baseCallback'),
                    baseFind = require('./baseFind'),
                    baseFindIndex = require('./baseFindIndex'),
                    isArray = require('../lang/isArray');

                /**
                 * Creates a `_.find` or `_.findLast` function.
                 *
                 * @private
                 * @param {Function} eachFunc The function to iterate over a collection.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new find function.
                 */
                function createFind(eachFunc, fromRight) {
                    return function (collection, predicate, thisArg) {
                        predicate = baseCallback(predicate, thisArg, 3);

                        if (isArray(collection)) {
                            var index = baseFindIndex(collection, predicate, fromRight);

                            return index > -1 ? collection[index] : undefined;
                        }

                        return baseFind(collection, predicate, eachFunc);
                    };
                }

                module.exports = createFind;

            },{
                '../lang/isArray': 143,'./baseCallback': 70,'./baseFind': 75,'./baseFindIndex': 76
            }],106: [function (require, module, exports) {
                var bindCallback = require('./bindCallback'),
                    isArray = require('../lang/isArray');

                /**
                 * Creates a function for `_.forEach` or `_.forEachRight`.
                 *
                 * @private
                 * @param {Function} arrayFunc The function to iterate over an array.
                 * @param {Function} eachFunc The function to iterate over a collection.
                 * @returns {Function} Returns the new each function.
                 */
                function createForEach(arrayFunc, eachFunc) {
                    return function (collection, iteratee, thisArg) {
                        return typeof iteratee == 'function' && thisArg === undefined && isArray(collection) ?
                            arrayFunc(collection, iteratee)
                            : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
                    };
                }

                module.exports = createForEach;

            },{
                '../lang/isArray': 143,'./bindCallback': 97
            }],107: [function (require, module, exports) {
                (function (global) {
                    var arrayCopy = require('./arrayCopy'),
                        composeArgs = require('./composeArgs'),
                        composeArgsRight = require('./composeArgsRight'),
                        createCtorWrapper = require('./createCtorWrapper'),
                        isLaziable = require('./isLaziable'),
                        reorder = require('./reorder'),
                        replaceHolders = require('./replaceHolders'),
                        setData = require('./setData');

                    /** Used to compose bitmasks for wrapper metadata. */
                    var BIND_FLAG = 1,
                        BIND_KEY_FLAG = 2,
                        CURRY_BOUND_FLAG = 4,
                        CURRY_FLAG = 8,
                        CURRY_RIGHT_FLAG = 16,
                        PARTIAL_FLAG = 32,
                        PARTIAL_RIGHT_FLAG = 64,
                        ARY_FLAG = 128;

                    /* Native method references for those with the same name as other `lodash` methods. */
                    var nativeMax = Math.max;

                    /**
                     * Creates a function that wraps `func` and invokes it with optional `this`
                     * binding of, partial application, and currying.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
                     * @param {Array} [holders] The `partials` placeholder indexes.
                     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
                     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
                     * @param {Array} [argPos] The argument positions of the new function.
                     * @param {number} [ary] The arity cap of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        var isAry = bitmask & ARY_FLAG,
                            isBind = bitmask & BIND_FLAG,
                            isBindKey = bitmask & BIND_KEY_FLAG,
                            isCurry = bitmask & CURRY_FLAG,
                            isCurryBound = bitmask & CURRY_BOUND_FLAG,
                            isCurryRight = bitmask & CURRY_RIGHT_FLAG,
                            Ctor = isBindKey ? undefined : createCtorWrapper(func);

                        function wrapper() {
                            // Avoid `arguments` object use disqualifying optimizations by
                            // converting it to an array before providing it to other functions.
                            var length = arguments.length,
                                index = length,
                                args = Array(length);

                            while (index--) {
                                args[index] = arguments[index];
                            }

                            if (partials) {
                                args = composeArgs(args, partials, holders);
                            }

                            if (partialsRight) {
                                args = composeArgsRight(args, partialsRight, holdersRight);
                            }

                            if (isCurry || isCurryRight) {
                                var placeholder = wrapper.placeholder,
                                    argsHolders = replaceHolders(args, placeholder);

                                length -= argsHolders.length;

                                if (length < arity) {
                                    var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                                        newArity = nativeMax(arity - length, 0),
                                        newsHolders = isCurry ? argsHolders : undefined,
                                        newHoldersRight = isCurry ? undefined : argsHolders,
                                        newPartials = isCurry ? args : undefined,
                                        newPartialsRight = isCurry ? undefined : args;

                                    bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
                                    bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                                    if (!isCurryBound) {
                                        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                                    }
                                    var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                                        result = createHybridWrapper.apply(undefined, newData);

                                    if (isLaziable(func)) {
                                        setData(result, newData);
                                    }
                                    result.placeholder = placeholder;

                                    return result;
                                }
                            }
                            var thisBinding = isBind ? thisArg : this,
                                fn = isBindKey ? thisBinding[func] : func;

                            if (argPos) {
                                args = reorder(args, argPos);
                            }

                            if (isAry && ary < args.length) {
                                args.length = ary;
                            }

                            if (this && this !== global && this instanceof wrapper) {
                                fn = Ctor || createCtorWrapper(func);
                            }

                            return fn.apply(thisBinding, args);
                        }

                        return wrapper;
                    }

                    module.exports = createHybridWrapper;

                }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
                //# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sb2Rhc2gtY29tcGF0L2ludGVybmFsL2NyZWF0ZUh5YnJpZFdyYXBwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXJyYXlDb3B5ID0gcmVxdWlyZSgnLi9hcnJheUNvcHknKSxcbiAgICBjb21wb3NlQXJncyA9IHJlcXVpcmUoJy4vY29tcG9zZUFyZ3MnKSxcbiAgICBjb21wb3NlQXJnc1JpZ2h0ID0gcmVxdWlyZSgnLi9jb21wb3NlQXJnc1JpZ2h0JyksXG4gICAgY3JlYXRlQ3RvcldyYXBwZXIgPSByZXF1aXJlKCcuL2NyZWF0ZUN0b3JXcmFwcGVyJyksXG4gICAgaXNMYXppYWJsZSA9IHJlcXVpcmUoJy4vaXNMYXppYWJsZScpLFxuICAgIHJlb3JkZXIgPSByZXF1aXJlKCcuL3Jlb3JkZXInKSxcbiAgICByZXBsYWNlSG9sZGVycyA9IHJlcXVpcmUoJy4vcmVwbGFjZUhvbGRlcnMnKSxcbiAgICBzZXREYXRhID0gcmVxdWlyZSgnLi9zZXREYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHdyYXBwZXIgbWV0YWRhdGEuICovXG52YXIgQklORF9GTEFHID0gMSxcbiAgICBCSU5EX0tFWV9GTEFHID0gMixcbiAgICBDVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICBDVVJSWV9GTEFHID0gOCxcbiAgICBDVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgUEFSVElBTF9GTEFHID0gMzIsXG4gICAgUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgQVJZX0ZMQUcgPSAxMjg7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIGFuZCBpbnZva2VzIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gKiBiaW5kaW5nIG9mLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy4gU2VlIGBjcmVhdGVXcmFwcGVyYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUh5YnJpZFdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBBUllfRkxBRyxcbiAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBCSU5EX0ZMQUcsXG4gICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgQklORF9LRVlfRkxBRyxcbiAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgQ1VSUllfRkxBRyxcbiAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiBDVVJSWV9CT1VORF9GTEFHLFxuICAgICAgaXNDdXJyeVJpZ2h0ID0gYml0bWFzayAmIENVUlJZX1JJR0hUX0ZMQUcsXG4gICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCB0byBvdGhlciBmdW5jdGlvbnMuXG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgfVxuICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9XG4gICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCk7XG4gICAgfVxuICAgIGlmIChpc0N1cnJ5IHx8IGlzQ3VycnlSaWdodCkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0gd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICBhcmdzSG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgbGVuZ3RoIC09IGFyZ3NIb2xkZXJzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICB2YXIgbmV3QXJnUG9zID0gYXJnUG9zID8gYXJyYXlDb3B5KGFyZ1BvcykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBuZXdBcml0eSA9IG5hdGl2ZU1heChhcml0eSAtIGxlbmd0aCwgMCksXG4gICAgICAgICAgICBuZXdzSG9sZGVycyA9IGlzQ3VycnkgPyBhcmdzSG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBhcmdzSG9sZGVycyxcbiAgICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IGFyZ3MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGFyZ3M7XG5cbiAgICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFBBUlRJQUxfRkxBRyA6IFBBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gUEFSVElBTF9SSUdIVF9GTEFHIDogUEFSVElBTF9GTEFHKTtcblxuICAgICAgICBpZiAoIWlzQ3VycnlCb3VuZCkge1xuICAgICAgICAgIGJpdG1hc2sgJj0gfihCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3RGF0YSA9IFtmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3c0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsIG5ld0hvbGRlcnNSaWdodCwgbmV3QXJnUG9zLCBhcnksIG5ld0FyaXR5XSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZFdyYXBwZXIuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcblxuICAgICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgaWYgKGFyZ1Bvcykge1xuICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICB9XG4gICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICB9XG4gICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gZ2xvYmFsICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlSHlicmlkV3JhcHBlcjtcbiJdfQ==
            },{
                './arrayCopy': 65,'./composeArgs': 99,'./composeArgsRight': 100,'./createCtorWrapper': 104,'./isLaziable': 127,'./reorder': 134,'./replaceHolders': 135,'./setData': 136
            }],108: [function (require, module, exports) {
                (function (global) {
                    var createCtorWrapper = require('./createCtorWrapper');

                    /** Used to compose bitmasks for wrapper metadata. */
                    var BIND_FLAG = 1;

                    /**
                     * Creates a function that wraps `func` and invokes it with the optional `this`
                     * binding of `thisArg` and the `partials` prepended to those provided to
                     * the wrapper.
                     *
                     * @private
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {Array} partials The arguments to prepend to those provided to the new function.
                     * @returns {Function} Returns the new bound function.
                     */
                    function createPartialWrapper(func, bitmask, thisArg, partials) {
                        var isBind = bitmask & BIND_FLAG,
                            Ctor = createCtorWrapper(func);

                        function wrapper() {
                            // Avoid `arguments` object use disqualifying optimizations by
                            // converting it to an array before providing it `func`.
                            var argsIndex = -1,
                                argsLength = arguments.length,
                                leftIndex = -1,
                                leftLength = partials.length,
                                args = Array(leftLength + argsLength);

                            while (++leftIndex < leftLength) {
                                args[leftIndex] = partials[leftIndex];
                            }

                            while (argsLength--) {
                                args[leftIndex++] = arguments[++argsIndex];
                            }
                            var fn = this && this !== global && this instanceof wrapper ? Ctor : func;

                            return fn.apply(isBind ? thisArg : this, args);
                        }

                        return wrapper;
                    }

                    module.exports = createPartialWrapper;

                }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
                //# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sb2Rhc2gtY29tcGF0L2ludGVybmFsL2NyZWF0ZVBhcnRpYWxXcmFwcGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3JlYXRlQ3RvcldyYXBwZXIgPSByZXF1aXJlKCcuL2NyZWF0ZUN0b3JXcmFwcGVyJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHdyYXBwZXIgbWV0YWRhdGEuICovXG52YXIgQklORF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gKiB0aGUgd3JhcHBlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBwZXJgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWxXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuICAgICAgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgLy8gQXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IHVzZSBkaXNxdWFsaWZ5aW5nIG9wdGltaXphdGlvbnMgYnlcbiAgICAvLyBjb252ZXJ0aW5nIGl0IHRvIGFuIGFycmF5IGJlZm9yZSBwcm92aWRpbmcgaXQgYGZ1bmNgLlxuICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgIH1cbiAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSBnbG9iYWwgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVQYXJ0aWFsV3JhcHBlcjtcbiJdfQ==
            },{
                './createCtorWrapper': 104
            }],109: [function (require, module, exports) {
                var baseSetData = require('./baseSetData'),
                    createBindWrapper = require('./createBindWrapper'),
                    createHybridWrapper = require('./createHybridWrapper'),
                    createPartialWrapper = require('./createPartialWrapper'),
                    getData = require('./getData'),
                    mergeData = require('./mergeData'),
                    setData = require('./setData');

                /** Used to compose bitmasks for wrapper metadata. */
                var BIND_FLAG = 1,
                    BIND_KEY_FLAG = 2,
                    PARTIAL_FLAG = 32,
                    PARTIAL_RIGHT_FLAG = 64;

                /** Used as the `TypeError` message for "Functions" methods. */
                var FUNC_ERROR_TEXT = 'Expected a function';

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeMax = Math.max;

                /**
                 * Creates a function that either curries or invokes `func` with optional
                 * `this` binding and partially applied arguments.
                 *
                 * @private
                 * @param {Function|string} func The function or method name to reference.
                 * @param {number} bitmask The bitmask of flags.
                 *  The bitmask may be composed of the following flags:
                 *     1 - `_.bind`
                 *     2 - `_.bindKey`
                 *     4 - `_.curry` or `_.curryRight` of a bound function
                 *     8 - `_.curry`
                 *    16 - `_.curryRight`
                 *    32 - `_.partial`
                 *    64 - `_.partialRight`
                 *   128 - `_.rearg`
                 *   256 - `_.ary`
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {Array} [partials] The arguments to be partially applied.
                 * @param {Array} [holders] The `partials` placeholder indexes.
                 * @param {Array} [argPos] The argument positions of the new function.
                 * @param {number} [ary] The arity cap of `func`.
                 * @param {number} [arity] The arity of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                    var isBindKey = bitmask & BIND_KEY_FLAG;

                    if (!isBindKey && typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    var length = partials ? partials.length : 0;

                    if (!length) {
                        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                        partials = holders = undefined;
                    }
                    length -= holders ? holders.length : 0;

                    if (bitmask & PARTIAL_RIGHT_FLAG) {
                        var partialsRight = partials,
                            holdersRight = holders;

                        partials = holders = undefined;
                    }
                    var data = isBindKey ? undefined : getData(func),
                        newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

                    if (data) {
                        mergeData(newData, data);
                        bitmask = newData[1];
                        arity = newData[9];
                    }
                    newData[9] = arity == null ?
                        isBindKey ? 0 : func.length
                        : nativeMax(arity - length, 0) || 0;

                    if (bitmask == BIND_FLAG) {
                        var result = createBindWrapper(newData[0], newData[2]);
                    } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                        result = createPartialWrapper.apply(undefined, newData);
                    } else {
                        result = createHybridWrapper.apply(undefined, newData);
                    }
                    var setter = data ? baseSetData : setData;

                    return setter(result, newData);
                }

                module.exports = createWrapper;

            },{
                './baseSetData': 91,'./createBindWrapper': 103,'./createHybridWrapper': 107,'./createPartialWrapper': 108,'./getData': 113,'./mergeData': 131,'./setData': 136
            }],110: [function (require, module, exports) {
                var arraySome = require('./arraySome');

                /**
                 * A specialized version of `baseIsEqualDeep` for arrays with support for
                 * partial deep comparisons.
                 *
                 * @private
                 * @param {Array} array The array to compare.
                 * @param {Array} other The other array to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} [customizer] The function to customize comparing arrays.
                 * @param {boolean} [isLoose] Specify performing partial comparisons.
                 * @param {Array} [stackA] Tracks traversed `value` objects.
                 * @param {Array} [stackB] Tracks traversed `other` objects.
                 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                 */
                function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
                    var index = -1,
                        arrLength = array.length,
                        othLength = other.length;

                    if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                        return false;
                    }
                    // Ignore non-index properties.
                    while (++index < arrLength) {
                        var arrValue = array[index],
                            othValue = other[index],
                            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

                        if (result !== undefined) {
                            if (result) {
                                continue;
                            }

                            return false;
                        }
                        // Recursively compare arrays (susceptible to call stack limits).
                        if (isLoose) {
                            if (!arraySome(other, function (othValue) {
                                    return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                                })) {
                                return false;
                            }
                        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                            return false;
                        }
                    }

                    return true;
                }

                module.exports = equalArrays;

            },{
                './arraySome': 68
            }],111: [function (require, module, exports) {
                /** `Object#toString` result references. */
                var boolTag = '[object Boolean]',
                    dateTag = '[object Date]',
                    errorTag = '[object Error]',
                    numberTag = '[object Number]',
                    regexpTag = '[object RegExp]',
                    stringTag = '[object String]';

                /**
                 * A specialized version of `baseIsEqualDeep` for comparing objects of
                 * the same `toStringTag`.
                 *
                 * **Note:** This function only supports comparing values with tags of
                 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {string} tag The `toStringTag` of the objects to compare.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function equalByTag(object, other, tag) {
                    switch (tag) {
                        case boolTag:
                        case dateTag:
                            // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                            // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                            return +object == +other;

                        case errorTag:
                            return object.name == other.name && object.message == other.message;

                        case numberTag:
                            // Treat `NaN` vs. `NaN` as equal.
                            return object != +object ?
                                other != +other
                                : object == +other;

                        case regexpTag:
                        case stringTag:
                            // Coerce regexes to strings and treat strings primitives and string
                            // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                            return object == other + '';
                    }

                    return false;
                }

                module.exports = equalByTag;

            },{}],112: [function (require, module, exports) {
                var keys = require('../object/keys');

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /**
                 * A specialized version of `baseIsEqualDeep` for objects with support for
                 * partial deep comparisons.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} [customizer] The function to customize comparing values.
                 * @param {boolean} [isLoose] Specify performing partial comparisons.
                 * @param {Array} [stackA] Tracks traversed `value` objects.
                 * @param {Array} [stackB] Tracks traversed `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                    var objProps = keys(object),
                        objLength = objProps.length,
                        othProps = keys(other),
                        othLength = othProps.length;

                    if (objLength != othLength && !isLoose) {
                        return false;
                    }
                    var index = objLength;

                    while (index--) {
                        var key = objProps[index];

                        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                            return false;
                        }
                    }
                    var skipCtor = isLoose;

                    while (++index < objLength) {
                        key = objProps[index];
                        var objValue = object[key],
                            othValue = other[key],
                            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;

                        // Recursively compare objects (susceptible to call stack limits).
                        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                            return false;
                        }
                        skipCtor || (skipCtor = key == 'constructor');
                    }

                    if (!skipCtor) {
                        var objCtor = object.constructor,
                            othCtor = other.constructor;

                        // Non `Object` object instances with different constructors are not equal.
                        if (objCtor != othCtor &&
                            ('constructor' in object && 'constructor' in other) &&
                            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                            return false;
                        }
                    }

                    return true;
                }

                module.exports = equalObjects;

            },{
                '../object/keys': 152
            }],113: [function (require, module, exports) {
                var metaMap = require('./metaMap'),
                    noop = require('../utility/noop');

                /**
                 * Gets metadata for `func`.
                 *
                 * @private
                 * @param {Function} func The function to query.
                 * @returns {*} Returns the metadata for `func`.
                 */
                var getData = !metaMap ? noop : function (func) {
                    return metaMap.get(func);
                };

                module.exports = getData;

            },{
                '../utility/noop': 158,'./metaMap': 132
            }],114: [function (require, module, exports) {
                var realNames = require('./realNames');

                /**
                 * Gets the name of `func`.
                 *
                 * @private
                 * @param {Function} func The function to query.
                 * @returns {string} Returns the function name.
                 */
                function getFuncName(func) {
                    var result = func.name,
                        array = realNames[result],
                        length = array ? array.length : 0;

                    while (length--) {
                        var data = array[length],
                            otherFunc = data.func;

                        if (otherFunc == null || otherFunc == func) {
                            return data.name;
                        }
                    }

                    return result;
                }

                module.exports = getFuncName;

            },{
                './realNames': 133
            }],115: [function (require, module, exports) {
                var baseProperty = require('./baseProperty');

                /**
                 * Gets the "length" property value of `object`.
                 *
                 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
                 * that affects Safari on at least iOS 8.1-8.3 ARM64.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {*} Returns the "length" value.
                 */
                var getLength = baseProperty('length');

                module.exports = getLength;

            },{
                './baseProperty': 89
            }],116: [function (require, module, exports) {
                var isStrictComparable = require('./isStrictComparable'),
                    pairs = require('../object/pairs');

                /**
                 * Gets the propery names, values, and compare flags of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the match data of `object`.
                 */
                function getMatchData(object) {
                    var result = pairs(object),
                        length = result.length;

                    while (length--) {
                        result[length][2] = isStrictComparable(result[length][1]);
                    }

                    return result;
                }

                module.exports = getMatchData;

            },{
                '../object/pairs': 154,'./isStrictComparable': 130
            }],117: [function (require, module, exports) {
                var isNative = require('../lang/isNative');

                /**
                 * Gets the native function at `key` of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {string} key The key of the method to get.
                 * @returns {*} Returns the function if it's native, else `undefined`.
                 */
                function getNative(object, key) {
                    var value = object == null ? undefined : object[key];

                    return isNative(value) ? value : undefined;
                }

                module.exports = getNative;

            },{
                '../lang/isNative': 146
            }],118: [function (require, module, exports) {
                /**
                 * Gets the index at which the first occurrence of `NaN` is found in `array`.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {number} fromIndex The index to search from.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
                 */
                function indexOfNaN(array, fromIndex, fromRight) {
                    var length = array.length,
                        index = fromIndex + (fromRight ? 0 : -1);

                    while (fromRight ? index-- : ++index < length) {
                        var other = array[index];

                        if (other !== other) {
                            return index;
                        }
                    }

                    return -1;
                }

                module.exports = indexOfNaN;

            },{}],119: [function (require, module, exports) {
                /** Used for native method references. */
                var objectProto = Object.prototype;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /**
                 * Initializes an array clone.
                 *
                 * @private
                 * @param {Array} array The array to clone.
                 * @returns {Array} Returns the initialized clone.
                 */
                function initCloneArray(array) {
                    var length = array.length,
                        result = new array.constructor(length);

                    // Add array properties assigned by `RegExp#exec`.
                    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                        result.index = array.index;
                        result.input = array.input;
                    }

                    return result;
                }

                module.exports = initCloneArray;

            },{}],120: [function (require, module, exports) {
                (function (global) {
                    var bufferClone = require('./bufferClone');

                    /** `Object#toString` result references. */
                    var boolTag = '[object Boolean]',
                        dateTag = '[object Date]',
                        numberTag = '[object Number]',
                        regexpTag = '[object RegExp]',
                        stringTag = '[object String]';

                    var arrayBufferTag = '[object ArrayBuffer]',
                        float32Tag = '[object Float32Array]',
                        float64Tag = '[object Float64Array]',
                        int8Tag = '[object Int8Array]',
                        int16Tag = '[object Int16Array]',
                        int32Tag = '[object Int32Array]',
                        uint8Tag = '[object Uint8Array]',
                        uint8ClampedTag = '[object Uint8ClampedArray]',
                        uint16Tag = '[object Uint16Array]',
                        uint32Tag = '[object Uint32Array]';

                    /** Used to match `RegExp` flags from their coerced string values. */
                    var reFlags = /\w*$/;

                    /** Native method references. */
                    var Uint8Array = global.Uint8Array;

                    /** Used to lookup a type array constructors by `toStringTag`. */
                    var ctorByTag = {};

                    ctorByTag[float32Tag] = global.Float32Array;
                    ctorByTag[float64Tag] = global.Float64Array;
                    ctorByTag[int8Tag] = global.Int8Array;
                    ctorByTag[int16Tag] = global.Int16Array;
                    ctorByTag[int32Tag] = global.Int32Array;
                    ctorByTag[uint8Tag] = Uint8Array;
                    ctorByTag[uint8ClampedTag] = global.Uint8ClampedArray;
                    ctorByTag[uint16Tag] = global.Uint16Array;
                    ctorByTag[uint32Tag] = global.Uint32Array;

                    /**
                     * Initializes an object clone based on its `toStringTag`.
                     *
                     * **Note:** This function only supports cloning values with tags of
                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @param {string} tag The `toStringTag` of the object to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the initialized clone.
                     */
                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;

                        switch (tag) {
                            case arrayBufferTag:
                                return bufferClone(object);

                            case boolTag:
                            case dateTag:
                                return new Ctor(+object);

                            case float32Tag: case float64Tag:
                            case int8Tag: case int16Tag: case int32Tag:
                            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
                                // Safari 5 mobile incorrectly has `Object` as the constructor of typed arrays.
                                if (Ctor instanceof Ctor) {
                                    Ctor = ctorByTag[tag];
                                }
                                var buffer = object.buffer;

                                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

                            case numberTag:
                            case stringTag:
                                return new Ctor(object);

                            case regexpTag:
                                var result = new Ctor(object.source, reFlags.exec(object));

                                result.lastIndex = object.lastIndex;
                        }

                        return result;
                    }

                    module.exports = initCloneByTag;

                }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
                //# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sb2Rhc2gtY29tcGF0L2ludGVybmFsL2luaXRDbG9uZUJ5VGFnLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYnVmZmVyQ2xvbmUgPSByZXF1aXJlKCcuL2J1ZmZlckNsb25lJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcblxuLyoqIFVzZWQgdG8gbG9va3VwIGEgdHlwZSBhcnJheSBjb25zdHJ1Y3RvcnMgYnkgYHRvU3RyaW5nVGFnYC4gKi9cbnZhciBjdG9yQnlUYWcgPSB7fTtcbmN0b3JCeVRhZ1tmbG9hdDMyVGFnXSA9IGdsb2JhbC5GbG9hdDMyQXJyYXk7XG5jdG9yQnlUYWdbZmxvYXQ2NFRhZ10gPSBnbG9iYWwuRmxvYXQ2NEFycmF5O1xuY3RvckJ5VGFnW2ludDhUYWddID0gZ2xvYmFsLkludDhBcnJheTtcbmN0b3JCeVRhZ1tpbnQxNlRhZ10gPSBnbG9iYWwuSW50MTZBcnJheTtcbmN0b3JCeVRhZ1tpbnQzMlRhZ10gPSBnbG9iYWwuSW50MzJBcnJheTtcbmN0b3JCeVRhZ1t1aW50OFRhZ10gPSBVaW50OEFycmF5O1xuY3RvckJ5VGFnW3VpbnQ4Q2xhbXBlZFRhZ10gPSBnbG9iYWwuVWludDhDbGFtcGVkQXJyYXk7XG5jdG9yQnlUYWdbdWludDE2VGFnXSA9IGdsb2JhbC5VaW50MTZBcnJheTtcbmN0b3JCeVRhZ1t1aW50MzJUYWddID0gZ2xvYmFsLlVpbnQzMkFycmF5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGJ1ZmZlckNsb25lKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAvLyBTYWZhcmkgNSBtb2JpbGUgaW5jb3JyZWN0bHkgaGFzIGBPYmplY3RgIGFzIHRoZSBjb25zdHJ1Y3RvciBvZiB0eXBlZCBhcnJheXMuXG4gICAgICBpZiAoQ3RvciBpbnN0YW5jZW9mIEN0b3IpIHtcbiAgICAgICAgQ3RvciA9IGN0b3JCeVRhZ1t0YWddO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlciA9IG9iamVjdC5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IEN0b3IoaXNEZWVwID8gYnVmZmVyQ2xvbmUoYnVmZmVyKSA6IGJ1ZmZlciwgb2JqZWN0LmJ5dGVPZmZzZXQsIG9iamVjdC5sZW5ndGgpO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yKG9iamVjdC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhvYmplY3QpKTtcbiAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSBvYmplY3QubGFzdEluZGV4O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iXX0=
            },{
                './bufferClone': 98
            }],121: [function (require, module, exports) {
                /**
                 * Initializes an object clone.
                 *
                 * @private
                 * @param {Object} object The object to clone.
                 * @returns {Object} Returns the initialized clone.
                 */
                function initCloneObject(object) {
                    var Ctor = object.constructor;

                    if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
                        Ctor = Object;
                    }

                    return new Ctor;
                }

                module.exports = initCloneObject;

            },{}],122: [function (require, module, exports) {
                var getLength = require('./getLength'),
                    isLength = require('./isLength');

                /**
                 * Checks if `value` is array-like.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                 */
                function isArrayLike(value) {
                    return value != null && isLength(getLength(value));
                }

                module.exports = isArrayLike;

            },{
                './getLength': 115,'./isLength': 128
            }],123: [function (require, module, exports) {
                /**
                 * Checks if `value` is a host object in IE < 9.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
                 */
                var isHostObject = (function () {
                    try {
                        Object({
                            'toString': 0
                        } + '');
                    } catch (e) {
                        return function () {
                            return false;
                        };
                    }

                    return function (value) {
                        // IE < 9 presents many host objects as `Object` objects that can coerce
                        // to strings despite having improperly defined `toString` methods.
                        return typeof value.toString != 'function' && typeof (value + '') == 'string';
                    };
                }());

                module.exports = isHostObject;

            },{}],124: [function (require, module, exports) {
                /** Used to detect unsigned integer values. */
                var reIsUint = /^\d+$/;

                /**
                 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
                 * of an array-like value.
                 */
                var MAX_SAFE_INTEGER = 9007199254740991;

                /**
                 * Checks if `value` is a valid array-like index.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                 */
                function isIndex(value, length) {
                    value = typeof value == 'number' || reIsUint.test(value) ? +value : -1;
                    length = length == null ? MAX_SAFE_INTEGER : length;

                    return value > -1 && value % 1 == 0 && value < length;
                }

                module.exports = isIndex;

            },{}],125: [function (require, module, exports) {
                var isArrayLike = require('./isArrayLike'),
                    isIndex = require('./isIndex'),
                    isObject = require('../lang/isObject');

                /**
                 * Checks if the provided arguments are from an iteratee call.
                 *
                 * @private
                 * @param {*} value The potential iteratee value argument.
                 * @param {*} index The potential iteratee index or key argument.
                 * @param {*} object The potential iteratee object argument.
                 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
                 */
                function isIterateeCall(value, index, object) {
                    if (!isObject(object)) {
                        return false;
                    }
                    var type = typeof index;

                    if (type == 'number' ?
                            isArrayLike(object) && isIndex(index, object.length)
                            : type == 'string' && index in object) {
                        var other = object[index];

                        return value === value ? value === other : other !== other;
                    }

                    return false;
                }

                module.exports = isIterateeCall;

            },{
                '../lang/isObject': 147,'./isArrayLike': 122,'./isIndex': 124
            }],126: [function (require, module, exports) {
                var isArray = require('../lang/isArray'),
                    toObject = require('./toObject');

                /** Used to match property names within property paths. */
                var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
                    reIsPlainProp = /^\w*$/;

                /**
                 * Checks if `value` is a property name and not a property path.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @param {Object} [object] The object to query keys on.
                 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                 */
                function isKey(value, object) {
                    var type = typeof value;

                    if (type == 'string' && reIsPlainProp.test(value) || type == 'number') {
                        return true;
                    }

                    if (isArray(value)) {
                        return false;
                    }
                    var result = !reIsDeepProp.test(value);

                    return result || object != null && value in toObject(object);
                }

                module.exports = isKey;

            },{
                '../lang/isArray': 143,'./toObject': 138
            }],127: [function (require, module, exports) {
                var LazyWrapper = require('./LazyWrapper'),
                    getData = require('./getData'),
                    getFuncName = require('./getFuncName'),
                    lodash = require('../chain/lodash');

                /**
                 * Checks if `func` has a lazy counterpart.
                 *
                 * @private
                 * @param {Function} func The function to check.
                 * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
                 */
                function isLaziable(func) {
                    var funcName = getFuncName(func);

                    if (!(funcName in LazyWrapper.prototype)) {
                        return false;
                    }
                    var other = lodash[funcName];

                    if (func === other) {
                        return true;
                    }
                    var data = getData(other);

                    return !!data && func === data[0];
                }

                module.exports = isLaziable;

            },{
                '../chain/lodash': 54,'./LazyWrapper': 63,'./getData': 113,'./getFuncName': 114
            }],128: [function (require, module, exports) {
                /**
                 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
                 * of an array-like value.
                 */
                var MAX_SAFE_INTEGER = 9007199254740991;

                /**
                 * Checks if `value` is a valid array-like length.
                 *
                 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                 */
                function isLength(value) {
                    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                }

                module.exports = isLength;

            },{}],129: [function (require, module, exports) {
                /**
                 * Checks if `value` is object-like.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                 */
                function isObjectLike(value) {
                    return !!value && typeof value == 'object';
                }

                module.exports = isObjectLike;

            },{}],130: [function (require, module, exports) {
                var isObject = require('../lang/isObject');

                /**
                 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` if suitable for strict
                 *  equality comparisons, else `false`.
                 */
                function isStrictComparable(value) {
                    return value === value && !isObject(value);
                }

                module.exports = isStrictComparable;

            },{
                '../lang/isObject': 147
            }],131: [function (require, module, exports) {
                var arrayCopy = require('./arrayCopy'),
                    composeArgs = require('./composeArgs'),
                    composeArgsRight = require('./composeArgsRight'),
                    replaceHolders = require('./replaceHolders');

                /** Used to compose bitmasks for wrapper metadata. */
                var BIND_FLAG = 1,
                    CURRY_BOUND_FLAG = 4,
                    CURRY_FLAG = 8,
                    ARY_FLAG = 128,
                    REARG_FLAG = 256;

                /** Used as the internal argument placeholder. */
                var PLACEHOLDER = '__lodash_placeholder__';

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeMin = Math.min;

                /**
                 * Merges the function metadata of `source` into `data`.
                 *
                 * Merging metadata reduces the number of wrappers required to invoke a function.
                 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
                 * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
                 * augment function arguments, making the order in which they are executed important,
                 * preventing the merging of metadata. However, we make an exception for a safe
                 * common case where curried functions have `_.ary` and or `_.rearg` applied.
                 *
                 * @private
                 * @param {Array} data The destination metadata.
                 * @param {Array} source The source metadata.
                 * @returns {Array} Returns `data`.
                 */
                function mergeData(data, source) {
                    var bitmask = data[1],
                        srcBitmask = source[1],
                        newBitmask = bitmask | srcBitmask,
                        isCommon = newBitmask < ARY_FLAG;

                    var isCombo =
                        srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG ||
                        srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] ||
                        srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG;

                    // Exit early if metadata can't be merged.
                    if (!(isCommon || isCombo)) {
                        return data;
                    }
                    // Use source `thisArg` if available.
                    if (srcBitmask & BIND_FLAG) {
                        data[2] = source[2];
                        // Set when currying a bound function.
                        newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
                    }
                    // Compose partial arguments.
                    var value = source[3];

                    if (value) {
                        var partials = data[3];

                        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
                    }
                    // Compose partial right arguments.
                    value = source[5];

                    if (value) {
                        partials = data[5];
                        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
                    }
                    // Use source `argPos` if available.
                    value = source[7];

                    if (value) {
                        data[7] = arrayCopy(value);
                    }
                    // Use source `ary` if it's smaller.
                    if (srcBitmask & ARY_FLAG) {
                        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                    }
                    // Use source `arity` if one is not provided.
                    if (data[9] == null) {
                        data[9] = source[9];
                    }
                    // Use source `func` and merge bitmasks.
                    data[0] = source[0];
                    data[1] = newBitmask;

                    return data;
                }

                module.exports = mergeData;

            },{
                './arrayCopy': 65,'./composeArgs': 99,'./composeArgsRight': 100,'./replaceHolders': 135
            }],132: [function (require, module, exports) {
                (function (global) {
                    var getNative = require('./getNative');

                    /** Native method references. */
                    var WeakMap = getNative(global, 'WeakMap');

                    /** Used to store function metadata. */
                    var metaMap = WeakMap && new WeakMap;

                    module.exports = metaMap;

                }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
                //# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sb2Rhc2gtY29tcGF0L2ludGVybmFsL21ldGFNYXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9nZXROYXRpdmUnKTtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKGdsb2JhbCwgJ1dlYWtNYXAnKTtcblxuLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gbWV0YU1hcDtcbiJdfQ==
            },{
                './getNative': 117
            }],133: [function (require, module, exports) {
                /** Used to lookup unminified function names. */
                var realNames = {};

                module.exports = realNames;

            },{}],134: [function (require, module, exports) {
                var arrayCopy = require('./arrayCopy'),
                    isIndex = require('./isIndex');

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeMin = Math.min;

                /**
                 * Reorder `array` according to the specified indexes where the element at
                 * the first index is assigned as the first element, the element at
                 * the second index is assigned as the second element, and so on.
                 *
                 * @private
                 * @param {Array} array The array to reorder.
                 * @param {Array} indexes The arranged array indexes.
                 * @returns {Array} Returns `array`.
                 */
                function reorder(array, indexes) {
                    var arrLength = array.length,
                        length = nativeMin(indexes.length, arrLength),
                        oldArray = arrayCopy(array);

                    while (length--) {
                        var index = indexes[length];

                        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                    }

                    return array;
                }

                module.exports = reorder;

            },{
                './arrayCopy': 65,'./isIndex': 124
            }],135: [function (require, module, exports) {
                /** Used as the internal argument placeholder. */
                var PLACEHOLDER = '__lodash_placeholder__';

                /**
                 * Replaces all `placeholder` elements in `array` with an internal placeholder
                 * and returns an array of their indexes.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {*} placeholder The placeholder to replace.
                 * @returns {Array} Returns the new array of placeholder indexes.
                 */
                function replaceHolders(array, placeholder) {
                    var index = -1,
                        length = array.length,
                        resIndex = -1,
                        result = [];

                    while (++index < length) {
                        if (array[index] === placeholder) {
                            array[index] = PLACEHOLDER;
                            result[++resIndex] = index;
                        }
                    }

                    return result;
                }

                module.exports = replaceHolders;

            },{}],136: [function (require, module, exports) {
                var baseSetData = require('./baseSetData'),
                    now = require('../date/now');

                /** Used to detect when a function becomes hot. */
                var HOT_COUNT = 150,
                    HOT_SPAN = 16;

                /**
                 * Sets metadata for `func`.
                 *
                 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
                 * period of time, it will trip its breaker and transition to an identity function
                 * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
                 * for more details.
                 *
                 * @private
                 * @param {Function} func The function to associate metadata with.
                 * @param {*} data The metadata.
                 * @returns {Function} Returns `func`.
                 */
                var setData = (function () {
                    var count = 0,
                        lastCalled = 0;

                    return function (key, value) {
                        var stamp = now(),
                            remaining = HOT_SPAN - (stamp - lastCalled);

                        lastCalled = stamp;

                        if (remaining > 0) {
                            if (++count >= HOT_COUNT) {
                                return key;
                            }
                        } else {
                            count = 0;
                        }

                        return baseSetData(key, value);
                    };
                }());

                module.exports = setData;

            },{
                '../date/now': 60,'./baseSetData': 91
            }],137: [function (require, module, exports) {
                var isArguments = require('../lang/isArguments'),
                    isArray = require('../lang/isArray'),
                    isIndex = require('./isIndex'),
                    isLength = require('./isLength'),
                    isString = require('../lang/isString'),
                    keysIn = require('../object/keysIn');

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /**
                 * A fallback implementation of `Object.keys` which creates an array of the
                 * own enumerable property names of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 */
                function shimKeys(object) {
                    var props = keysIn(object),
                        propsLength = props.length,
                        length = propsLength && object.length;

                    var allowIndexes = !!length && isLength(length) &&
                        (isArray(object) || isArguments(object) || isString(object));

                    var index = -1,
                        result = [];

                    while (++index < propsLength) {
                        var key = props[index];

                        if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) {
                            result.push(key);
                        }
                    }

                    return result;
                }

                module.exports = shimKeys;

            },{
                '../lang/isArguments': 142,'../lang/isArray': 143,'../lang/isString': 149,'../object/keysIn': 153,'./isIndex': 124,'./isLength': 128
            }],138: [function (require, module, exports) {
                var isObject = require('../lang/isObject'),
                    isString = require('../lang/isString'),
                    support = require('../support');

                /**
                 * Converts `value` to an object if it's not one.
                 *
                 * @private
                 * @param {*} value The value to process.
                 * @returns {Object} Returns the object.
                 */
                function toObject(value) {
                    if (support.unindexedChars && isString(value)) {
                        var index = -1,
                            length = value.length,
                            result = Object(value);

                        while (++index < length) {
                            result[index] = value.charAt(index);
                        }

                        return result;
                    }

                    return isObject(value) ? value : Object(value);
                }

                module.exports = toObject;

            },{
                '../lang/isObject': 147,'../lang/isString': 149,'../support': 156
            }],139: [function (require, module, exports) {
                var baseToString = require('./baseToString'),
                    isArray = require('../lang/isArray');

                /** Used to match property names within property paths. */
                var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

                /** Used to match backslashes in property paths. */
                var reEscapeChar = /\\(\\)?/g;

                /**
                 * Converts `value` to property path array if it's not one.
                 *
                 * @private
                 * @param {*} value The value to process.
                 * @returns {Array} Returns the property path array.
                 */
                function toPath(value) {
                    if (isArray(value)) {
                        return value;
                    }
                    var result = [];

                    baseToString(value).replace(rePropName, function (match, number, quote, string) {
                        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
                    });

                    return result;
                }

                module.exports = toPath;

            },{
                '../lang/isArray': 143,'./baseToString': 93
            }],140: [function (require, module, exports) {
                var LazyWrapper = require('./LazyWrapper'),
                    LodashWrapper = require('./LodashWrapper'),
                    arrayCopy = require('./arrayCopy');

                /**
                 * Creates a clone of `wrapper`.
                 *
                 * @private
                 * @param {Object} wrapper The wrapper to clone.
                 * @returns {Object} Returns the cloned wrapper.
                 */
                function wrapperClone(wrapper) {
                    return wrapper instanceof LazyWrapper ?
                        wrapper.clone()
                        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
                }

                module.exports = wrapperClone;

            },{
                './LazyWrapper': 63,'./LodashWrapper': 64,'./arrayCopy': 65
            }],141: [function (require, module, exports) {
                var baseClone = require('../internal/baseClone'),
                    bindCallback = require('../internal/bindCallback');

                /**
                 * Creates a deep clone of `value`. If `customizer` is provided it is invoked
                 * to produce the cloned values. If `customizer` returns `undefined` cloning
                 * is handled by the method instead. The `customizer` is bound to `thisArg`
                 * and invoked with two argument; (value [, index|key, object]).
                 *
                 * **Note:** This method is loosely based on the
                 * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
                 * The enumerable properties of `arguments` objects and objects created by
                 * constructors other than `Object` are cloned to plain `Object` objects. An
                 * empty object is returned for uncloneable values such as functions, DOM nodes,
                 * Maps, Sets, and WeakMaps.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to deep clone.
                 * @param {Function} [customizer] The function to customize cloning values.
                 * @param {*} [thisArg] The `this` binding of `customizer`.
                 * @returns {*} Returns the deep cloned value.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney' },
                 *   { 'user': 'fred' }
                 * ];
                 *
                 * var deep = _.cloneDeep(users);
                 * deep[0] === users[0];
                 * // => false
                 *
                 * // using a customizer callback
                 * var el = _.cloneDeep(document.body, function(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * });
                 *
                 * el === document.body
                 * // => false
                 * el.nodeName
                 * // => BODY
                 * el.childNodes.length;
                 * // => 20
                 */
                function cloneDeep(value, customizer, thisArg) {
                    return typeof customizer == 'function' ?
                        baseClone(value, true, bindCallback(customizer, thisArg, 1))
                        : baseClone(value, true);
                }

                module.exports = cloneDeep;

            },{
                '../internal/baseClone': 71,'../internal/bindCallback': 97
            }],142: [function (require, module, exports) {
                var isArrayLike = require('../internal/isArrayLike'),
                    isObjectLike = require('../internal/isObjectLike');

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /** Native method references. */
                var propertyIsEnumerable = objectProto.propertyIsEnumerable;

                /**
                 * Checks if `value` is classified as an `arguments` object.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                 * @example
                 *
                 * _.isArguments(function() { return arguments; }());
                 * // => true
                 *
                 * _.isArguments([1, 2, 3]);
                 * // => false
                 */
                function isArguments(value) {
                    return isObjectLike(value) && isArrayLike(value) &&
                        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
                }

                module.exports = isArguments;

            },{
                '../internal/isArrayLike': 122,'../internal/isObjectLike': 129
            }],143: [function (require, module, exports) {
                var getNative = require('../internal/getNative'),
                    isLength = require('../internal/isLength'),
                    isObjectLike = require('../internal/isObjectLike');

                /** `Object#toString` result references. */
                var arrayTag = '[object Array]';

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /**
                 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objToString = objectProto.toString;

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeIsArray = getNative(Array, 'isArray');

                /**
                 * Checks if `value` is classified as an `Array` object.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                 * @example
                 *
                 * _.isArray([1, 2, 3]);
                 * // => true
                 *
                 * _.isArray(function() { return arguments; }());
                 * // => false
                 */
                var isArray = nativeIsArray || function (value) {
                        return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
                    };

                module.exports = isArray;

            },{
                '../internal/getNative': 117,'../internal/isLength': 128,'../internal/isObjectLike': 129
            }],144: [function (require, module, exports) {
                var isArguments = require('./isArguments'),
                    isArray = require('./isArray'),
                    isArrayLike = require('../internal/isArrayLike'),
                    isFunction = require('./isFunction'),
                    isObjectLike = require('../internal/isObjectLike'),
                    isString = require('./isString'),
                    keys = require('../object/keys');

                /**
                 * Checks if `value` is empty. A value is considered empty unless it is an
                 * `arguments` object, array, string, or jQuery-like collection with a length
                 * greater than `0` or an object with own enumerable properties.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {Array|Object|string} value The value to inspect.
                 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                 * @example
                 *
                 * _.isEmpty(null);
                 * // => true
                 *
                 * _.isEmpty(true);
                 * // => true
                 *
                 * _.isEmpty(1);
                 * // => true
                 *
                 * _.isEmpty([1, 2, 3]);
                 * // => false
                 *
                 * _.isEmpty({ 'a': 1 });
                 * // => false
                 */
                function isEmpty(value) {
                    if (value == null) {
                        return true;
                    }

                    if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
                        isObjectLike(value) && isFunction(value.splice))) {
                        return !value.length;
                    }

                    return !keys(value).length;
                }

                module.exports = isEmpty;

            },{
                '../internal/isArrayLike': 122,'../internal/isObjectLike': 129,'../object/keys': 152,'./isArguments': 142,'./isArray': 143,'./isFunction': 145,'./isString': 149
            }],145: [function (require, module, exports) {
                var isObject = require('./isObject');

                /** `Object#toString` result references. */
                var funcTag = '[object Function]';

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /**
                 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objToString = objectProto.toString;

                /**
                 * Checks if `value` is classified as a `Function` object.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                 * @example
                 *
                 * _.isFunction(_);
                 * // => true
                 *
                 * _.isFunction(/abc/);
                 * // => false
                 */
                function isFunction(value) {
                    // The use of `Object#toString` avoids issues with the `typeof` operator
                    // in older versions of Chrome and Safari which return 'function' for regexes
                    // and Safari 8 equivalents which return 'object' for typed array constructors.
                    return isObject(value) && objToString.call(value) == funcTag;
                }

                module.exports = isFunction;

            },{
                './isObject': 147
            }],146: [function (require, module, exports) {
                var isFunction = require('./isFunction'),
                    isHostObject = require('../internal/isHostObject'),
                    isObjectLike = require('../internal/isObjectLike');

                /** Used to detect host constructors (Safari > 5). */
                var reIsHostCtor = /^\[object .+?Constructor\]$/;

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /** Used to resolve the decompiled source of functions. */
                var fnToString = Function.prototype.toString;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /** Used to detect if a method is native. */
                var reIsNative = RegExp('^' +
                    fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
                );

                /**
                 * Checks if `value` is a native function.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
                 * @example
                 *
                 * _.isNative(Array.prototype.push);
                 * // => true
                 *
                 * _.isNative(_);
                 * // => false
                 */
                function isNative(value) {
                    if (value == null) {
                        return false;
                    }

                    if (isFunction(value)) {
                        return reIsNative.test(fnToString.call(value));
                    }

                    return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
                }

                module.exports = isNative;

            },{
                '../internal/isHostObject': 123,'../internal/isObjectLike': 129,'./isFunction': 145
            }],147: [function (require, module, exports) {
                /**
                 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
                 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                 * @example
                 *
                 * _.isObject({});
                 * // => true
                 *
                 * _.isObject([1, 2, 3]);
                 * // => true
                 *
                 * _.isObject(1);
                 * // => false
                 */
                function isObject(value) {
                    // Avoid a V8 JIT bug in Chrome 19-20.
                    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
                    var type = typeof value;

                    return !!value && (type == 'object' || type == 'function');
                }

                module.exports = isObject;

            },{}],148: [function (require, module, exports) {
                var baseForIn = require('../internal/baseForIn'),
                    isArguments = require('./isArguments'),
                    isHostObject = require('../internal/isHostObject'),
                    isObjectLike = require('../internal/isObjectLike'),
                    support = require('../support');

                /** `Object#toString` result references. */
                var objectTag = '[object Object]';

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /**
                 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objToString = objectProto.toString;

                /**
                 * Checks if `value` is a plain object, that is, an object created by the
                 * `Object` constructor or one with a `[[Prototype]]` of `null`.
                 *
                 * **Note:** This method assumes objects created by the `Object` constructor
                 * have no inherited enumerable properties.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                 * @example
                 *
                 * function Foo() {
         *   this.a = 1;
         * }
                 *
                 * _.isPlainObject(new Foo);
                 * // => false
                 *
                 * _.isPlainObject([1, 2, 3]);
                 * // => false
                 *
                 * _.isPlainObject({ 'x': 0, 'y': 0 });
                 * // => true
                 *
                 * _.isPlainObject(Object.create(null));
                 * // => true
                 */
                function isPlainObject(value) {
                    var Ctor;

                    // Exit early for non `Object` objects.
                    if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value) && !isArguments(value)) ||
                        !hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor))) {
                        return false;
                    }
                    // IE < 9 iterates inherited properties before own properties. If the first
                    // iterated property is an object's own property then there are no inherited
                    // enumerable properties.
                    var result;

                    if (support.ownLast) {
                        baseForIn(value, function (subValue, key, object) {
                            result = hasOwnProperty.call(object, key);

                            return false;
                        });

                        return result !== false;
                    }
                    // In most environments an object's own properties are iterated before
                    // its inherited properties. If the last iterated property is an object's
                    // own property then there are no inherited enumerable properties.
                    baseForIn(value, function (subValue, key) {
                        result = key;
                    });

                    return result === undefined || hasOwnProperty.call(value, result);
                }

                module.exports = isPlainObject;

            },{
                '../internal/baseForIn': 78,'../internal/isHostObject': 123,'../internal/isObjectLike': 129,'../support': 156,'./isArguments': 142
            }],149: [function (require, module, exports) {
                var isObjectLike = require('../internal/isObjectLike');

                /** `Object#toString` result references. */
                var stringTag = '[object String]';

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /**
                 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objToString = objectProto.toString;

                /**
                 * Checks if `value` is classified as a `String` primitive or object.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                 * @example
                 *
                 * _.isString('abc');
                 * // => true
                 *
                 * _.isString(1);
                 * // => false
                 */
                function isString(value) {
                    return typeof value == 'string' || isObjectLike(value) && objToString.call(value) == stringTag;
                }

                module.exports = isString;

            },{
                '../internal/isObjectLike': 129
            }],150: [function (require, module, exports) {
                var isLength = require('../internal/isLength'),
                    isObjectLike = require('../internal/isObjectLike');

                /** `Object#toString` result references. */
                var argsTag = '[object Arguments]',
                    arrayTag = '[object Array]',
                    boolTag = '[object Boolean]',
                    dateTag = '[object Date]',
                    errorTag = '[object Error]',
                    funcTag = '[object Function]',
                    mapTag = '[object Map]',
                    numberTag = '[object Number]',
                    objectTag = '[object Object]',
                    regexpTag = '[object RegExp]',
                    setTag = '[object Set]',
                    stringTag = '[object String]',
                    weakMapTag = '[object WeakMap]';

                var arrayBufferTag = '[object ArrayBuffer]',
                    float32Tag = '[object Float32Array]',
                    float64Tag = '[object Float64Array]',
                    int8Tag = '[object Int8Array]',
                    int16Tag = '[object Int16Array]',
                    int32Tag = '[object Int32Array]',
                    uint8Tag = '[object Uint8Array]',
                    uint8ClampedTag = '[object Uint8ClampedArray]',
                    uint16Tag = '[object Uint16Array]',
                    uint32Tag = '[object Uint32Array]';

                /** Used to identify `toStringTag` values of typed arrays. */
                var typedArrayTags = {};

                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                        typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                            typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                                typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                        typedArrayTags[dateTag] = typedArrayTags[errorTag] =
                            typedArrayTags[funcTag] = typedArrayTags[mapTag] =
                                typedArrayTags[numberTag] = typedArrayTags[objectTag] =
                                    typedArrayTags[regexpTag] = typedArrayTags[setTag] =
                                        typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

                /** Used for native method references. */
                var objectProto = Object.prototype;

                /**
                 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objToString = objectProto.toString;

                /**
                 * Checks if `value` is classified as a typed array.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                 * @example
                 *
                 * _.isTypedArray(new Uint8Array);
                 * // => true
                 *
                 * _.isTypedArray([]);
                 * // => false
                 */
                function isTypedArray(value) {
                    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
                }

                module.exports = isTypedArray;

            },{
                '../internal/isLength': 128,'../internal/isObjectLike': 129
            }],151: [function (require, module, exports) {
                /**
                 * Checks if `value` is `undefined`.
                 *
                 * @static
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                 * @example
                 *
                 * _.isUndefined(void 0);
                 * // => true
                 *
                 * _.isUndefined(null);
                 * // => false
                 */
                function isUndefined(value) {
                    return value === undefined;
                }

                module.exports = isUndefined;

            },{}],152: [function (require, module, exports) {
                var getNative = require('../internal/getNative'),
                    isArrayLike = require('../internal/isArrayLike'),
                    isObject = require('../lang/isObject'),
                    shimKeys = require('../internal/shimKeys'),
                    support = require('../support');

                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeKeys = getNative(Object, 'keys');

                /**
                 * Creates an array of the own enumerable property names of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects. See the
                 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
                 * for more details.
                 *
                 * @static
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 * @example
                 *
                 * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.keys(new Foo);
                 * // => ['a', 'b'] (iteration order is not guaranteed)
                 *
                 * _.keys('hi');
                 * // => ['0', '1']
                 */
                var keys = !nativeKeys ? shimKeys : function (object) {
                    var Ctor = object == null ? undefined : object.constructor;

                    if (typeof Ctor == 'function' && Ctor.prototype === object ||
                        (typeof object == 'function' ? support.enumPrototypes : isArrayLike(object))) {
                        return shimKeys(object);
                    }

                    return isObject(object) ? nativeKeys(object) : [];
                };

                module.exports = keys;

            },{
                '../internal/getNative': 117,'../internal/isArrayLike': 122,'../internal/shimKeys': 137,'../lang/isObject': 147,'../support': 156
            }],153: [function (require, module, exports) {
                var arrayEach = require('../internal/arrayEach'),
                    isArguments = require('../lang/isArguments'),
                    isArray = require('../lang/isArray'),
                    isFunction = require('../lang/isFunction'),
                    isIndex = require('../internal/isIndex'),
                    isLength = require('../internal/isLength'),
                    isObject = require('../lang/isObject'),
                    isString = require('../lang/isString'),
                    support = require('../support');

                /** `Object#toString` result references. */
                var arrayTag = '[object Array]',
                    boolTag = '[object Boolean]',
                    dateTag = '[object Date]',
                    errorTag = '[object Error]',
                    funcTag = '[object Function]',
                    numberTag = '[object Number]',
                    objectTag = '[object Object]',
                    regexpTag = '[object RegExp]',
                    stringTag = '[object String]';

                /** Used to fix the JScript `[[DontEnum]]` bug. */
                var shadowProps = [
                    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
                    'toLocaleString', 'toString', 'valueOf'
                ];

                /** Used for native method references. */
                var errorProto = Error.prototype,
                    objectProto = Object.prototype,
                    stringProto = String.prototype;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /**
                 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objToString = objectProto.toString;

                /** Used to avoid iterating over non-enumerable properties in IE < 9. */
                var nonEnumProps = {};

                nonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = {
                    'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true
                };
                nonEnumProps[boolTag] = nonEnumProps[stringTag] = {
                    'constructor': true, 'toString': true, 'valueOf': true
                };
                nonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = {
                    'constructor': true, 'toString': true
                };
                nonEnumProps[objectTag] = {
                    'constructor': true
                };

                arrayEach(shadowProps, function (key) {
                    for (var tag in nonEnumProps) {
                        if (hasOwnProperty.call(nonEnumProps, tag)) {
                            var props = nonEnumProps[tag];

                            props[key] = hasOwnProperty.call(props, key);
                        }
                    }
                });

                /**
                 * Creates an array of the own and inherited enumerable property names of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects.
                 *
                 * @static
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 * @example
                 *
                 * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.keysIn(new Foo);
                 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                 */
                function keysIn(object) {
                    if (object == null) {
                        return [];
                    }

                    if (!isObject(object)) {
                        object = Object(object);
                    }
                    var length = object.length;

                    length = length && isLength(length) &&
                    (isArray(object) || isArguments(object) || isString(object)) && length || 0;

                    var Ctor = object.constructor,
                        index = -1,
                        proto = isFunction(Ctor) && Ctor.prototype || objectProto,
                        isProto = proto === object,
                        result = Array(length),
                        skipIndexes = length > 0,
                        skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),
                        skipProto = support.enumPrototypes && isFunction(object);

                    while (++index < length) {
                        result[index] = index + '';
                    }
                    // lodash skips the `constructor` property when it infers it is iterating
                    // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`
                    // attribute of an existing property and the `constructor` property of a
                    // prototype defaults to non-enumerable.
                    for (var key in object) {
                        if (!(skipProto && key == 'prototype') &&
                            !(skipErrorProps && (key == 'message' || key == 'name')) &&
                            !(skipIndexes && isIndex(key, length)) &&
                            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                            result.push(key);
                        }
                    }

                    if (support.nonEnumShadows && object !== objectProto) {
                        var tag = object === stringProto ? stringTag : object === errorProto ? errorTag : objToString.call(object),
                            nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];

                        if (tag == objectTag) {
                            proto = objectProto;
                        }
                        length = shadowProps.length;

                        while (length--) {
                            key = shadowProps[length];
                            var nonEnum = nonEnums[key];

                            if (!(isProto && nonEnum) &&
                                (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {
                                result.push(key);
                            }
                        }
                    }

                    return result;
                }

                module.exports = keysIn;

            },{
                '../internal/arrayEach': 66,'../internal/isIndex': 124,'../internal/isLength': 128,'../lang/isArguments': 142,'../lang/isArray': 143,'../lang/isFunction': 145,'../lang/isObject': 147,'../lang/isString': 149,'../support': 156
            }],154: [function (require, module, exports) {
                var keys = require('./keys'),
                    toObject = require('../internal/toObject');

                /**
                 * Creates a two dimensional array of the key-value pairs for `object`,
                 * e.g. `[[key1, value1], [key2, value2]]`.
                 *
                 * @static
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the new array of key-value pairs.
                 * @example
                 *
                 * _.pairs({ 'barney': 36, 'fred': 40 });
                 * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
                 */
                function pairs(object) {
                    object = toObject(object);

                    var index = -1,
                        props = keys(object),
                        length = props.length,
                        result = Array(length);

                    while (++index < length) {
                        var key = props[index];

                        result[index] = [key, object[key]];
                    }

                    return result;
                }

                module.exports = pairs;

            },{
                '../internal/toObject': 138,'./keys': 152
            }],155: [function (require, module, exports) {
                var baseValues = require('../internal/baseValues'),
                    keys = require('./keys');

                /**
                 * Creates an array of the own enumerable property values of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects.
                 *
                 * @static
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property values.
                 * @example
                 *
                 * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.values(new Foo);
                 * // => [1, 2] (iteration order is not guaranteed)
                 *
                 * _.values('hi');
                 * // => ['h', 'i']
                 */
                function values(object) {
                    return baseValues(object, keys(object));
                }

                module.exports = values;

            },{
                '../internal/baseValues': 94,'./keys': 152
            }],156: [function (require, module, exports) {
                /** Used for native method references. */
                var arrayProto = Array.prototype,
                    errorProto = Error.prototype,
                    objectProto = Object.prototype;

                /** Native method references. */
                var propertyIsEnumerable = objectProto.propertyIsEnumerable,
                    splice = arrayProto.splice;

                /**
                 * An object environment feature flags.
                 *
                 * @static
                 * @memberOf _
                 * @type Object
                 */
                var support = {};

                (function (x) {
                    var Ctor = function () {
                        this.x = x;
                    },
                        object = {
                        '0': x, 'length': x
                    },
                        props = [];

                    Ctor.prototype = {
                        'valueOf': x, 'y': x
                    };

                    for (var key in new Ctor) {
                        props.push(key);
                    }

                    /**
                     * Detect if `name` or `message` properties of `Error.prototype` are
                     * enumerable by default (IE < 9, Safari < 5.1).
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||
                    propertyIsEnumerable.call(errorProto, 'name');

                    /**
                     * Detect if `prototype` properties are enumerable by default.
                     *
                     * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
                     * (if the prototype or a property on the prototype has been set)
                     * incorrectly set the `[[Enumerable]]` value of a function's `prototype`
                     * property to `true`.
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');

                    /**
                     * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
                     *
                     * In IE < 9 an object's own properties, shadowing non-enumerable ones,
                     * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.nonEnumShadows = !/valueOf/.test(props);

                    /**
                     * Detect if own properties are iterated after inherited properties (IE < 9).
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.ownLast = props[0] != 'x';

                    /**
                     * Detect if `Array#shift` and `Array#splice` augment array-like objects
                     * correctly.
                     *
                     * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array
                     * `shift()` and `splice()` functions that fail to remove the last element,
                     * `value[0]`, of array-like objects even though the "length" property is
                     * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,
                     * while `splice()` is buggy regardless of mode in IE < 9.
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.spliceObjects = (splice.call(object, 0, 1), !object[0]);

                    /**
                     * Detect lack of support for accessing string characters by index.
                     *
                     * IE < 8 can't access characters by index. IE 8 can only access characters
                     * by index on string literals, not string objects.
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.unindexedChars = 'x'[0] + Object('x')[0] != 'xx';
                }(1, 0));

                module.exports = support;

            },{}],157: [function (require, module, exports) {
                /**
                 * This method returns the first argument provided to it.
                 *
                 * @static
                 * @memberOf _
                 * @category Utility
                 * @param {*} value Any value.
                 * @returns {*} Returns `value`.
                 * @example
                 *
                 * var object = { 'user': 'fred' };
                 *
                 * _.identity(object) === object;
                 * // => true
                 */
                function identity(value) {
                    return value;
                }

                module.exports = identity;

            },{}],158: [function (require, module, exports) {
                /**
                 * A no-operation function that returns `undefined` regardless of the
                 * arguments it receives.
                 *
                 * @static
                 * @memberOf _
                 * @category Utility
                 * @example
                 *
                 * var object = { 'user': 'fred' };
                 *
                 * _.noop(object) === undefined;
                 * // => true
                 */
                function noop() {
                    // No operation performed.
                }

                module.exports = noop;

            },{}],159: [function (require, module, exports) {
                var baseProperty = require('../internal/baseProperty'),
                    basePropertyDeep = require('../internal/basePropertyDeep'),
                    isKey = require('../internal/isKey');

                /**
                 * Creates a function that returns the property value at `path` on a
                 * given object.
                 *
                 * @static
                 * @memberOf _
                 * @category Utility
                 * @param {Array|string} path The path of the property to get.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var objects = [
                 *   { 'a': { 'b': { 'c': 2 } } },
                 *   { 'a': { 'b': { 'c': 1 } } }
                 * ];
                 *
                 * _.map(objects, _.property('a.b.c'));
                 * // => [2, 1]
                 *
                 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
                 * // => [1, 2]
                 */
                function property(path) {
                    return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
                }

                module.exports = property;

            },{
                '../internal/baseProperty': 89,'../internal/basePropertyDeep': 90,'../internal/isKey': 126
            }],160: [function (require, module, exports) {
                /**
                 * Module dependencies.
                 */

                var Emitter = require('emitter');
                var reduce = require('reduce');

                /**
                 * Root reference for iframes.
                 */

                var root = 'undefined' == typeof window ?
                    this || self
                    : window;

                /**
                 * Noop.
                 */

                function noop() {}

                /**
                 * Check if `obj` is a host object,
                 * we don't want to serialize these :)
                 *
                 * TODO: future proof, move to compoent land
                 *
                 * @param {Object} obj
                 * @return {Boolean}
                 * @api private
                 */

                function isHost(obj) {
                    var str = {}.toString.call(obj);

                    switch (str) {
                        case '[object File]':
                        case '[object Blob]':
                        case '[object FormData]':
                            return true;
                        default:
                            return false;
                    }
                }

                /**
                 * Determine XHR.
                 */

                request.getXHR = function () {
                    if (root.XMLHttpRequest &&
                        (!root.location || 'file:' != root.location.protocol ||
                        !root.ActiveXObject)) {
                        return new XMLHttpRequest;
                    }

                    try {
                        return new ActiveXObject('Microsoft.XMLHTTP');
                    } catch (e) {}

                    try {
                        return new ActiveXObject('Msxml2.XMLHTTP.6.0');
                    } catch (e) {}

                    try {
                        return new ActiveXObject('Msxml2.XMLHTTP.3.0');
                    } catch (e) {}

                    try {
                        return new ActiveXObject('Msxml2.XMLHTTP');
                    } catch (e) {}

                    return false;
                };

                /**
                 * Removes leading and trailing whitespace, added to support IE.
                 *
                 * @param {String} s
                 * @return {String}
                 * @api private
                 */

                var trim = ''.trim ?
                    function (s) {
                    return s.trim();
                }
                    : function (s) {
                    return s.replace(/(^\s*|\s*$)/g, '');
                };

                /**
                 * Check if `obj` is an object.
                 *
                 * @param {Object} obj
                 * @return {Boolean}
                 * @api private
                 */

                function isObject(obj) {
                    return obj === Object(obj);
                }

                /**
                 * Serialize the given `obj`.
                 *
                 * @param {Object} obj
                 * @return {String}
                 * @api private
                 */

                function serialize(obj) {
                    if (!isObject(obj)) return obj;
                    var pairs = [];

                    for (var key in obj) {
                        if (null != obj[key]) {
                            pairs.push(encodeURIComponent(key) +
                            '=' + encodeURIComponent(obj[key]));
                        }
                    }

                    return pairs.join('&');
                }

                /**
                 * Expose serialization method.
                 */

                request.serializeObject = serialize;

                /**
                 * Parse the given x-www-form-urlencoded `str`.
                 *
                 * @param {String} str
                 * @return {Object}
                 * @api private
                 */

                function parseString(str) {
                    var obj = {};
                    var pairs = str.split('&');
                    var parts;
                    var pair;

                    for (var i = 0, len = pairs.length; i < len; ++i) {
                        pair = pairs[i];
                        parts = pair.split('=');
                        obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
                    }

                    return obj;
                }

                /**
                 * Expose parser.
                 */

                request.parseString = parseString;

                /**
                 * Default MIME type map.
                 *
                 *     superagent.types.xml = 'application/xml';
                 *
                 */

                request.types = {
                    html: 'text/html',
                    json: 'application/json',
                    xml: 'application/xml',
                    urlencoded: 'application/x-www-form-urlencoded',
                    'form': 'application/x-www-form-urlencoded',
                    'form-data': 'application/x-www-form-urlencoded'
                };

                /**
                 * Default serialization map.
                 *
                 *     superagent.serialize['application/xml'] = function(obj){
         *       return 'generated xml here';
         *     };
                 *
                 */

                request.serialize = {
                    'application/x-www-form-urlencoded': serialize,
                    'application/json': JSON.stringify
                };

                /**
                 * Default parsers.
                 *
                 *     superagent.parse['application/xml'] = function(str){
          *       return { object parsed from str };
          *     };
                 *
                 */

                request.parse = {
                    'application/x-www-form-urlencoded': parseString,
                    'application/json': JSON.parse
                };

                /**
                 * Parse the given header `str` into
                 * an object containing the mapped fields.
                 *
                 * @param {String} str
                 * @return {Object}
                 * @api private
                 */

                function parseHeader(str) {
                    var lines = str.split(/\r?\n/);
                    var fields = {};
                    var index;
                    var line;
                    var field;
                    var val;

                    lines.pop(); // trailing CRLF

                    for (var i = 0, len = lines.length; i < len; ++i) {
                        line = lines[i];
                        index = line.indexOf(':');
                        field = line.slice(0, index).toLowerCase();
                        val = trim(line.slice(index + 1));
                        fields[field] = val;
                    }

                    return fields;
                }

                /**
                 * Return the mime type for the given `str`.
                 *
                 * @param {String} str
                 * @return {String}
                 * @api private
                 */

                function type(str) {
                    return str.split(/ *; */).shift();
                }

                /**
                 * Return header field parameters.
                 *
                 * @param {String} str
                 * @return {Object}
                 * @api private
                 */

                function params(str) {
                    return reduce(str.split(/ *; */), function (obj, str) {
                        var parts = str.split(/ *= */),
 key = parts.shift(),
 val = parts.shift();

                        if (key && val) obj[key] = val;

                        return obj;
                    }, {});
                }

                /**
                 * Initialize a new `Response` with the given `xhr`.
                 *
                 *  - set flags (.ok, .error, etc)
                 *  - parse header
                 *
                 * Examples:
                 *
                 *  Aliasing `superagent` as `request` is nice:
                 *
                 *      request = superagent;
                 *
                 *  We can use the promise-like API, or pass callbacks:
                 *
                 *      request.get('/').end(function(res){});
                 *      request.get('/', function(res){});
                 *
                 *  Sending data can be chained:
                 *
                 *      request
                 *        .post('/user')
                 *        .send({ name: 'tj' })
                 *        .end(function(res){});
                 *
                 *  Or passed to `.send()`:
                 *
                 *      request
                 *        .post('/user')
                 *        .send({ name: 'tj' }, function(res){});
                 *
                 *  Or passed to `.post()`:
                 *
                 *      request
                 *        .post('/user', { name: 'tj' })
                 *        .end(function(res){});
                 *
                 * Or further reduced to a single call for simple cases:
                 *
                 *      request
                 *        .post('/user', { name: 'tj' }, function(res){});
                 *
                 * @param {XMLHTTPRequest} xhr
                 * @param {Object} options
                 * @api private
                 */

                function Response(req, options) {
                    options = options || {};
                    this.req = req;
                    this.xhr = this.req.xhr;
                    // responseText is accessible only if responseType is '' or 'text' and on older browsers
                    this.text = this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ?
                        this.xhr.responseText
                        : null;
                    this.statusText = this.req.xhr.statusText;
                    this.setStatusProperties(this.xhr.status);
                    this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
                    // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
                    // getResponseHeader still works. so we get content-type even if getting
                    // other headers fails.
                    this.header['content-type'] = this.xhr.getResponseHeader('content-type');
                    this.setHeaderProperties(this.header);
                    this.body = this.req.method != 'HEAD' ?
                        this.parseBody(this.text ? this.text : this.xhr.response)
                        : null;
                }

                /**
                 * Get case-insensitive `field` value.
                 *
                 * @param {String} field
                 * @return {String}
                 * @api public
                 */

                Response.prototype.get = function (field) {
                    return this.header[field.toLowerCase()];
                };

                /**
                 * Set header related properties:
                 *
                 *   - `.type` the content type without params
                 *
                 * A response of "Content-Type: text/plain; charset=utf-8"
                 * will provide you with a `.type` of "text/plain".
                 *
                 * @param {Object} header
                 * @api private
                 */

                Response.prototype.setHeaderProperties = function (header) {
                    // content-type
                    var ct = this.header['content-type'] || '';

                    this.type = type(ct);

                    // params
                    var obj = params(ct);

                    for (var key in obj) this[key] = obj[key];
                };

                /**
                 * Parse the given body `str`.
                 *
                 * Used for auto-parsing of bodies. Parsers
                 * are defined on the `superagent.parse` object.
                 *
                 * @param {String} str
                 * @return {Mixed}
                 * @api private
                 */

                Response.prototype.parseBody = function (str) {
                    var parse = request.parse[this.type];

                    return parse && str && (str.length || str instanceof Object) ?
                        parse(str)
                        : null;
                };

                /**
                 * Set flags such as `.ok` based on `status`.
                 *
                 * For example a 2xx response will give you a `.ok` of __true__
                 * whereas 5xx will be __false__ and `.error` will be __true__. The
                 * `.clientError` and `.serverError` are also available to be more
                 * specific, and `.statusType` is the class of error ranging from 1..5
                 * sometimes useful for mapping respond colors etc.
                 *
                 * "sugar" properties are also defined for common cases. Currently providing:
                 *
                 *   - .noContent
                 *   - .badRequest
                 *   - .unauthorized
                 *   - .notAcceptable
                 *   - .notFound
                 *
                 * @param {Number} status
                 * @api private
                 */

                Response.prototype.setStatusProperties = function (status) {
                    // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
                    if (status === 1223) {
                        status = 204;
                    }

                    var type = status / 100 | 0;

                    // status / class
                    this.status = status;
                    this.statusType = type;

                    // basics
                    this.info = 1 == type;
                    this.ok = 2 == type;
                    this.clientError = 4 == type;
                    this.serverError = 5 == type;
                    this.error = 4 == type || 5 == type ?
                        this.toError()
                        : false;

                    // sugar
                    this.accepted = 202 == status;
                    this.noContent = 204 == status;
                    this.badRequest = 400 == status;
                    this.unauthorized = 401 == status;
                    this.notAcceptable = 406 == status;
                    this.notFound = 404 == status;
                    this.forbidden = 403 == status;
                };

                /**
                 * Return an `Error` representative of this response.
                 *
                 * @return {Error}
                 * @api public
                 */

                Response.prototype.toError = function () {
                    var req = this.req;
                    var method = req.method;
                    var url = req.url;

                    var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
                    var err = new Error(msg);

                    err.status = this.status;
                    err.method = method;
                    err.url = url;

                    return err;
                };

                /**
                 * Expose `Response`.
                 */

                request.Response = Response;

                /**
                 * Initialize a new `Request` with the given `method` and `url`.
                 *
                 * @param {String} method
                 * @param {String} url
                 * @api public
                 */

                function Request(method, url) {
                    var self = this;

                    Emitter.call(this);
                    this._query = this._query || [];
                    this.method = method;
                    this.url = url;
                    this.header = {};
                    this._header = {};
                    this.on('end', function () {
                        var err = null;
                        var res = null;

                        try {
                            res = new Response(self);
                        } catch (e) {
                            err = new Error('Parser is unable to parse the response');
                            err.parse = true;
                            err.original = e;

                            return self.callback(err);
                        }

                        self.emit('response', res);

                        if (err) {
                            return self.callback(err, res);
                        }

                        if (res.status >= 200 && res.status < 300) {
                            return self.callback(err, res);
                        }

                        var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');

                        new_err.original = err;
                        new_err.response = res;
                        new_err.status = res.status;

                        self.callback(err || new_err, res);
                    });
                }

                /**
                 * Mixin `Emitter`.
                 */

                Emitter(Request.prototype);

                /**
                 * Allow for extension
                 */

                Request.prototype.use = function (fn) {
                    fn(this);

                    return this;
                };

                /**
                 * Set timeout to `ms`.
                 *
                 * @param {Number} ms
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.timeout = function (ms) {
                    this._timeout = ms;

                    return this;
                };

                /**
                 * Clear previous timeout.
                 *
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.clearTimeout = function () {
                    this._timeout = 0;
                    clearTimeout(this._timer);

                    return this;
                };

                /**
                 * Abort the request, and clear potential timeout.
                 *
                 * @return {Request}
                 * @api public
                 */

                Request.prototype.abort = function () {
                    if (this.aborted) return;
                    this.aborted = true;
                    this.xhr.abort();
                    this.clearTimeout();
                    this.emit('abort');

                    return this;
                };

                /**
                 * Set header `field` to `val`, or multiple fields with one object.
                 *
                 * Examples:
                 *
                 *      req.get('/')
                 *        .set('Accept', 'application/json')
                 *        .set('X-API-Key', 'foobar')
                 *        .end(callback);
                 *
                 *      req.get('/')
                 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
                 *        .end(callback);
                 *
                 * @param {String|Object} field
                 * @param {String} val
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.set = function (field, val) {
                    if (isObject(field)) {
                        for (var key in field) {
                            this.set(key, field[key]);
                        }

                        return this;
                    }
                    this._header[field.toLowerCase()] = val;
                    this.header[field] = val;

                    return this;
                };

                /**
                 * Remove header `field`.
                 *
                 * Example:
                 *
                 *      req.get('/')
                 *        .unset('User-Agent')
                 *        .end(callback);
                 *
                 * @param {String} field
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.unset = function (field) {
                    delete this._header[field.toLowerCase()];
                    delete this.header[field];

                    return this;
                };

                /**
                 * Get case-insensitive header `field` value.
                 *
                 * @param {String} field
                 * @return {String}
                 * @api private
                 */

                Request.prototype.getHeader = function (field) {
                    return this._header[field.toLowerCase()];
                };

                /**
                 * Set Content-Type to `type`, mapping values from `request.types`.
                 *
                 * Examples:
                 *
                 *      superagent.types.xml = 'application/xml';
                 *
                 *      request.post('/')
                 *        .type('xml')
                 *        .send(xmlstring)
                 *        .end(callback);
                 *
                 *      request.post('/')
                 *        .type('application/xml')
                 *        .send(xmlstring)
                 *        .end(callback);
                 *
                 * @param {String} type
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.type = function (type) {
                    this.set('Content-Type', request.types[type] || type);

                    return this;
                };

                /**
                 * Set Accept to `type`, mapping values from `request.types`.
                 *
                 * Examples:
                 *
                 *      superagent.types.json = 'application/json';
                 *
                 *      request.get('/agent')
                 *        .accept('json')
                 *        .end(callback);
                 *
                 *      request.get('/agent')
                 *        .accept('application/json')
                 *        .end(callback);
                 *
                 * @param {String} accept
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.accept = function (type) {
                    this.set('Accept', request.types[type] || type);

                    return this;
                };

                /**
                 * Set Authorization field value with `user` and `pass`.
                 *
                 * @param {String} user
                 * @param {String} pass
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.auth = function (user, pass) {
                    var str = btoa(user + ':' + pass);

                    this.set('Authorization', 'Basic ' + str);

                    return this;
                };

                /**
                 * Add query-string `val`.
                 *
                 * Examples:
                 *
                 *   request.get('/shoes')
                 *     .query('size=10')
                 *     .query({ color: 'blue' })
                 *
                 * @param {Object|String} val
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.query = function (val) {
                    if ('string' != typeof val) val = serialize(val);

                    if (val) this._query.push(val);

                    return this;
                };

                /**
                 * Write the field `name` and `val` for "multipart/form-data"
                 * request bodies.
                 *
                 * ``` js
                 * request.post('/upload')
                 *   .field('foo', 'bar')
                 *   .end(callback);
                 * ```
                 *
                 * @param {String} name
                 * @param {String|Blob|File} val
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.field = function (name, val) {
                    if (!this._formData) this._formData = new root.FormData();
                    this._formData.append(name, val);

                    return this;
                };

                /**
                 * Queue the given `file` as an attachment to the specified `field`,
                 * with optional `filename`.
                 *
                 * ``` js
                 * request.post('/upload')
                 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
                 *   .end(callback);
                 * ```
                 *
                 * @param {String} field
                 * @param {Blob|File} file
                 * @param {String} filename
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.attach = function (field, file, filename) {
                    if (!this._formData) this._formData = new root.FormData();
                    this._formData.append(field, file, filename);

                    return this;
                };

                /**
                 * Send `data`, defaulting the `.type()` to "json" when
                 * an object is given.
                 *
                 * Examples:
                 *
                 *       // querystring
                 *       request.get('/search')
                 *         .end(callback)
                 *
                 *       // multiple data "writes"
                 *       request.get('/search')
                 *         .send({ search: 'query' })
                 *         .send({ range: '1..5' })
                 *         .send({ order: 'desc' })
                 *         .end(callback)
                 *
                 *       // manual json
                 *       request.post('/user')
                 *         .type('json')
                 *         .send('{"name":"tj"})
                 *         .end(callback)
                 *
                 *       // auto json
                 *       request.post('/user')
                 *         .send({ name: 'tj' })
                 *         .end(callback)
                 *
                 *       // manual x-www-form-urlencoded
                 *       request.post('/user')
                 *         .type('form')
                 *         .send('name=tj')
                 *         .end(callback)
                 *
                 *       // auto x-www-form-urlencoded
                 *       request.post('/user')
                 *         .type('form')
                 *         .send({ name: 'tj' })
                 *         .end(callback)
                 *
                 *       // defaults to x-www-form-urlencoded
                 *      request.post('/user')
                 *        .send('name=tobi')
                 *        .send('species=ferret')
                 *        .end(callback)
                 *
                 * @param {String|Object} data
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.send = function (data) {
                    var obj = isObject(data);
                    var type = this.getHeader('Content-Type');

                    // merge
                    if (obj && isObject(this._data)) {
                        for (var key in data) {
                            this._data[key] = data[key];
                        }
                    } else if ('string' == typeof data) {
                        if (!type) this.type('form');
                        type = this.getHeader('Content-Type');

                        if ('application/x-www-form-urlencoded' == type) {
                            this._data = this._data ?
                                this._data + '&' + data
                                : data;
                        } else {
                            this._data = (this._data || '') + data;
                        }
                    } else {
                        this._data = data;
                    }

                    if (!obj || isHost(data)) return this;

                    if (!type) this.type('json');

                    return this;
                };

                /**
                 * Invoke the callback with `err` and `res`
                 * and handle arity check.
                 *
                 * @param {Error} err
                 * @param {Response} res
                 * @api private
                 */

                Request.prototype.callback = function (err, res) {
                    var fn = this._callback;

                    this.clearTimeout();
                    fn(err, res);
                };

                /**
                 * Invoke callback with x-domain error.
                 *
                 * @api private
                 */

                Request.prototype.crossDomainError = function () {
                    var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');

                    err.crossDomain = true;
                    this.callback(err);
                };

                /**
                 * Invoke callback with timeout error.
                 *
                 * @api private
                 */

                Request.prototype.timeoutError = function () {
                    var timeout = this._timeout;
                    var err = new Error('timeout of ' + timeout + 'ms exceeded');

                    err.timeout = timeout;
                    this.callback(err);
                };

                /**
                 * Enable transmission of cookies with x-domain requests.
                 *
                 * Note that for this to work the origin must not be
                 * using "Access-Control-Allow-Origin" with a wildcard,
                 * and also must set "Access-Control-Allow-Credentials"
                 * to "true".
                 *
                 * @api public
                 */

                Request.prototype.withCredentials = function () {
                    this._withCredentials = true;

                    return this;
                };

                /**
                 * Initiate request, invoking callback `fn(res)`
                 * with an instanceof `Response`.
                 *
                 * @param {Function} fn
                 * @return {Request} for chaining
                 * @api public
                 */

                Request.prototype.end = function (fn) {
                    var self = this;
                    var xhr = this.xhr = request.getXHR();
                    var query = this._query.join('&');
                    var timeout = this._timeout;
                    var data = this._formData || this._data;

                    // store callback
                    this._callback = fn || noop;

                    // state change
                    xhr.onreadystatechange = function () {
                        if (4 != xhr.readyState) return;

                        // In IE9, reads to any property (e.g. status) off of an aborted XHR will
                        // result in the error "Could not complete the operation due to error c00c023f"
                        var status;

                        try {
                            status = xhr.status;
                        } catch (e) {
                            status = 0;
                        }

                        if (0 == status) {
                            if (self.timedout) return self.timeoutError();

                            if (self.aborted) return;

                            return self.crossDomainError();
                        }
                        self.emit('end');
                    };

                    // progress
                    var handleProgress = function (e) {
                        if (e.total > 0) {
                            e.percent = e.loaded / e.total * 100;
                        }
                        self.emit('progress', e);
                    };

                    if (this.hasListeners('progress')) {
                        xhr.onprogress = handleProgress;
                    }

                    try {
                        if (xhr.upload && this.hasListeners('progress')) {
                            xhr.upload.onprogress = handleProgress;
                        }
                    } catch (e) {
                        // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
                        // Reported here:
                        // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
                    }

                    // timeout
                    if (timeout && !this._timer) {
                        this._timer = setTimeout(function () {
                            self.timedout = true;
                            self.abort();
                        }, timeout);
                    }

                    // querystring
                    if (query) {
                        query = request.serializeObject(query);
                        this.url += ~this.url.indexOf('?') ?
                            '&' + query
                            : '?' + query;
                    }

                    // initiate request
                    xhr.open(this.method, this.url, true);

                    // CORS
                    if (this._withCredentials) xhr.withCredentials = true;

                    // body
                    if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
                        // serialize stuff
                        var serialize = request.serialize[this.getHeader('Content-Type')];

                        if (serialize) data = serialize(data);
                    }

                    // set header fields
                    for (var field in this.header) {
                        if (null == this.header[field]) continue;
                        xhr.setRequestHeader(field, this.header[field]);
                    }

                    // send stuff
                    this.emit('request', this);
                    xhr.send(data);

                    return this;
                };

                /**
                 * Expose `Request`.
                 */

                request.Request = Request;

                /**
                 * Issue a request:
                 *
                 * Examples:
                 *
                 *    request('GET', '/users').end(callback)
                 *    request('/users').end(callback)
                 *    request('/users', callback)
                 *
                 * @param {String} method
                 * @param {String|Function} url or callback
                 * @return {Request}
                 * @api public
                 */

                function request(method, url) {
                    // callback
                    if ('function' == typeof url) {
                        return new Request('GET', method).end(url);
                    }

                    // url first
                    if (1 == arguments.length) {
                        return new Request('GET', method);
                    }

                    return new Request(method, url);
                }

                /**
                 * GET `url` with optional callback `fn(res)`.
                 *
                 * @param {String} url
                 * @param {Mixed|Function} data or fn
                 * @param {Function} fn
                 * @return {Request}
                 * @api public
                 */

                request.get = function (url, data, fn) {
                    var req = request('GET', url);

                    if ('function' == typeof data) fn = data, data = null;

                    if (data) req.query(data);

                    if (fn) req.end(fn);

                    return req;
                };

                /**
                 * HEAD `url` with optional callback `fn(res)`.
                 *
                 * @param {String} url
                 * @param {Mixed|Function} data or fn
                 * @param {Function} fn
                 * @return {Request}
                 * @api public
                 */

                request.head = function (url, data, fn) {
                    var req = request('HEAD', url);

                    if ('function' == typeof data) fn = data, data = null;

                    if (data) req.send(data);

                    if (fn) req.end(fn);

                    return req;
                };

                /**
                 * DELETE `url` with optional callback `fn(res)`.
                 *
                 * @param {String} url
                 * @param {Function} fn
                 * @return {Request}
                 * @api public
                 */

                request.del = function (url, fn) {
                    var req = request('DELETE', url);

                    if (fn) req.end(fn);

                    return req;
                };

                /**
                 * PATCH `url` with optional `data` and callback `fn(res)`.
                 *
                 * @param {String} url
                 * @param {Mixed} data
                 * @param {Function} fn
                 * @return {Request}
                 * @api public
                 */

                request.patch = function (url, data, fn) {
                    var req = request('PATCH', url);

                    if ('function' == typeof data) fn = data, data = null;

                    if (data) req.send(data);

                    if (fn) req.end(fn);

                    return req;
                };

                /**
                 * POST `url` with optional `data` and callback `fn(res)`.
                 *
                 * @param {String} url
                 * @param {Mixed} data
                 * @param {Function} fn
                 * @return {Request}
                 * @api public
                 */

                request.post = function (url, data, fn) {
                    var req = request('POST', url);

                    if ('function' == typeof data) fn = data, data = null;

                    if (data) req.send(data);

                    if (fn) req.end(fn);

                    return req;
                };

                /**
                 * PUT `url` with optional `data` and callback `fn(res)`.
                 *
                 * @param {String} url
                 * @param {Mixed|Function} data or fn
                 * @param {Function} fn
                 * @return {Request}
                 * @api public
                 */

                request.put = function (url, data, fn) {
                    var req = request('PUT', url);

                    if ('function' == typeof data) fn = data, data = null;

                    if (data) req.send(data);

                    if (fn) req.end(fn);

                    return req;
                };

                /**
                 * Expose `request`.
                 */

                module.exports = request;

            },{
                'emitter': 161,'reduce': 162
            }],161: [function (require, module, exports) {

                /**
                 * Expose `Emitter`.
                 */

                module.exports = Emitter;

                /**
                 * Initialize a new `Emitter`.
                 *
                 * @api public
                 */

                function Emitter(obj) {
                    if (obj) return mixin(obj);
                }

                /**
                 * Mixin the emitter properties.
                 *
                 * @param {Object} obj
                 * @return {Object}
                 * @api private
                 */

                function mixin(obj) {
                    for (var key in Emitter.prototype) {
                        obj[key] = Emitter.prototype[key];
                    }

                    return obj;
                }

                /**
                 * Listen on the given `event` with `fn`.
                 *
                 * @param {String} event
                 * @param {Function} fn
                 * @return {Emitter}
                 * @api public
                 */

                Emitter.prototype.on =
                    Emitter.prototype.addEventListener = function (event, fn) {
                        this._callbacks = this._callbacks || {};
                        (this._callbacks[event] = this._callbacks[event] || [])
                            .push(fn);

                        return this;
                    };

                /**
                 * Adds an `event` listener that will be invoked a single
                 * time then automatically removed.
                 *
                 * @param {String} event
                 * @param {Function} fn
                 * @return {Emitter}
                 * @api public
                 */

                Emitter.prototype.once = function (event, fn) {
                    var self = this;

                    this._callbacks = this._callbacks || {};

                    function on() {
                        self.off(event, on);
                        fn.apply(this, arguments);
                    }

                    on.fn = fn;
                    this.on(event, on);

                    return this;
                };

                /**
                 * Remove the given callback for `event` or all
                 * registered callbacks.
                 *
                 * @param {String} event
                 * @param {Function} fn
                 * @return {Emitter}
                 * @api public
                 */

                Emitter.prototype.off =
                    Emitter.prototype.removeListener =
                        Emitter.prototype.removeAllListeners =
                            Emitter.prototype.removeEventListener = function (event, fn) {
                                this._callbacks = this._callbacks || {};

                                // all
                                if (0 == arguments.length) {
                                    this._callbacks = {};

                                    return this;
                                }

                                // specific event
                                var callbacks = this._callbacks[event];

                                if (!callbacks) return this;

                                // remove all handlers
                                if (1 == arguments.length) {
                                    delete this._callbacks[event];

                                    return this;
                                }

                                // remove specific handler
                                var cb;

                                for (var i = 0; i < callbacks.length; i++) {
                                    cb = callbacks[i];

                                    if (cb === fn || cb.fn === fn) {
                                        callbacks.splice(i, 1);
                                        break;
                                    }
                                }

                                return this;
                            };

                /**
                 * Emit `event` with the given args.
                 *
                 * @param {String} event
                 * @param {Mixed} ...
                 * @return {Emitter}
                 */

                Emitter.prototype.emit = function (event) {
                    this._callbacks = this._callbacks || {};
                    var args = [].slice.call(arguments, 1),
 callbacks = this._callbacks[event];

                    if (callbacks) {
                        callbacks = callbacks.slice(0);

                        for (var i = 0, len = callbacks.length; i < len; ++i) {
                            callbacks[i].apply(this, args);
                        }
                    }

                    return this;
                };

                /**
                 * Return array of callbacks for `event`.
                 *
                 * @param {String} event
                 * @return {Array}
                 * @api public
                 */

                Emitter.prototype.listeners = function (event) {
                    this._callbacks = this._callbacks || {};

                    return this._callbacks[event] || [];
                };

                /**
                 * Check if this emitter has `event` handlers.
                 *
                 * @param {String} event
                 * @return {Boolean}
                 * @api public
                 */

                Emitter.prototype.hasListeners = function (event) {
                    return !!this.listeners(event).length;
                };

            },{}],162: [function (require, module, exports) {

                /**
                 * Reduce `arr` with `fn`.
                 *
                 * @param {Array} arr
                 * @param {Function} fn
                 * @param {Mixed} initial
                 *
                 * TODO: combatible error handling?
                 */

                module.exports = function (arr, fn, initial) {
                    var idx = 0;
                    var len = arr.length;
                    var curr = arguments.length == 3 ?
                        initial
                        : arr[idx++];

                    while (idx < len) {
                        curr = fn.call(null, curr, arr[idx], ++idx, arr);
                    }

                    return curr;
                };
            },{}]
        }, {}, [1])(1);
    });

    'use strict';

    window.SwaggerUi = Backbone.Router.extend({

        dom_id: 'swagger_ui',

        // Attributes
        options: null,
        api: null,
        headerView: null,
        mainView: null,

        // SwaggerUi accepts all the same options as SwaggerApi
        initialize: function (options) {
            options = options || {};

            if (!options.highlightSizeThreshold) {
                options.highlightSizeThreshold = 100000;
            }

            // Allow dom_id to be overridden
            if (options.dom_id) {
                this.dom_id = options.dom_id;
                delete options.dom_id;
            }

            if (!options.supportedSubmitMethods) {
                options.supportedSubmitMethods = [
                    'get',
                    'put',
                    'post',
                    'delete',
                    'head',
                    'options',
                    'patch'
                ];
            }

            if (typeof options.oauth2RedirectUrl === 'string') {
                window.oAuthRedirectUrl = options.redirectUrl;
            }

            // Create an empty div which contains the dom_id
            if (!$('#' + this.dom_id).length) {
                $('body').append('<div id="' + this.dom_id + '"></div>');
            }

            this.options = options;

            // set marked options
            marked.setOptions({
                gfm: true
            });

            // Set the callbacks
            var that = this;

            this.options.success = function () {
                return that.render();
            };
            this.options.progress = function (d) {
                return that.showMessage(d);
            };
            this.options.failure = function (d) {
                return that.onLoadFailure(d);
            };

            // Create view to handle the header inputs
            this.headerView = new SwaggerUi.Views.HeaderView({
                el: $('#header')
            });

            // Event handler for when the baseUrl/apiKey is entered by user
            this.headerView.on('update-swagger-ui', function (data) {
                return that.updateSwaggerUi(data);
            });
        },

        // Set an option after initializing
        setOption: function (option, value) {
            this.options[option] = value;
        },

        // Get the value of a previously set option
        getOption: function (option) {
            return this.options[option];
        },

        // Event handler for when url/key is received from user
        updateSwaggerUi: function (data) {
            this.options.url = data.url;
            this.load();
        },

        // Create an api and render
        load: function () {
            // Initialize the API object
            if (this.mainView) {
                this.mainView.clear();
            }
            var url = this.options.url;

            if (url && url.indexOf('http') !== 0) {
                url = this.buildUrl(window.location.href.toString(), url);
            }

            if (this.api) {
                this.options.authorizations = this.api.clientAuthorizations.authz;
            }
            this.options.url = url;
            this.headerView.update(url);

            this.api = new SwaggerClient(this.options);
        },

        // collapse all sections
        collapseAll: function () {
            Docs.collapseEndpointListForResource('');
        },

        // list operations for all sections
        listAll: function () {
            Docs.collapseOperationsForResource('');
        },

        // expand operations for all sections
        expandAll: function () {
            Docs.expandOperationsForResource('');
        },

        // This is bound to success handler for SwaggerApi
        //  so it gets called when SwaggerApi completes loading
        render: function () {
            this.showMessage('Finished Loading Resource Information. Rendering Swagger UI...');
            this.mainView = new SwaggerUi.Views.MainView({
                model: this.api,
                el: $('#' + this.dom_id),
                swaggerOptions: this.options,
                router: this
            }).render();
            this.showMessage();

            switch (this.options.docExpansion) {
                case 'full':
                    this.expandAll(); break;

                case 'list':
                    this.listAll(); break;
                default:
                    break;
            }
            this.renderGFM();

            if (this.options.onComplete) {
                this.options.onComplete(this.api, this);
            }

            setTimeout(Docs.shebang.bind(this), 100);
        },

        buildUrl: function (base, url) {
            if (url.indexOf('/') === 0) {
                var parts = base.split('/');

                base = parts[0] + '//' + parts[2];

                return base + url;
            }
            var endOfPath = base.length;

            if (base.indexOf('?') > -1) {
                endOfPath = Math.min(endOfPath, base.indexOf('?'));
            }

            if (base.indexOf('#') > -1) {
                endOfPath = Math.min(endOfPath, base.indexOf('#'));
            }

            base = base.substring(0, endOfPath);

            if (base.indexOf('/', base.length - 1) !== -1) {
                return base + url;
            }

            return base + '/' + url;

        },

        // Shows message on topbar of the ui
        showMessage: function (data) {
            if (data === undefined) {
                data = '';
            }
            var $msgbar = $('#message-bar');

            $msgbar.removeClass('message-fail');
            $msgbar.addClass('message-success');
            $msgbar.html(data);

            if (window.SwaggerTranslator) {
                window.SwaggerTranslator.translate($msgbar);
            }
        },

        // shows message in red
        onLoadFailure: function (data) {
            if (data === undefined) {
                data = '';
            }
            $('#message-bar').removeClass('message-success');
            $('#message-bar').addClass('message-fail');

            var val = $('#message-bar').text(data);

            if (this.options.onFailure) {
                this.options.onFailure(data);
            }

            return val;
        },

        // Renders GFM for elements with 'markdown' class
        renderGFM: function () {
            $('.markdown').each(function () {
                $(this).html(marked($(this).html()));
            });

            $('.propDesc', '.model-signature .description').each(function () {
                $(this).html(marked($(this).html())).addClass('markdown');
            });
        }

    });

    window.SwaggerUi.Views = {};

    // don't break backward compatibility with previous versions and warn users to upgrade their code
    (function () {
        window.authorizations = {
            add: function () {
                warn('Using window.authorizations is deprecated. Please use SwaggerUi.api.clientAuthorizations.add().');

                if (typeof window.swaggerUi === 'undefined') {
                    throw new TypeError('window.swaggerUi is not defined');
                }

                if (window.swaggerUi instanceof SwaggerUi) {
                    window.swaggerUi.api.clientAuthorizations.add.apply(window.swaggerUi.api.clientAuthorizations, arguments);
                }
            }
        };

        window.ApiKeyAuthorization = function () {
            warn('window.ApiKeyAuthorization is deprecated. Please use SwaggerClient.ApiKeyAuthorization.');
            SwaggerClient.ApiKeyAuthorization.apply(window, arguments);
        };

        window.PasswordAuthorization = function () {
            warn('window.PasswordAuthorization is deprecated. Please use SwaggerClient.PasswordAuthorization.');
            SwaggerClient.PasswordAuthorization.apply(window, arguments);
        };

        function warn(message) {
            if ('console' in window && typeof window.console.warn === 'function') {
                console.warn(message);
            }
        }
    })();


    // UMD
    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            // AMD. Register as an anonymous module.
            define(['b'], function (b) {
                return root.SwaggerUi = factory(b);
            });
        } else if (typeof exports === 'object') {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like environments that support module.exports,
            // like Node.
            module.exports = factory(require('b'));
        } else {
            // Browser globals
            root.SwaggerUi = factory(root.b);
        }
    }(this, function () {
        return SwaggerUi;
    }));

    'use strict';

    SwaggerUi.Views.ApiKeyButton = Backbone.View.extend({ // TODO: append this to global SwaggerUi

        events: {
            'click #apikey_button': 'toggleApiKeyContainer',
            'click #apply_api_key': 'applyApiKey'
        },

        initialize: function (opts) {
            this.options = opts || {};
            this.router = this.options.router;
        },

        render: function () {
            var template = this.template();

            $(this.el).html(template(this.model));

            return this;
        },

        applyApiKey: function () {
            var keyAuth = new SwaggerClient.ApiKeyAuthorization(
                this.model.name,
                $('#input_apiKey_entry').val(),
                this.model.in
            );

            this.router.api.clientAuthorizations.add(this.model.name, keyAuth);
            this.router.load();
            $('#apikey_container').show();
        },

        toggleApiKeyContainer: function () {
            if ($('#apikey_container').length) {

                var elem = $('#apikey_container').first();

                if (elem.is(':visible')) {
                    elem.hide();
                } else {

                    // hide others
                    $('.auth_container').hide();
                    elem.show();
                }
            }
        },

        template: function () {
            return Handlebars.templates.apikey_button_view;
        }

    });
    'use strict';

    SwaggerUi.Views.BasicAuthButton = Backbone.View.extend({

        initialize: function (opts) {
            this.options = opts || {};
            this.router = this.options.router;
        },

        render: function () {
            var template = this.template();

            $(this.el).html(template(this.model));

            return this;
        },

        events: {
            'click #basic_auth_button': 'togglePasswordContainer',
            'click #apply_basic_auth': 'applyPassword'
        },

        applyPassword: function () {
            var username = $('.input_username').val();
            var password = $('.input_password').val();
            var basicAuth = new SwaggerClient.PasswordAuthorization('basic', username, password);

            this.router.api.clientAuthorizations.add(this.model.type, basicAuth);
            this.router.load();
            $('#basic_auth_container').hide();
        },

        togglePasswordContainer: function () {
            if ($('#basic_auth_container').length) {
                var elem = $('#basic_auth_container').show();

                if (elem.is(':visible')) {
                    elem.slideUp();
                } else {
                    // hide others
                    $('.auth_container').hide();
                    elem.show();
                }
            }
        },

        template: function () {
            return Handlebars.templates.basic_auth_button_view;
        }

    });
    'use strict';

    SwaggerUi.Views.ContentTypeView = Backbone.View.extend({
        initialize: function () {},

        render: function () {
            this.model.contentTypeId = 'ct' + Math.random();
            $(this.el).html(Handlebars.templates.content_type(this.model));

            return this;
        }
    });
    'use strict';

    SwaggerUi.Views.HeaderView = Backbone.View.extend({
        events: {
            'click #show-pet-store-icon': 'showPetStore',
            'click #explore': 'showCustom',
            'keyup #input_baseUrl': 'showCustomOnKeyup',
            'keyup #input_apiKey': 'showCustomOnKeyup'
        },

        initialize: function () {},

        showPetStore: function () {
            this.trigger('update-swagger-ui', {
                url: 'http://petstore.swagger.io/v2/swagger.json'
            });
        },

        showCustomOnKeyup: function (e) {
            if (e.keyCode === 13) {
                this.showCustom();
            }
        },

        showCustom: function (e) {
            if (e) {
                e.preventDefault();
            }

            this.trigger('update-swagger-ui', {
                url: $('#input_baseUrl').val(),
                apiKey: $('#input_apiKey').val()
            });
        },

        update: function (url, apiKey, trigger) {
            if (trigger === undefined) {
                trigger = false;
            }

            $('#input_baseUrl').val(url);

            //$('#input_apiKey').val(apiKey);
            if (trigger) {
                this.trigger('update-swagger-ui', {
                    url: url
                });
            }
        }
    });

    'use strict';

    SwaggerUi.Views.MainView = Backbone.View.extend({
        apisSorter: {
            alpha: function (a, b) {
                return a.name.localeCompare(b.name);
            }
        },
        operationsSorters: {
            alpha: function (a, b) {
                return a.path.localeCompare(b.path);
            },
            method: function (a, b) {
                return a.method.localeCompare(b.method);
            }
        },
        initialize: function (opts) {
            var sorterOption, sorterFn, key, value;

            opts = opts || {};

            this.router = opts.router;

            // Sort APIs
            if (opts.swaggerOptions.apisSorter) {
                sorterOption = opts.swaggerOptions.apisSorter;

                if (_.isFunction(sorterOption)) {
                    sorterFn = sorterOption;
                } else {
                    sorterFn = this.apisSorter[sorterOption];
                }

                if (_.isFunction(sorterFn)) {
                    this.model.apisArray.sort(sorterFn);
                }
            }
            // Sort operations of each API
            if (opts.swaggerOptions.operationsSorter) {
                sorterOption = opts.swaggerOptions.operationsSorter;

                if (_.isFunction(sorterOption)) {
                    sorterFn = sorterOption;
                } else {
                    sorterFn = this.operationsSorters[sorterOption];
                }

                if (_.isFunction(sorterFn)) {
                    for (key in this.model.apisArray) {
                        this.model.apisArray[key].operationsArray.sort(sorterFn);
                    }
                }
            }

            // set up the UI for input
            this.model.auths = [];

            for (key in this.model.securityDefinitions) {
                value = this.model.securityDefinitions[key];

                this.model.auths.push({
                    name: key,
                    type: value.type,
                    value: value
                });
            }

            if ('validatorUrl' in opts.swaggerOptions) {
                // Validator URL specified explicitly
                this.model.validatorUrl = opts.swaggerOptions.validatorUrl;
            } else if (this.model.url.indexOf('localhost') > 0) {
                // Localhost override
                this.model.validatorUrl = null;
            } else {
                // Default validator
                if (window.location.protocol === 'https:') {
                    this.model.validatorUrl = 'https://online.swagger.io/validator';
                } else {
                    this.model.validatorUrl = 'http://online.swagger.io/validator';
                }
            }
        },

        render: function () {
            if (this.model.securityDefinitions) {
                for (var name in this.model.securityDefinitions) {
                    var auth = this.model.securityDefinitions[name];
                    var button;

                    if (auth.type === 'apiKey' && $('#apikey_button').length === 0) {
                        button = new SwaggerUi.Views.ApiKeyButton({
                            model: auth, router:  this.router
                        }).render().el;
                        $('.auth_main_container').append(button);
                    }

                    if (auth.type === 'basicAuth' && $('#basic_auth_button').length === 0) {
                        button = new SwaggerUi.Views.BasicAuthButton({
                            model: auth, router: this.router
                        }).render().el;
                        $('.auth_main_container').append(button);
                    }
                }
            }

            // Render the outer container for resources
            $(this.el).html(Handlebars.templates.main(this.model));

            // Render each resource

            var resources = {};
            var counter = 0;

            for (var i = 0; i < this.model.apisArray.length; i++) {
                var resource = this.model.apisArray[i];
                var id = resource.name;

                while (typeof resources[id] !== 'undefined') {
                    id = id + '_' + counter;
                    counter += 1;
                }
                resource.id = id;
                resources[id] = resource;
                this.addResource(resource, this.model.auths);
            }

            $('.propWrap').hover(function onHover() {
                $('.optionsWrapper', $(this)).show();
            }, function offhover() {
                $('.optionsWrapper', $(this)).hide();
            });

            return this;
        },

        addResource: function (resource, auths) {
            // Render a resource and add it to resources li
            resource.id = resource.id.replace(/\s/g, '_');
            var resourceView = new SwaggerUi.Views.ResourceView({
                model: resource,
                router: this.router,
                tagName: 'li',
                id: 'resource_' + resource.id,
                className: 'resource',
                auths: auths,
                swaggerOptions: this.options.swaggerOptions
            });

            $('#resources', this.el).append(resourceView.render().el);
        },

        clear: function () {
            $(this.el).html('');
        }
    });

    'use strict';

    SwaggerUi.Views.OperationView = Backbone.View.extend({
        invocationUrl: null,

        events: {
            'submit .sandbox': 'submitOperation',
            'click .submit': 'submitOperation',
            'click .response_hider': 'hideResponse',
            'click .toggleOperation': 'toggleOperationContent',
            'mouseenter .api-ic': 'mouseEnter',
            'dblclick .curl': 'selectText'
        },

        initialize: function (opts) {
            opts = opts || {};
            this.router = opts.router;
            this.auths = opts.auths;
            this.parentId = this.model.parentId;
            this.nickname = this.model.nickname;
            this.model.encodedParentId = encodeURIComponent(this.parentId);

            return this;
        },

        selectText: function (event) {
            var doc = document,
                text = event.target.firstChild,
                range,
                selection;

            if (doc.body.createTextRange) {
                range = document.body.createTextRange();
                range.moveToElementText(text);
                range.select();
            } else if (window.getSelection) {
                selection = window.getSelection();
                range = document.createRange();
                range.selectNodeContents(text);
                selection.removeAllRanges();
                selection.addRange(range);
            }
        },

        mouseEnter: function (e) {
            var elem = $(this.el).find('.content');
            var x = e.pageX;
            var y = e.pageY;
            var scX = $(window).scrollLeft();
            var scY = $(window).scrollTop();
            var scMaxX = scX + $(window).width();
            var scMaxY = scY + $(window).height();
            var wd = elem.width();
            var hgh = elem.height();

            if (x + wd > scMaxX) {
                x = scMaxX - wd;
            }

            if (x < scX) {
                x = scX;
            }

            if (y + hgh > scMaxY) {
                y = scMaxY - hgh;
            }

            if (y < scY) {
                y = scY;
            }

            var pos = {};

            pos.top = y;
            pos.left = x;
            elem.css(pos);
        },

        // Note: copied from CoffeeScript compiled file
        // TODO: redactor
        render: function () {
            var a, auth, auths, code, contentTypeModel, isMethodSubmissionSupported, k, key, l, len, len1, len2, len3, len4, m, modelAuths, n, o, p, param, q, ref, ref1, ref2, ref3, ref4, ref5, responseContentTypeView, responseSignatureView, schema, schemaObj, scopeIndex, signatureModel, statusCode, successResponse, type, v, value;

            isMethodSubmissionSupported = jQuery.inArray(this.model.method, this.model.supportedSubmitMethods()) >= 0;

            if (!isMethodSubmissionSupported) {
                this.model.isReadOnly = true;
            }
            this.model.description = this.model.description || this.model.notes;
            this.model.oauth = null;
            modelAuths = this.model.authorizations || this.model.security;

            if (modelAuths) {
                if (Array.isArray(modelAuths)) {
                    for (l = 0, len = modelAuths.length; l < len; l++) {
                        auths = modelAuths[l];

                        for (key in auths) {
                            for (a in this.auths) {
                                auth = this.auths[a];

                                if (key === auth.name) {
                                    if (auth.type === 'oauth2') {
                                        this.model.oauth = {};
                                        this.model.oauth.scopes = [];
                                        ref1 = auth.value.scopes;

                                        for (k in ref1) {
                                            v = ref1[k];
                                            scopeIndex = auths[key].indexOf(k);

                                            if (scopeIndex >= 0) {
                                                o = {
                                                    scope: k,
                                                    description: v
                                                };
                                                this.model.oauth.scopes.push(o);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    for (k in modelAuths) {
                        v = modelAuths[k];

                        if (k === 'oauth2') {
                            if (this.model.oauth === null) {
                                this.model.oauth = {};
                            }

                            if (this.model.oauth.scopes ===

 void 0) {
                                this.model.oauth.scopes = [];
                            }

                            for (m = 0, len1 = v.length; m < len1; m++) {
                                o = v[m];
                                this.model.oauth.scopes.push(o);
                            }
                        }
                    }
                }
            }

            if (typeof this.model.responses !== 'undefined') {
                this.model.responseMessages = [];
                ref2 = this.model.responses;

                for (code in ref2) {
                    value = ref2[code];
                    schema = null;
                    schemaObj = this.model.responses[code].schema;

                    if (schemaObj && schemaObj.$ref) {
                        schema = schemaObj.$ref;

                        if (schema.indexOf('#/definitions/') === 0) {
                            schema = schema.substring('#/definitions/'.length);
                        }
                    }
                    this.model.responseMessages.push({
                        code: code,
                        message: value.description,
                        responseModel: schema
                    });
                }
            }

            if (typeof this.model.responseMessages === 'undefined') {
                this.model.responseMessages = [];
            }
            signatureModel = null;

            if (this.model.successResponse) {
                successResponse = this.model.successResponse;

                for (key in successResponse) {
                    value = successResponse[key];
                    this.model.successCode = key;

                    if (typeof value === 'object' && typeof value.createJSONSample === 'function') {
                        signatureModel = {
                            sampleJSON: JSON.stringify(value.createJSONSample(), void 0, 2),
                            isParam: false,
                            signature: value.getMockSignature()
                        };
                    }
                }
            } else if (this.model.responseClassSignature && this.model.responseClassSignature !== 'string') {
                signatureModel = {
                    sampleJSON: this.model.responseSampleJSON,
                    isParam: false,
                    signature: this.model.responseClassSignature
                };
            }
            var opts = this.options.swaggerOptions;

            if (opts.showRequestHeaders) {
                this.model.showRequestHeaders = true;
            }
            $(this.el).html(Handlebars.templates.operation(this.model));

            if (signatureModel) {
                responseSignatureView = new SwaggerUi.Views.SignatureView({
                    model: signatureModel,
                    router: this.router,
                    tagName: 'div'
                });
                $('.model-signature', $(this.el)).append(responseSignatureView.render().el);
            } else {
                this.model.responseClassSignature = 'string';
                $('.model-signature', $(this.el)).html(this.model.type);
            }
            contentTypeModel = {
                isParam: false
            };
            contentTypeModel.consumes = this.model.consumes;
            contentTypeModel.produces = this.model.produces;
            ref3 = this.model.parameters;

            for (n = 0, len2 = ref3.length; n < len2; n++) {
                param = ref3[n];
                type = param.type || param.dataType || '';

                if (typeof type === 'undefined') {
                    schema = param.schema;

                    if (schema && schema.$ref) {
                        ref = schema.$ref;

                        if (ref.indexOf('#/definitions/') === 0) {
                            type = ref.substring('#/definitions/'.length);
                        } else {
                            type = ref;
                        }
                    }
                }

                if (type && type.toLowerCase() === 'file') {
                    if (!contentTypeModel.consumes) {
                        contentTypeModel.consumes = 'multipart/form-data';
                    }
                }
                param.type = type;
            }
            responseContentTypeView = new SwaggerUi.Views.ResponseContentTypeView({
                model: contentTypeModel,
                router: this.router
            });
            $('.response-content-type', $(this.el)).append(responseContentTypeView.render().el);
            ref4 = this.model.parameters;

            for (p = 0, len3 = ref4.length; p < len3; p++) {
                param = ref4[p];
                this.addParameter(param, contentTypeModel.consumes);
            }
            ref5 = this.model.responseMessages;

            for (q = 0, len4 = ref5.length; q < len4; q++) {
                statusCode = ref5[q];
                this.addStatusCode(statusCode);
            }

            return this;
        },

        addParameter: function (param, consumes) {
            // Render a parameter
            param.consumes = consumes;
            var paramView = new SwaggerUi.Views.ParameterView({
                model: param,
                tagName: 'tr',
                readOnly: this.model.isReadOnly
            });

            $('.operation-params', $(this.el)).append(paramView.render().el);
        },

        addStatusCode: function (statusCode) {
            // Render status codes
            var statusCodeView = new SwaggerUi.Views.StatusCodeView({
                model: statusCode,
                tagName: 'tr',
                router: this.router
            });

            $('.operation-status', $(this.el)).append(statusCodeView.render().el);
        },

        // Note: copied from CoffeeScript compiled file
        // TODO: redactor
        submitOperation: function (e) {
            var error_free, form, isFileUpload, map, opts;

            if (e !== null) {
                e.preventDefault();
            }
            form = $('.sandbox', $(this.el));
            error_free = true;
            form.find('input.required').each(function () {
                $(this).removeClass('error');

                if (jQuery.trim($(this).val()) === '') {
                    $(this).addClass('error');
                    $(this).wiggle({
                        callback: (function (_this) {
                            return function () {
                                $(_this).focus();
                            };
                        })(this)
                    });
                    error_free = false;
                }
            });
            form.find('textarea.required').each(function () {
                $(this).removeClass('error');

                if (jQuery.trim($(this).val()) === '') {
                    $(this).addClass('error');
                    $(this).wiggle({
                        callback: (function (_this) {
                            return function () {
                                return $(_this).focus();
                            };
                        })(this)
                    });
                    error_free = false;
                }
            });
            form.find('select.required').each(function () {
                $(this).removeClass('error');

                if (this.selectedIndex === -1) {
                    $(this).addClass('error');
                    $(this).wiggle({
                        callback: (function (_this) {
                            return function () {
                                $(_this).focus();
                            };
                        })(this)
                    });
                    error_free = false;
                }
            });

            if (error_free) {
                map = this.getInputMap(form);
                isFileUpload = this.isFileUpload(form);
                opts = {
                    parent: this
                };

                if (this.options.swaggerOptions) {
                    for (var key in this.options.swaggerOptions) {
                        opts[key] = this.options.swaggerOptions[key];
                    }
                }
                opts.responseContentType = $('div select[name=responseContentType]', $(this.el)).val();
                opts.requestContentType = $('div select[name=parameterContentType]', $(this.el)).val();
                $('.response_throbber', $(this.el)).show();

                if (isFileUpload) {
                    $('.request_url', $(this.el)).html('<pre></pre>');
                    $('.request_url pre', $(this.el)).text(this.invocationUrl);

                    opts.useJQuery = true;
                    map.parameterContentType = 'multipart/form-data';

                    return this.model.execute(map, opts, this.showCompleteStatus, this.showErrorStatus, this);
                }
                this.map = map;

                return this.model.execute(map, opts, this.showCompleteStatus, this.showErrorStatus, this);

            }
        },

        getInputMap: function (form) {
            var map, ref1, l, len, o, ref2, m, len1, val, ref3, n, len2;

            map = {};
            ref1 = form.find('input');

            for (l = 0, len = ref1.length; l < len; l++) {
                o = ref1[l];

                if (o.value !== null && jQuery.trim(o.value).length > 0) {
                    map[o.name] = o.value;
                }

                if (o.type === 'file') {
                    map[o.name] = o.files[0];
                }
            }
            ref2 = form.find('textarea');

            for (m = 0, len1 = ref2.length; m < len1; m++) {
                o = ref2[m];
                val = this.getTextAreaValue(o);

                if (val !== null && jQuery.trim(val).length > 0) {
                    map[o.name] = val;
                }
            }
            ref3 = form.find('select');

            for (n = 0, len2 = ref3.length; n < len2; n++) {
                o = ref3[n];
                val = this.getSelectedValue(o);

                if (val !== null && jQuery.trim(val).length > 0) {
                    map[o.name] = val;
                }
            }

            return map;
        },

        isFileUpload: function (form) {
            var ref1, l, len, o;
            var isFileUpload = false;

            ref1 = form.find('input');

            for (l = 0, len = ref1.length; l < len; l++) {
                o = ref1[l];

                if (o.type === 'file') {
                    isFileUpload = true;
                }
            }

            return isFileUpload;
        },

        success: function (response, parent) {
            parent.showCompleteStatus(response);
        },

        // wraps a jquery response as a shred response
        wrap: function (data) {
            var h, headerArray, headers, i, l, len, o;

            headers = {};
            headerArray = data.getAllResponseHeaders().split('\r');

            for (l = 0, len = headerArray.length; l < len; l++) {
                i = headerArray[l];
                h = i.match(/^([^:]*?):(.*)$/);

                if (!h) {
                    h = [];
                }
                h.shift();

                if (h[0] !==

 void 0 && h[1] !==

 void 0) {
                    headers[h[0].trim()] = h[1].trim();
                }
            }
            o = {};
            o.content = {};
            o.content.data = data.responseText;
            o.headers = headers;
            o.request = {};
            o.request.url = this.invocationUrl;
            o.status = data.status;

            return o;
        },

        getSelectedValue: function (select) {
            if (!select.multiple) {
                return select.value;
            }
            var options = [];

            for (var l = 0, len = select.options.length; l < len; l++) {
                var opt = select.options[l];

                if (opt.selected) {
                    options.push(opt.value);
                }
            }

            if (options.length > 0) {
                return options;
            }

            return null;

        },

        // handler for hide response link
        hideResponse: function (e) {
            if (e) {
                e.preventDefault();
            }
            $('.response', $(this.el)).slideUp();
            $('.response_hider', $(this.el)).fadeOut();
        },

        // Show response from server
        showResponse: function (response) {
            var prettyJson = JSON.stringify(response, null, '\t').replace(/\n/g, '<br>');

            $('.response_body', $(this.el)).html(_.escape(prettyJson));
        },

        // Show error from server
        showErrorStatus: function (data, parent) {
            parent.showStatus(data);
        },

        // show the status codes
        showCompleteStatus: function (data, parent) {
            parent.showStatus(data);
        },

        // Adapted from http://stackoverflow.com/a/2893259/454004
        // Note: directly ported from CoffeeScript
        // TODO: Cleanup CoffeeScript artifacts
        formatXml: function (xml) {
            var contexp, fn, formatted, indent, l, lastType, len, lines, ln, pad, reg, transitions, wsexp;

            reg = /(>)(<)(\/*)/g;
            wsexp = /[ ]*(.*)[ ]+\n/g;
            contexp = /(<.+>)(.+\n)/g;
            xml = xml.replace(reg, '$1\n$2$3').replace(wsexp, '$1\n').replace(contexp, '$1\n$2');
            pad = 0;
            formatted = '';
            lines = xml.split('\n');
            indent = 0;
            lastType = 'other';
            transitions = {
                'single->single': 0,
                'single->closing': -1,
                'single->opening': 0,
                'single->other': 0,
                'closing->single': 0,
                'closing->closing': -1,
                'closing->opening': 0,
                'closing->other': 0,
                'opening->single': 1,
                'opening->closing': 0,
                'opening->opening': 1,
                'opening->other': 1,
                'other->single': 0,
                'other->closing': -1,
                'other->opening': 0,
                'other->other': 0
            };
            fn = function (ln) {
                var fromTo, j, key, padding, type, types, value;

                types = {
                    single: Boolean(ln.match(/<.+\/>/)),
                    closing: Boolean(ln.match(/<\/.+>/)),
                    opening: Boolean(ln.match(/<[^!?].*>/))
                };
                type = ((function () {
                    var results;

                    results = [];

                    for (key in types) {
                        value = types[key];

                        if (value) {
                            results.push(key);
                        }
                    }

                    return results;
                })())[0];
                type = type ===

 void 0 ? 'other' : type;
                fromTo = lastType + '->' + type;
                lastType = type;
                padding = '';
                indent += transitions[fromTo];
                padding = ((function () {
                    var m, ref1, results;

                    results = [];

                    for (j = m = 0, ref1 = indent; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
                        results.push('  ');
                    }

                    return results;
                })()).join('');

                if (fromTo === 'opening->closing') {
                    formatted = formatted.substr(0, formatted.length - 1) + ln + '\n';
                } else {
                    formatted += padding + ln + '\n';
                }
            };

            for (l = 0, len = lines.length; l < len; l++) {
                ln = lines[l];
                fn(ln);
            }

            return formatted;
        },

        // puts the response data in UI
        showStatus: function (response) {
            var url, content;

            if (response.content === undefined) {
                content = response.data;
                url = response.url;
            } else {
                content = response.content.data;
                url = response.request.url;
            }
            var headers = response.headers;

            content = jQuery.trim(content);

            // if server is nice, and sends content-type back, we can use it
            var contentType = null;

            if (headers) {
                contentType = headers['Content-Type'] || headers['content-type'];

                if (contentType) {
                    contentType = contentType.split(';')[0].trim();
                }
            }
            $('.response_body', $(this.el)).removeClass('json');
            $('.response_body', $(this.el)).removeClass('xml');

            var supportsAudioPlayback = function (contentType) {
                var audioElement = document.createElement('audio');

                return !!(audioElement.canPlayType && audioElement.canPlayType(contentType).replace(/no/, ''));
            };

            var pre;
            var code;

            if (!content) {
                code = $('<code />').text('no content');
                pre = $('<pre class="json" />').append(code);

                // JSON
            } else if (contentType === 'application/json' || /\+json$/.test(contentType)) {
                var json = null;

                try {
                    json = JSON.stringify(JSON.parse(content), null, '  ');
                } catch (_error) {
                    json = 'can\'t parse JSON.  Raw result:\n\n' + content;
                }
                code = $('<code />').text(json);
                pre = $('<pre class="json" />').append(code);

                // XML
            } else if (contentType === 'application/xml' || /\+xml$/.test(contentType)) {
                code = $('<code />').text(this.formatXml(content));
                pre = $('<pre class="xml" />').append(code);

                // HTML
            } else if (contentType === 'text/html') {
                code = $('<code />').html(_.escape(content));
                pre = $('<pre class="xml" />').append(code);

                // Plain Text
            } else if (/text\/plain/.test(contentType)) {
                code = $('<code />').text(content);
                pre = $('<pre class="plain" />').append(code);


                // Image
            } else if (/^image\//.test(contentType)) {
                pre = $('<img>').attr('src', url);

                // Audio
            } else if (/^audio\//.test(contentType) && supportsAudioPlayback(contentType)) {
                pre = $('<audio controls>').append($('<source>').attr('src', url).attr('type', contentType));

                // Download
            } else if (headers['Content-Disposition'] && (/attachment/).test(headers['Content-Disposition']) ||
                headers['content-disposition'] && (/attachment/).test(headers['content-disposition']) ||
                headers['Content-Description'] && (/File Transfer/).test(headers['Content-Description']) ||
                headers['content-description'] && (/File Transfer/).test(headers['content-description'])) {

                if ('Blob' in window) {
                    var type = contentType || 'text/html';
                    var blob = new Blob([content], {
                        type: type
                    });
                    var a = document.createElement('a');
                    var href = window.URL.createObjectURL(blob);
                    var fileName = response.url.substr(response.url.lastIndexOf('/') + 1);
                    var download = [type, fileName, href].join(':');

                    a.setAttribute('href', href);
                    a.setAttribute('download', download);
                    a.innerText = 'Download ' + fileName;

                    pre = $('<div/>').append(a);
                } else {
                    pre = $('<pre class="json" />').append('Download headers detected but your browser does not support downloading binary via XHR (Blob).');
                }

                // Location header based redirect download
            } else if (headers.location || headers.Location) {
                window.location = response.url;

                // Anything else (CORS)
            } else {
                code = $('<code />').text(content);
                pre = $('<pre class="json" />').append(code);
            }
            var response_body = pre;

            $('.request_url', $(this.el)).html('<pre></pre>');
            $('.request_url pre', $(this.el)).text(url);
            $('.response_code', $(this.el)).html('<pre>' + response.status + '</pre>');
            $('.response_body', $(this.el)).html(response_body);
            $('.response_headers', $(this.el)).html('<pre>' + _.escape(JSON.stringify(response.headers, null, '  ')).replace(/\n/g, '<br>') + '</pre>');
            $('.response', $(this.el)).slideDown();
            $('.response_hider', $(this.el)).show();
            $('.response_throbber', $(this.el)).hide();


            //adds curl output
            var curlCommand = this.model.asCurl(this.map);

            curlCommand = curlCommand.replace('!', '&#33;');
            $('.curl', $(this.el)).html('<pre>' + curlCommand + '</pre>');

            // only highlight the response if response is less than threshold, default state is highlight response
            var opts = this.options.swaggerOptions;

            if (opts.showRequestHeaders) {
                var form = $('.sandbox', $(this.el)),
                    map = this.getInputMap(form),
                    requestHeaders = this.model.getHeaderParams(map);

                delete requestHeaders['Content-Type'];
                $('.request_headers', $(this.el)).html('<pre>' + _.escape(JSON.stringify(requestHeaders, null, '  ')).replace(/\n/g, '<br>') + '</pre>');
            }

            var response_body_el = $('.response_body', $(this.el))[0];
            // only highlight the response if response is less than threshold, default state is highlight response

            if (opts.highlightSizeThreshold && typeof response.data !== 'undefined' && response.data.length > opts.highlightSizeThreshold) {
                return response_body_el;
            }

            return hljs.highlightBlock(response_body_el);

        },

        toggleOperationContent: function (event) {
            var elem = $('#' + Docs.escapeResourceName(this.parentId + '_' + this.nickname + '_content'));

            if (elem.is(':visible')) {
                event.preventDefault();
                $.bbq.pushState('#/', 2);
                Docs.collapseOperation(elem);
            } else {
                Docs.expandOperation(elem);
            }
        },

        getTextAreaValue: function (textArea) {
            var param, parsed, result, i;

            if (textArea.value === null || jQuery.trim(textArea.value).length === 0) {
                return null;
            }
            param = this.getParamByName(textArea.name);

            if (param && param.type && param.type.toLowerCase() === 'array') {
                parsed = textArea.value.split('\n');
                result = [];

                for (i = 0; i < parsed.length; i++) {
                    if (parsed[i] !== null && jQuery.trim(parsed[i]).length > 0) {
                        result.push(parsed[i]);
                    }
                }

                return result.length > 0 ? result : null;
            }

            return textArea.value;

        },

        getParamByName: function (name) {
            var i;

            if (this.model.parameters) {
                for (i = 0; i < this.model.parameters.length; i++) {
                    if (this.model.parameters[i].name === name) {
                        return this.model.parameters[i];
                    }
                }
            }

            return null;
        }

    });

    'use strict';

    SwaggerUi.Views.ParameterContentTypeView = Backbone.View.extend({
        initialize: function () {},

        render: function () {
            this.model.parameterContentTypeId = 'pct' + Math.random();
            $(this.el).html(Handlebars.templates.parameter_content_type(this.model));

            return this;
        }

    });
    'use strict';

    SwaggerUi.Views.ParameterView = Backbone.View.extend({
        initialize: function () {
            Handlebars.registerHelper('isArray', function (param, opts) {
                if (param.type.toLowerCase() === 'array' || param.allowMultiple) {
                    return opts.fn(this);
                }

                return opts.inverse(this);

            });
        },

        render: function () {
            var type = this.model.type || this.model.dataType;

            if (typeof type === 'undefined') {
                var schema = this.model.schema;

                if (schema && schema.$ref) {
                    var ref = schema.$ref;

                    if (ref.indexOf('#/definitions/') === 0) {
                        type = ref.substring('#/definitions/'.length);
                    } else {
                        type = ref;
                    }
                }
            }

            this.model.type = type;
            this.model.paramType = this.model.in || this.model.paramType;
            this.model.isBody = this.model.paramType === 'body' || this.model.in === 'body';
            this.model.isFile = type && type.toLowerCase() === 'file';

            // Allow for default === false
            if (typeof this.model.default === 'undefined') {
                this.model.default = this.model.defaultValue;
            }

            this.model.hasDefault = typeof this.model.default !== 'undefined';
            this.model.valueId = 'm' + this.model.name + Math.random();

            if (this.model.allowableValues) {
                this.model.isList = true;
            }

            var template = this.template();

            $(this.el).html(template(this.model));

            var signatureModel = {
                sampleJSON: this.model.sampleJSON,
                isParam: true,
                signature: this.model.signature
            };

            if (this.model.sampleJSON) {
                var signatureView = new SwaggerUi.Views.SignatureView({
                    model: signatureModel, tagName: 'div'
                });

                $('.model-signature', $(this.el)).append(signatureView.render().el);
            } else {
                $('.model-signature', $(this.el)).html(this.model.signature);
            }

            var isParam = false;

            if (this.model.isBody) {
                isParam = true;
            }

            var contentTypeModel = {
                isParam: isParam
            };

            contentTypeModel.consumes = this.model.consumes;

            if (isParam) {
                var parameterContentTypeView = new SwaggerUi.Views.ParameterContentTypeView({
                    model: contentTypeModel
                });

                $('.parameter-content-type', $(this.el)).append(parameterContentTypeView.render().el);
            } else {
                var responseContentTypeView = new SwaggerUi.Views.ResponseContentTypeView({
                    model: contentTypeModel
                });

                $('.response-content-type', $(this.el)).append(responseContentTypeView.render().el);
            }

            return this;
        },

        // Return an appropriate template based on if the parameter is a list, readonly, required
        template: function () {
            if (this.model.isList) {
                return Handlebars.templates.param_list;
            }

            if (this.options.readOnly) {
                if (this.model.required) {
                    return Handlebars.templates.param_readonly_required;
                }

                return Handlebars.templates.param_readonly;

            }

            if (this.model.required) {
                return Handlebars.templates.param_required;
            }

            return Handlebars.templates.param;

        }
    });

    'use strict';

    SwaggerUi.Views.ResourceView = Backbone.View.extend({
        initialize: function (opts) {
            opts = opts || {};
            this.router = opts.router;
            this.auths = opts.auths;

            if ('' === this.model.description) {
                this.model.description = null;
            }

            if (this.model.description) {
                this.model.summary = this.model.description;
            }
        },

        render: function () {
            var methods = {};

            $(this.el).html(Handlebars.templates.resource(this.model));

            // Render each operation
            for (var i = 0; i < this.model.operationsArray.length; i++) {
                var operation = this.model.operationsArray[i];
                var counter = 0;
                var id = operation.nickname;

                while (typeof methods[id] !== 'undefined') {
                    id = id + '_' + counter;
                    counter += 1;
                }

                methods[id] = operation;

                operation.nickname = id;
                operation.parentId = this.model.id;
                this.addOperation(operation);
            }

            $('.toggleEndpointList', this.el).click(this.callDocs.bind(this, 'toggleEndpointListForResource'));
            $('.collapseResource', this.el).click(this.callDocs.bind(this, 'collapseOperationsForResource'));
            $('.expandResource', this.el).click(this.callDocs.bind(this, 'expandOperationsForResource'));

            return this;
        },

        addOperation: function (operation) {

            operation.number = this.number;

            // Render an operation and add it to operations li
            var operationView = new SwaggerUi.Views.OperationView({
                model: operation,
                router: this.router,
                tagName: 'li',
                className: 'endpoint',
                swaggerOptions: this.options.swaggerOptions,
                auths: this.auths
            });

            $('.endpoints', $(this.el)).append(operationView.render().el);

            this.number++;

        },
        // Generic Event handler (`Docs` is global)

        callDocs: function (fnName, e) {
            e.preventDefault();
            Docs[fnName](e.currentTarget.getAttribute('data-id'));
        }
    });
    'use strict';

    SwaggerUi.Views.ResponseContentTypeView = Backbone.View.extend({
        initialize: function () {},

        render: function () {
            this.model.responseContentTypeId = 'rct' + Math.random();
            $(this.el).html(Handlebars.templates.response_content_type(this.model));

            return this;
        }
    });
    'use strict';

    SwaggerUi.Views.SignatureView = Backbone.View.extend({
        events: {
            'click a.description-link': 'switchToDescription',
            'click a.snippet-link': 'switchToSnippet',
            'mousedown .snippet': 'snippetToTextArea'
        },

        initialize: function () {

        },

        render: function () {

            $(this.el).html(Handlebars.templates.signature(this.model));

            this.switchToSnippet();

            this.isParam = this.model.isParam;

            if (this.isParam) {
                $('.notice', $(this.el)).text('Click to set as parameter value');
            }

            return this;
        },

        // handler for show signature
        switchToDescription: function (e) {
            if (e) {
                e.preventDefault();
            }

            $('.snippet', $(this.el)).hide();
            $('.description', $(this.el)).show();
            $('.description-link', $(this.el)).addClass('selected');
            $('.snippet-link', $(this.el)).removeClass('selected');
        },

        // handler for show sample
        switchToSnippet: function (e) {
            if (e) {
                e.preventDefault();
            }

            $('.description', $(this.el)).hide();
            $('.snippet', $(this.el)).show();
            $('.snippet-link', $(this.el)).addClass('selected');
            $('.description-link', $(this.el)).removeClass('selected');
        },

        // handler for snippet to text area
        snippetToTextArea: function (e) {
            if (this.isParam) {
                if (e) {
                    e.preventDefault();
                }

                var textArea = $('textarea', $(this.el.parentNode.parentNode.parentNode));

                // Fix for bug in IE 10/11 which causes placeholder text to be copied to "value"
                if ($.trim(textArea.val()) === '' || textArea.prop('placeholder') === textArea.val()) {
                    textArea.val(this.model.sampleJSON);
                }
            }
        }
    });
    'use strict';

    SwaggerUi.Views.StatusCodeView = Backbone.View.extend({
        initialize: function (opts) {
            this.options = opts || {};
            this.router = this.options.router;
        },

        render: function () {
            $(this.el).html(Handlebars.templates.status_code(this.model));

            if (this.router.api.models.hasOwnProperty(this.model.responseModel)) {
                var responseModel = {
                    sampleJSON: JSON.stringify(this.router.api.models[this.model.responseModel].createJSONSample(), null, 2),
                    isParam: false,
                    signature: this.router.api.models[this.model.responseModel].getMockSignature()
                };

                var responseModelView = new SwaggerUi.Views.SignatureView({
                    model: responseModel, tagName: 'div'
                });

                $('.model-signature', this.$el).append(responseModelView.render().el);
            } else {
                $('.model-signature', this.$el).html('');
            }

            return this;
        }
    });
}).call(this);
